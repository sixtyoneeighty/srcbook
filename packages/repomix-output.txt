This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-10T07:59:38.812Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
api/
  ai/
    app-parser.mts
    config.mts
    generate.mts
    logger.mts
    plan-parser.mts
    stream-xml-parser.mts
  apps/
    templates/
      react-typescript/
        src/
          App.tsx
          index.css
          main.tsx
          vite-env.d.ts
        .gitignore
        index.html
        package.json
        postcss.config.js
        tailwind.config.js
        tsconfig.json
        vite.config.ts
    app.mts
    disk.mts
    git.mts
    processes.mts
    schemas.mts
    utils.mts
  db/
    index.mts
    schema.mts
  drizzle/
    meta/
      _journal.json
      0000_snapshot.json
      0001_snapshot.json
      0002_snapshot.json
      0003_snapshot.json
      0004_snapshot.json
      0005_snapshot.json
      0006_snapshot.json
      0007_snapshot.json
      0008_snapshot.json
      0009_snapshot.json
      0010_snapshot.json
      0011_snapshot.json
      0012_snapshot.json
      0013_snapshot.json
      0014_snapshot.json
      0015_snapshot.json
    0000_initial.sql
    0001_favorite_language.sql
    0002_add-openai-key.sql
    0003_posthog_analytics.sql
    0004_add_ai_config.sql
    0005_new_provider_ai_models.sql
    0006_deprecate_ai_config.sql
    0007_add_subscription_email.sql
    0008_add_secrets.sql
    0009_secret_session_unique.sql
    0010_create_apps.sql
    0011_apps_external_id_unique.sql
    0011_remove_language_from_apps.sql
    0012_add_app_history.sql
    0013_add_x_ai.sql
    0014_Gemini_Integration.sql
    0015_add_custom_api_key.sql
  prompts/
    app-builder.txt
    app-editor.txt
    cell-generator-javascript.txt
    cell-generator-typescript.txt
    code-updater-javascript.txt
    code-updater-typescript.txt
    fix-cell-diagnostics.txt
    srcbook-generator.txt
  server/
    channels/
      app.mts
    http.mts
    utils.mts
    ws-client.mts
    ws.mts
  srcbook/
    examples/
      getting-started.src.md
      langgraph-web-agent.src.md
      websockets.src.md
    config.mts
    examples.mts
    index.mts
    path.mts
  srcmd/
    decoding.mts
    encoding.mts
    paths.mts
    types.mts
  test/
    srcmd_files/
      mock_srcbook/
        src/
          foo.mjs
        package.json
        README.md
      srcbook.src.md
    app-parser.test.mts
    plan-chunks-2.txt
    plan-chunks.txt
    plan-parser.test.mts
    srcmd.test.mts
    streaming-xml-parser.test.mts
    tsserver.test.mts
    utils.mts
  tsserver/
    messages.mts
    tsserver.mts
    tsservers.mts
    utils.mts
  .eslintrc.cjs
  .npmignore
  CHANGELOG.md
  config.mts
  constants.mts
  deps.mts
  dev-server.mts
  drizzle.config.ts
  exec.mts
  fs-utils.mts
  index.mts
  package.json
  posthog-client.mts
  processes.mts
  session.mts
  srcmd.mts
  tsconfig.json
  tsconfig.lint.json
  tsservers.mts
  types.mts
  utils.mts
  vite-env.d.ts
  vite.config.ts
components/
  src/
    components/
      cells/
        code.tsx
        markdown.tsx
        title.tsx
      ui/
        button.tsx
        card.tsx
        collapsible.tsx
        command.tsx
        context-menu.tsx
        dialog.tsx
        dropdown-menu.tsx
        heading.tsx
        input.tsx
        navigation-menu.tsx
        popover.tsx
        resizable.tsx
        scroll-area.tsx
        select.tsx
        sheet.tsx
        sonner.tsx
        switch.tsx
        tabs.tsx
        textarea.tsx
        tooltip.tsx
        underline-flat-tabs.tsx
      ai-generate-tips-dialog.tsx
      cell-output.tsx
      delete-cell-dialog.tsx
      keyboard-shortcut.tsx
      logos.tsx
      use-cell.tsx
      use-theme.tsx
    lib/
      code-theme.ts
      utils.ts
    ui/
      heading.tsx
    index.tsx
    types.ts
  .eslintrc.cjs
  .npmignore
  CHANGELOG.md
  package.json
  tsconfig.json
  tsconfig.lint.json
configs/
  eslint/
    library.js
    react.js
  ts/
    base.json
    react-library.json
  package.json
shared/
  src/
    schemas/
      apps.mts
      cells.mts
      tsserver.mts
      websockets.mts
    types/
      apps.mts
      cells.mts
      feedback.mts
      history.mts
      secrets.mts
      tsserver.mts
      websockets.mts
    ai.mts
    utils.mts
  .eslintrc.cjs
  .npmignore
  CHANGELOG.md
  index.mts
  package.json
  tsconfig.json
  tsconfig.lint.json
web/
  src/
    clients/
      http/
        apps.ts
      websocket/
        channel.ts
        client.ts
        index.ts
    components/
      apps/
        lib/
          diff.ts
          file-tree.ts
          path.ts
        panels/
          explorer.tsx
          settings.tsx
        AiFeedbackModal.tsx
        bottom-drawer.tsx
        create-modal.tsx
        diff-modal.tsx
        diff-stats.tsx
        editor.tsx
        header.tsx
        local-storage.ts
        markdown.tsx
        package-install-toast.tsx
        sidebar.tsx
        types.ts
        use-app.tsx
        use-files.tsx
        use-logs.tsx
        use-package-json.tsx
        use-preview.tsx
        use-version.tsx
      cells/
        code.tsx
        generate-ai.tsx
        get-completions.ts
        hover.ts
        util.ts
      session-menu/
        index.tsx
        packages-panel.tsx
        secrets-panel.tsx
        settings-panel.tsx
        table-of-contents-panel.tsx
      ai-generate-tips-dialog.tsx
      chat.tsx
      collapsible-container.tsx
      delete-app-dialog.tsx
      delete-cell-dialog.tsx
      delete-srcbook-dialog.tsx
      drag-and-drop-srcmd-modal.tsx
      feedback-dialog.tsx
      generate-srcbook-modal.tsx
      import-export-srcbook-modal.tsx
      install-package-modal.tsx
      keyboard-shortcuts-dialog.tsx
      logos.tsx
      mailing-list-card.tsx
      navbar.tsx
      onboarding.tsx
      srcbook-cards.tsx
      srcmd-upload-drop-zone.tsx
      use-effect-once.tsx
      use-package-json.tsx
      use-settings.tsx
      use-tsconfig-json.tsx
    lib/
      environment.ts
      file-system-access.ts
      server.ts
      utils.ts
    routes/
      apps/
        context.tsx
        files-show.tsx
        files.tsx
        layout.tsx
        loaders.tsx
        preview.tsx
      home.tsx
      secrets.tsx
      session.tsx
      settings.tsx
    config.ts
    error.tsx
    index.css
    Layout.tsx
    LayoutNavbar.tsx
    main.tsx
    types.ts
    vite-env.d.ts
  .env.development
  .env.production
  .eslintrc.cjs
  CHANGELOG.md
  components.json
  index.html
  package.json
  postcss.config.js
  tailwind.config.js
  tsconfig.json
  tsconfig.lint.json
  vite.config.ts

================================================================
Repository Files
================================================================

================
File: api/ai/app-parser.mts
================
import { XMLParser } from 'fast-xml-parser';

// TODO reuse and cleanup types
export interface FileContent {
  filename: string;
  content: string;
}

export type Project = {
  id: string;
  items: (File | Command)[];
};

type File = {
  type: 'file';
  filename: string;
  content: string;
};

type Command = {
  type: 'command';
  content: string;
};

type ParsedResult = {
  project: {
    '@_id': string;
    file?: { '@_filename': string; '#text': string }[] | { '@_filename': string; '#text': string };
    command?: string[] | string;
  };
};

export function parseProjectXML(response: string): Project {
  try {
    const parser = new XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: '@_',
      textNodeName: '#text',
    });
    const result = parser.parse(response) as ParsedResult;

    if (!result.project) {
      throw new Error('Invalid response: missing project tag');
    }

    const project: Project = {
      id: result.project['@_id'],
      items: [],
    };

    const files = Array.isArray(result.project.file)
      ? result.project.file
      : [result.project.file].filter(Boolean);
    const commands = Array.isArray(result.project.command)
      ? result.project.command
      : [result.project.command].filter(Boolean);

    // TODO this ruins the order as it makes all the file changes first.
    // @FIXME: later
    for (const file of files) {
      if (file) {
        project.items.push({
          type: 'file',
          filename: file['@_filename'],
          content: file['#text'],
        });
      }
    }

    for (const command of commands) {
      if (command) {
        project.items.push({
          type: 'command',
          content: command,
        });
      }
    }

    return project;
  } catch (error) {
    console.error('Error parsing XML for the app:', error);
    throw new Error('Failed to parse XML response');
  }
}

export function buildProjectXml(files: FileContent[], projectId: string): string {
  const fileXmls = files
    .map(
      (file) => `
  <file filename="${file.filename}">
    <![CDATA[
${file.content}
    ]]>
  </file>`,
    )
    .join('\n');

  return `
<project id="${projectId}">
${fileXmls}
</project>
  `.trim();
}

================
File: api/ai/config.mts
================
import { createOpenAI } from '@ai-sdk/openai';
import { createAnthropic } from '@ai-sdk/anthropic';
import { getConfig } from '../config.mjs';
import type { LanguageModel } from 'ai';
import { getDefaultModel, type AiProviderType } from '@srcbook/shared';
import { createGoogleGenerativeAI } from '@ai-sdk/google';

/**
 * Get the correct client and model configuration.
 * Throws an error if the given API key is not set in the settings.
 */
export async function getModel(): Promise<LanguageModel> {
  const config = await getConfig();
  const { aiModel, aiProvider, aiBaseUrl } = config;
  const model = aiModel || getDefaultModel(aiProvider as AiProviderType);
  switch (aiProvider as AiProviderType) {
    case 'openai':
      if (!config.openaiKey) {
        throw new Error('OpenAI API key is not set');
      }
      const openai = createOpenAI({
        compatibility: 'strict', // strict mode, enabled when using the OpenAI API
        apiKey: config.openaiKey,
      });
      return openai(model);

    case 'anthropic':
      if (!config.anthropicKey) {
        throw new Error('Anthropic API key is not set');
      }
      const anthropic = createAnthropic({ apiKey: config.anthropicKey });
      return anthropic(model);

    case 'Gemini':
      if (!config.geminiKey) {
        throw new Error('Gemini API key is not set');
      }
      const google = createGoogleGenerativeAI({ apiKey: config.geminiKey });
      return google(model) as LanguageModel;

    case 'Xai':
      if (!config.xaiKey) {
        throw new Error('Xai API key is not set');
      }
      const xai = createOpenAI({
        compatibility: 'compatible',
        baseURL: 'https://api.x.ai/v1',
        apiKey: config.xaiKey,
      });
      return xai(model);

    case 'custom':
      if (typeof aiBaseUrl !== 'string') {
        throw new Error('Local AI base URL is not set');
      }
      const openaiCompatible = createOpenAI({
        compatibility: 'compatible',
        apiKey: config.customApiKey || 'bogus', // use custom API key if set, otherwise use a bogus key
        baseURL: aiBaseUrl,
      });
      return openaiCompatible(model);
  }
}

================
File: api/ai/generate.mts
================
import { streamText, generateText, type GenerateTextResult } from 'ai';
import { getModel } from './config.mjs';
import {
  type CodeLanguageType,
  type CellType,
  type CodeCellType,
  randomid,
  type CellWithPlaceholderType,
} from '@srcbook/shared';
import { type SessionType } from '../types.mjs';
import { readFileSync } from 'node:fs';
import Path from 'node:path';
import { PROMPTS_DIR } from '../constants.mjs';
import { encode, decodeCells } from '../srcmd.mjs';
import { buildProjectXml, type FileContent } from '../ai/app-parser.mjs';
import { logAppGeneration } from './logger.mjs';

const makeGenerateSrcbookSystemPrompt = () => {
  return readFileSync(Path.join(PROMPTS_DIR, 'srcbook-generator.txt'), 'utf-8');
};

const makeGenerateCellSystemPrompt = (language: CodeLanguageType) => {
  return readFileSync(Path.join(PROMPTS_DIR, `cell-generator-${language}.txt`), 'utf-8');
};

const makeFixDiagnosticsSystemPrompt = () => {
  return readFileSync(Path.join(PROMPTS_DIR, 'fix-cell-diagnostics.txt'), 'utf-8');
};
const makeAppBuilderSystemPrompt = () => {
  return readFileSync(Path.join(PROMPTS_DIR, 'app-builder.txt'), 'utf-8');
};
const makeAppEditorSystemPrompt = () => {
  return readFileSync(Path.join(PROMPTS_DIR, 'app-editor.txt'), 'utf-8');
};

const makeAppEditorUserPrompt = (projectId: string, files: FileContent[], query: string) => {
  const projectXml = buildProjectXml(files, projectId);
  const userRequestXml = `<userRequest>${query}</userRequest>`;
  return `Following below are the project XML and the user request.

${projectXml}

${userRequestXml}
  `.trim();
};

const makeAppCreateUserPrompt = (projectId: string, files: FileContent[], query: string) => {
  const projectXml = buildProjectXml(files, projectId);
  const userRequestXml = `<userRequest>${query}</userRequest>`;
  return `Following below are the project XML and the user request.

${projectXml}

${userRequestXml}
  `.trim();
};

const makeGenerateCellUserPrompt = (session: SessionType, insertIdx: number, query: string) => {
  // Make sure we copy cells so we don't mutate the session
  const cellsWithPlaceholder: CellWithPlaceholderType[] = [...session.cells];

  cellsWithPlaceholder.splice(insertIdx, 0, {
    id: randomid(),
    type: 'placeholder',
    text: '==== INTRODUCE CELL HERE ====',
  });

  // Intentionally not passing in tsconfig.json here as that doesn't need to be in the prompt.
  const inlineSrcbookWithPlaceholder = encode(
    { cells: cellsWithPlaceholder, language: session.language },
    {
      inline: true,
    },
  );

  const prompt = `==== BEGIN SRCBOOK ====
${inlineSrcbookWithPlaceholder}
==== END SRCBOOK ====

==== BEGIN USER REQUEST ====
${query}
==== END USER REQUEST ====`;
  return prompt;
};

const makeFixDiagnosticsUserPrompt = (
  session: SessionType,
  cell: CodeCellType,
  diagnostics: string,
) => {
  const inlineSrcbook = encode(
    { cells: session.cells, language: session.language },
    { inline: true },
  );
  const cellSource = cell.source;
  const prompt = `==== BEGIN SRCBOOK ====
${inlineSrcbook}
==== END SRCBOOK ====

==== BEGIN CODE CELL ====
${cellSource}
==== END CODE CELL ====

==== BEGIN DIAGNOSTICS ====
${diagnostics}
==== END DIAGNOSTICS ====
`;
  return prompt;
};

const makeGenerateCellEditSystemPrompt = (language: CodeLanguageType) => {
  return readFileSync(Path.join(PROMPTS_DIR, `code-updater-${language}.txt`), 'utf-8');
};

const makeGenerateCellEditUserPrompt = (
  query: string,
  session: SessionType,
  cell: CodeCellType,
) => {
  // Intentionally not passing in tsconfig.json here as that doesn't need to be in the prompt.
  const inlineSrcbook = encode(
    { cells: session.cells, language: session.language },
    { inline: true },
  );

  const prompt = `==== BEGIN SRCBOOK ====
${inlineSrcbook}
==== END SRCBOOK ====

==== BEGIN CODE CELL ====
${cell.source}
==== END CODE CELL ====

==== BEGIN USER REQUEST ====
${query}
==== END USER REQUEST ====
`;
  return prompt;
};

type NoToolsGenerateTextResult = GenerateTextResult<{}>;
/*
 * Given a user request, which is free form text describing their intent,
 * generate a srcbook using an LLM.
 *
 * Currently, this uses openAI and the GPT-4o model, and throws if the
 * openAI API key is not set in the settings.
 * In the future, we can parameterize this with different models, to allow
 * users to use different providers like Anthropic or local ones.
 */
export async function generateSrcbook(query: string): Promise<NoToolsGenerateTextResult> {
  const model = await getModel();
  const result = await generateText({
    model,
    system: makeGenerateSrcbookSystemPrompt(),
    prompt: query,
  });

  // TODO, handle 'length' finish reason with sequencing logic.
  if (result.finishReason !== 'stop') {
    console.warn('Generated a srcbook, but finish_reason was not "stop":', result.finishReason);
  }
  return result;
}

export async function healthcheck(): Promise<string> {
  const model = await getModel();
  const result = await generateText({
    model,
    system: 'This is a test, simply respond "yes" to confirm the model is working.',
    prompt: 'Are you working?',
  });
  return result.text;
}

type GenerateCellsResult = {
  error: boolean;
  errors?: string[];
  cells?: CellType[];
};
export async function generateCells(
  query: string,
  session: SessionType,
  insertIdx: number,
): Promise<GenerateCellsResult> {
  const model = await getModel();

  const systemPrompt = makeGenerateCellSystemPrompt(session.language);
  const userPrompt = makeGenerateCellUserPrompt(session, insertIdx, query);
  const result = await generateText({
    model,
    system: systemPrompt,
    prompt: userPrompt,
  });

  // TODO, handle 'length' finish reason with sequencing logic.
  if (result.finishReason !== 'stop') {
    console.warn('Generated a cell, but finish_reason was not "stop":', result.finishReason);
  }

  // Parse the result into cells
  // TODO: figure out logging.
  // Data is incredibly valuable for product improvements, but privacy needs to be considered.
  const decodeResult = decodeCells(result.text);

  if (decodeResult.error) {
    return { error: true, errors: decodeResult.errors };
  } else {
    return { error: false, cells: decodeResult.srcbook.cells };
  }
}

export async function generateCellEdit(query: string, session: SessionType, cell: CodeCellType) {
  const model = await getModel();

  const systemPrompt = makeGenerateCellEditSystemPrompt(session.language);
  const userPrompt = makeGenerateCellEditUserPrompt(query, session, cell);
  const result = await generateText({
    model,
    system: systemPrompt,
    prompt: userPrompt,
  });

  return result.text;
}

export async function fixDiagnostics(
  session: SessionType,
  cell: CodeCellType,
  diagnostics: string,
): Promise<string> {
  const model = await getModel();

  const systemPrompt = makeFixDiagnosticsSystemPrompt();
  const userPrompt = makeFixDiagnosticsUserPrompt(session, cell, diagnostics);

  const result = await generateText({
    model,
    system: systemPrompt,
    prompt: userPrompt,
  });

  return result.text;
}

export async function generateApp(
  projectId: string,
  files: FileContent[],
  query: string,
): Promise<string> {
  const model = await getModel();
  const result = await generateText({
    model,
    system: makeAppBuilderSystemPrompt(),
    prompt: makeAppCreateUserPrompt(projectId, files, query),
  });
  return result.text;
}

export async function streamEditApp(
  projectId: string,
  files: FileContent[],
  query: string,
  appId: string,
  planId: string,
) {
  const model = await getModel();

  const systemPrompt = makeAppEditorSystemPrompt();
  const userPrompt = makeAppEditorUserPrompt(projectId, files, query);

  let response = '';

  const result = await streamText({
    model,
    system: systemPrompt,
    prompt: userPrompt,
    onChunk: (chunk) => {
      if (chunk.chunk.type === 'text-delta') {
        response += chunk.chunk.textDelta;
      }
    },
    onFinish: () => {
      if (process.env.SRCBOOK_DISABLE_ANALYTICS !== 'true') {
        logAppGeneration({
          appId,
          planId,
          llm_request: { model, system: systemPrompt, prompt: userPrompt },
          llm_response: response,
        });
      }
    },
  });

  return result.textStream;
}

================
File: api/ai/logger.mts
================
export type AppGenerationLog = {
  appId: string;
  planId: string;
  llm_request: any;
  llm_response: any;
};

/*
 * Log the LLM request / response to the analytics server.
 * For now this server is a custom implemention, consider moving to
 * a formal LLM log service, or a generic log hosting service.
 * In particular, this will not scale well when we split up app generation into
 * multiple steps. We will need spans/traces at that point.
 */
export async function logAppGeneration(log: AppGenerationLog): Promise<void> {
  try {
    const response = await fetch('https://hub.srcbook.com/api/app_generation_log', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(log),
    });

    if (!response.ok) {
      console.error('Error sending app generation log');
    }
  } catch (error) {
    console.error('Error sending app generation log:', error);
  }
}

================
File: api/ai/plan-parser.mts
================
import { XMLParser } from 'fast-xml-parser';
import Path from 'node:path';
import { type App as DBAppType } from '../db/schema.mjs';
import { loadFile } from '../apps/disk.mjs';
import { StreamingXMLParser, TagType } from './stream-xml-parser.mjs';
import { ActionChunkType, DescriptionChunkType } from '@srcbook/shared';

// The ai proposes a plan that we expect to contain both files and commands
// Here is an example of a plan:

/*
 * Example of a plan:
 *
 * <plan>
 *   <action type="file">
 *     <description>{Short justification of changes. Be as brief as possible, like a commit message}</description>
 *     <file filename="package.json">
 *         <![CDATA[{entire file contents}]]]]>
 *     </file>
 *   </action>
 *   <action type="file">
 *     <description>
 *         <![CDATA[{Short description of changes}]]>
 *     </description>
 *     <file filename="./App.tsx">
 *       <![CDATA[
 *         {... file contents (ALL OF THE FILE)}
 *       ]]>
 *     </file>
 *   </action>
 *
 *  <action type="command">
 *    <description>
 *      <![CDATA[
 *        Install required packages for state management and routing
 *      ]]>
 *    </description>
 *    <commandType>npm install</commandType>
 *    <package>react-redux</package>
 *    <package>react-router-dom</package>
 *  </action>
 *   ...
 * </plan>
 */

interface FileAction {
  type: 'file';
  dirname: string;
  basename: string;
  path: string;
  modified: string;
  original: string | null; // null if this is a new file. Consider using an enum for 'edit' | 'create' | 'delete' instead.
  description: string;
}

type NpmInstallCommand = {
  type: 'command';
  command: 'npm install';
  packages: string[];
  description: string;
};

// Later we can add more commands. For now, we only support npm install
type Command = NpmInstallCommand;

export interface Plan {
  // The high level description of the plan
  // Will be shown to the user above the diff box.
  id: string;
  query: string;
  description: string;
  actions: (FileAction | Command)[];
}

interface ParsedResult {
  plan: {
    planDescription: string;
    action:
      | {
          '@_type': string;
          description: string;
          file?: { '@_filename': string; '#text': string };
          commandType?: string;
          package?: string | string[];
        }[]
      | {
          '@_type': string;
          description: string;
          file?: { '@_filename': string; '#text': string };
          commandType?: string;
          package?: string | string[];
        };
  };
}

export async function parsePlan(
  response: string,
  app: DBAppType,
  query: string,
  planId: string,
): Promise<Plan> {
  try {
    const parser = new XMLParser({
      ignoreAttributes: false,
      attributeNamePrefix: '@_',
      textNodeName: '#text',
    });
    const result = parser.parse(response) as ParsedResult;

    if (!result.plan) {
      throw new Error('Invalid response: missing plan tag');
    }

    const plan: Plan = {
      id: planId,
      query,
      actions: [],
      description: result.plan.planDescription,
    };
    const actions = Array.isArray(result.plan.action) ? result.plan.action : [result.plan.action];

    for (const action of actions) {
      if (action['@_type'] === 'file' && action.file) {
        const filePath = action.file['@_filename'];
        let originalContent = null;

        try {
          const fileContent = await loadFile(app, filePath);
          originalContent = fileContent.source;
        } catch (error) {
          // If the file doesn't exist, it's likely that it's a new file.
        }

        plan.actions.push({
          type: 'file',
          path: filePath,
          dirname: Path.dirname(filePath),
          basename: Path.basename(filePath),
          modified: action.file['#text'],
          original: originalContent,
          description: action.description,
        });
      } else if (action['@_type'] === 'command' && action.commandType === 'npm install') {
        if (!action.package) {
          console.error('Invalid response: missing package tag');
          continue;
        }
        plan.actions.push({
          type: 'command',
          command: 'npm install',
          packages: Array.isArray(action.package) ? action.package : [action.package],
          description: action.description,
        });
      }
    }

    return plan;
  } catch (error) {
    console.error('Error parsing XML:', error);
    throw new Error('Failed to parse XML response');
  }
}

export function getPackagesToInstall(plan: Plan): string[] {
  return plan.actions
    .filter(
      (action): action is NpmInstallCommand =>
        action.type === 'command' && action.command === 'npm install',
    )
    .flatMap((action) => action.packages);
}
export async function streamParsePlan(
  stream: AsyncIterable<string>,
  app: DBAppType,
  _query: string,
  planId: string,
) {
  let parser: StreamingXMLParser;
  const parsePromises: Promise<void>[] = [];

  return new ReadableStream({
    async pull(controller) {
      if (parser === undefined) {
        parser = new StreamingXMLParser({
          async onTag(tag) {
            if (tag.name === 'planDescription' || tag.name === 'action') {
              const promise = (async () => {
                const chunk = await toStreamingChunk(app, tag, planId);
                if (chunk) {
                  controller.enqueue(JSON.stringify(chunk) + '\n');
                }
              })();
              parsePromises.push(promise);
            }
          },
        });
      }

      try {
        for await (const chunk of stream) {
          parser.parse(chunk);
        }
        // Wait for all pending parse operations to complete before closing
        await Promise.all(parsePromises);
        controller.close();
      } catch (error) {
        console.error(error);
        controller.enqueue(
          JSON.stringify({
            type: 'error',
            data: { content: 'Error while parsing streaming response' },
          }) + '\n',
        );
        controller.error(error);
      }
    },
  });
}

async function toStreamingChunk(
  app: DBAppType,
  tag: TagType,
  planId: string,
): Promise<DescriptionChunkType | ActionChunkType | null> {
  switch (tag.name) {
    case 'planDescription':
      return {
        type: 'description',
        planId: planId,
        data: { content: tag.content },
      } as DescriptionChunkType;
    case 'action': {
      const descriptionTag = tag.children.find((t) => t.name === 'description');
      const description = descriptionTag?.content ?? '';
      const type = tag.attributes.type;

      if (type === 'file') {
        const fileTag = tag.children.find((t) => t.name === 'file')!;

        const filePath = fileTag.attributes.filename as string;
        let originalContent = null;

        try {
          const fileContent = await loadFile(app, filePath);
          originalContent = fileContent.source;
        } catch (error) {
          // If the file doesn't exist, it's likely that it's a new file.
        }

        return {
          type: 'action',
          planId: planId,
          data: {
            type: 'file',
            description,
            path: filePath,
            dirname: Path.dirname(filePath),
            basename: Path.basename(filePath),
            modified: fileTag.content,
            original: originalContent,
          },
        } as ActionChunkType;
      } else if (type === 'command') {
        const commandTag = tag.children.find((t) => t.name === 'commandType')!;
        const packageTags = tag.children.filter((t) => t.name === 'package');

        return {
          type: 'action',
          planId: planId,
          data: {
            type: 'command',
            description,
            command: commandTag.content,
            packages: packageTags.map((t) => t.content),
          },
        } as ActionChunkType;
      } else {
        return null;
      }
    }
    default:
      return null;
  }
}

================
File: api/ai/stream-xml-parser.mts
================
export type NodeSchema = {
  isContentNode?: boolean;
  hasCdata?: boolean;
  allowedChildren?: string[];
};

export const xmlSchema: Record<string, NodeSchema> = {
  plan: { isContentNode: false, hasCdata: false },
  action: { isContentNode: false, hasCdata: false },
  description: { isContentNode: true, hasCdata: true },
  file: { isContentNode: false, hasCdata: true },
  commandType: { isContentNode: true, hasCdata: false },
  package: { isContentNode: true, hasCdata: false },
  planDescription: { isContentNode: true, hasCdata: true },
};

export type TagType = {
  name: string;
  attributes: Record<string, string>;
  content: string;
  children: TagType[];
};

export type TagCallbackType = (tag: TagType) => void;

export class StreamingXMLParser {
  private buffer = '';
  private currentTag: TagType | null = null;
  private tagStack: TagType[] = [];
  private isInCDATA = false;
  private cdataBuffer = '';
  private textBuffer = '';
  private onTag: TagCallbackType;

  constructor({ onTag }: { onTag: TagCallbackType }) {
    this.onTag = onTag;
  }

  private parseAttributes(attributeString: string): Record<string, string> {
    const attributes: Record<string, string> = {};
    const matches = attributeString.match(/(\w+)="([^"]*?)"/g);

    if (matches) {
      matches.forEach((match) => {
        const [key, value] = match.split('=') as [string, string];
        attributes[key] = value.replace(/"/g, '');
      });
    }

    return attributes;
  }

  private handleOpenTag(tagContent: string) {
    // First, save any accumulated text content to the current tag
    if (this.currentTag && this.textBuffer.trim()) {
      this.currentTag.content = this.textBuffer.trim();
    }
    this.textBuffer = '';

    const spaceIndex = tagContent.indexOf(' ');
    const tagName = spaceIndex === -1 ? tagContent : tagContent.substring(0, spaceIndex);
    const attributeString = spaceIndex === -1 ? '' : tagContent.substring(spaceIndex + 1);

    const newTag: TagType = {
      name: tagName,
      attributes: this.parseAttributes(attributeString),
      content: '',
      children: [],
    };

    if (this.currentTag) {
      // Push current tag to stack before moving to new tag
      this.tagStack.push(this.currentTag);
      this.currentTag.children.push(newTag);
    }

    this.currentTag = newTag;
  }

  private handleCloseTag(tagName: string) {
    if (!this.currentTag) {
      console.warn('Attempted to handle close tag with no current tag');
      return;
    }

    // Save any remaining text content before closing
    // Don't overwrite CDATA content, it's already been written
    const schema = xmlSchema[this.currentTag.name];
    const isCdataNode = schema ? schema.hasCdata : false;
    if (!isCdataNode) {
      this.currentTag.content = this.textBuffer.trim();
    }
    this.textBuffer = '';

    if (this.currentTag.name !== tagName) {
      return;
    }

    // Clean and emit the completed tag
    this.currentTag = this.cleanNode(this.currentTag);
    this.onTag(this.currentTag);

    // Pop the parent tag from the stack
    if (this.tagStack.length > 0) {
      this.currentTag = this.tagStack.pop()!;
    } else {
      this.currentTag = null;
    }
  }

  private cleanNode(node: TagType): TagType {
    const schema = xmlSchema[node.name];

    // If it's not in the schema, default to treating it as a content node
    const isContentNode = schema ? schema.isContentNode : true;

    // If it's not a content node and has children, remove its content
    if (!isContentNode && node.children.length > 0) {
      node.content = '';
    }

    // Recursively clean children
    node.children = node.children.map((child) => this.cleanNode(child));

    return node;
  }

  parse(chunk: string) {
    this.buffer += chunk;

    while (this.buffer.length > 0) {
      // Handle CDATA sections
      if (this.isInCDATA) {
        const cdataEndIndex = this.cdataBuffer.indexOf(']]>');
        if (cdataEndIndex === -1) {
          this.cdataBuffer += this.buffer;
          // Sometimes ]]> is in the next chunk, and we don't want to lose what's behind it
          const nextCdataEnd = this.cdataBuffer.indexOf(']]>');
          if (nextCdataEnd !== -1) {
            this.buffer = this.cdataBuffer.substring(nextCdataEnd);
          } else {
            this.buffer = '';
          }
          return;
        }

        this.cdataBuffer = this.cdataBuffer.substring(0, cdataEndIndex);
        if (this.currentTag) {
          this.currentTag.content = this.cdataBuffer.trim();
        }
        this.isInCDATA = false;
        this.buffer = this.cdataBuffer.substring(cdataEndIndex + 3) + this.buffer;
        this.cdataBuffer = '';
        continue;
      }

      // Look for the next tag
      const openTagStartIdx = this.buffer.indexOf('<');
      if (openTagStartIdx === -1) {
        // No more tags in this chunk, save the rest as potential content
        this.textBuffer += this.buffer;
        this.buffer = '';
        return;
      }

      // Save any text content before this tag
      if (openTagStartIdx > 0) {
        this.textBuffer += this.buffer.substring(0, openTagStartIdx);
        this.buffer = this.buffer.substring(openTagStartIdx);
      }

      // Check for CDATA
      if (this.sequenceExistsAt('<![CDATA[', 0)) {
        this.isInCDATA = true;
        const cdataStart = this.buffer.substring(9);
        this.cdataBuffer = cdataStart;
        this.buffer = '';
        return;
      }

      const openTagEndIdx = this.buffer.indexOf('>');
      if (openTagEndIdx === -1) {
        return;
      }

      const tagContent = this.buffer.substring(1, openTagEndIdx);
      this.buffer = this.buffer.substring(openTagEndIdx + 1);

      if (tagContent.startsWith('/')) {
        // Closing tag
        this.handleCloseTag(tagContent.substring(1));
      } else {
        // Opening tag
        this.handleOpenTag(tagContent);
      }
    }
  }

  private sequenceExistsAt(sequence: string, idx: number, buffer: string = this.buffer) {
    for (let i = 0; i < sequence.length; i++) {
      if (buffer[idx + i] !== sequence[i]) {
        return false;
      }
    }
    return true;
  }
}

================
File: api/apps/templates/react-typescript/src/App.tsx
================
import './index.css'

function App() {

  return (
    <h1 className="text-3xl font-bold underline">
      Hello world!
    </h1>
  )
}

export default App

================
File: api/apps/templates/react-typescript/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
}

================
File: api/apps/templates/react-typescript/src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: api/apps/templates/react-typescript/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: api/apps/templates/react-typescript/.gitignore
================
# typical gitignore for web apps
node_modules
dist
.DS_Store

================
File: api/apps/templates/react-typescript/index.html
================
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vite + React + TS</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>

================
File: api/apps/templates/react-typescript/package.json
================
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "lucide-react": "^0.453.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.6",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.20",
    "globals": "^15.9.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.14",
    "typescript": "^5.5.3",
    "vite": "^5.4.6"
  }
}

================
File: api/apps/templates/react-typescript/postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: api/apps/templates/react-typescript/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

================
File: api/apps/templates/react-typescript/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"]
}

================
File: api/apps/templates/react-typescript/vite.config.ts
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
});

================
File: api/apps/app.mts
================
import { randomid, type AppType } from '@srcbook/shared';
import { db } from '../db/index.mjs';
import { type App as DBAppType, apps as appsTable } from '../db/schema.mjs';
import { applyPlan, createViteApp, deleteViteApp, getFlatFilesForApp } from './disk.mjs';
import { CreateAppSchemaType, CreateAppWithAiSchemaType } from './schemas.mjs';
import { asc, desc, eq } from 'drizzle-orm';
import { npmInstall } from './processes.mjs';
import { generateApp } from '../ai/generate.mjs';
import { toValidPackageName } from '../apps/utils.mjs';
import { getPackagesToInstall, parsePlan } from '../ai/plan-parser.mjs';
import { commitAllFiles, initRepo } from './git.mjs';

function toSecondsSinceEpoch(date: Date): number {
  return Math.floor(date.getTime() / 1000);
}

export function serializeApp(app: DBAppType): AppType {
  return {
    id: app.externalId,
    name: app.name,
    createdAt: toSecondsSinceEpoch(app.createdAt),
    updatedAt: toSecondsSinceEpoch(app.updatedAt),
  };
}

async function insert(attrs: Pick<DBAppType, 'name' | 'externalId'>): Promise<DBAppType> {
  const [app] = await db.insert(appsTable).values(attrs).returning();
  return app!;
}

export async function createAppWithAi(data: CreateAppWithAiSchemaType): Promise<DBAppType> {
  const app = await insert({
    name: data.name,
    externalId: randomid(),
  });

  await createViteApp(app);

  await initRepo(app);

  // Note: we don't surface issues or retries and this is "running in the background".
  // In this case it works in our favor because we'll kickoff generation while it happens
  const firstNpmInstallProcess = npmInstall(app.externalId, {
    stdout(data) {
      console.log(data.toString('utf8'));
    },
    stderr(data) {
      console.error(data.toString('utf8'));
    },
    onExit(code) {
      console.log(`npm install exit code: ${code}`);
    },
  });

  const files = await getFlatFilesForApp(app.externalId);
  const result = await generateApp(toValidPackageName(app.name), files, data.prompt);
  const plan = await parsePlan(result, app, data.prompt, randomid());
  await applyPlan(app, plan);

  const packagesToInstall = getPackagesToInstall(plan);

  if (packagesToInstall.length > 0) {
    await firstNpmInstallProcess;

    console.log('installing packages', packagesToInstall);
    npmInstall(app.externalId, {
      packages: packagesToInstall,
      stdout(data) {
        console.log(data.toString('utf8'));
      },
      stderr(data) {
        console.error(data.toString('utf8'));
      },
      onExit(code) {
        console.log(`npm install exit code: ${code}`);
        console.log('Applying git commit');
        commitAllFiles(app, `Add dependencies: ${packagesToInstall.join(', ')}`);
      },
    });
  }

  return app;
}
export async function createApp(data: CreateAppSchemaType): Promise<DBAppType> {
  const app = await insert({
    name: data.name,
    externalId: randomid(),
  });

  await createViteApp(app);

  // TODO: handle this better.
  // This should be done somewhere else and surface issues or retries.
  // Not awaiting here because it's "happening in the background".
  npmInstall(app.externalId, {
    stdout(data) {
      console.log(data.toString('utf8'));
    },
    stderr(data) {
      console.error(data.toString('utf8'));
    },
    onExit(code) {
      console.log(`npm install exit code: ${code}`);
    },
  });

  return app;
}

export async function deleteApp(id: string) {
  await db.delete(appsTable).where(eq(appsTable.externalId, id));
  await deleteViteApp(id);
}

export function loadApps(sort: 'asc' | 'desc') {
  const sorter = sort === 'asc' ? asc : desc;
  return db.select().from(appsTable).orderBy(sorter(appsTable.updatedAt));
}

export async function loadApp(id: string) {
  const [app] = await db.select().from(appsTable).where(eq(appsTable.externalId, id));
  return app;
}

export async function updateApp(id: string, attrs: { name: string }) {
  const [updatedApp] = await db
    .update(appsTable)
    .set({ name: attrs.name })
    .where(eq(appsTable.externalId, id))
    .returning();
  return updatedApp;
}

================
File: api/apps/disk.mts
================
import type { RmOptions } from 'node:fs';
import fs from 'node:fs/promises';
import type { Project } from '../ai/app-parser.mjs';
import Path from 'node:path';
import { fileURLToPath } from 'node:url';
import { type App as DBAppType } from '../db/schema.mjs';
import { APPS_DIR } from '../constants.mjs';
import { toValidPackageName } from './utils.mjs';
import { DirEntryType, FileEntryType, FileType } from '@srcbook/shared';
import { FileContent } from '../ai/app-parser.mjs';
import type { Plan } from '../ai/plan-parser.mjs';
import archiver from 'archiver';
import { wss } from '../index.mjs';

export function pathToApp(id: string) {
  return Path.join(APPS_DIR, id);
}

export function broadcastFileUpdated(app: DBAppType, file: FileType) {
  wss.broadcast(`app:${app.externalId}`, 'file:updated', { file });
}

// Use this rather than fs.writeFile to ensure we notify the client that the file has been updated.
export async function writeFile(app: DBAppType, file: FileType) {
  // Guard against absolute / relative path issues for safety
  let path = file.path;
  if (!path.startsWith(pathToApp(app.externalId))) {
    path = Path.join(pathToApp(app.externalId), file.path);
  }
  const dirPath = Path.dirname(path);
  await fs.mkdir(dirPath, { recursive: true });
  await fs.writeFile(path, file.source, 'utf-8');
  broadcastFileUpdated(app, file);
}

function pathToTemplate(template: string) {
  return Path.resolve(fileURLToPath(import.meta.url), '..', 'templates', template);
}

export function deleteViteApp(id: string) {
  return fs.rm(pathToApp(id), { recursive: true });
}

export async function applyPlan(app: DBAppType, plan: Plan) {
  try {
    for (const item of plan.actions) {
      if (item.type === 'file') {
        const basename = Path.basename(item.path);
        await writeFile(app, {
          path: item.path,
          name: basename,
          source: item.modified,
          binary: isBinary(basename),
        });
      }
    }
  } catch (e) {
    console.error('Error applying plan to app', app.externalId, e);
    throw e;
  }
}

export async function createAppFromProject(app: DBAppType, project: Project) {
  const appPath = pathToApp(app.externalId);
  await fs.mkdir(appPath, { recursive: true });

  for (const item of project.items) {
    if (item.type === 'file') {
      await writeFile(app, {
        path: item.filename,
        name: Path.basename(item.filename),
        source: item.content,
        binary: isBinary(Path.basename(item.filename)),
      });
    } else if (item.type === 'command') {
      // For now, we'll just log the commands
      // TODO: execute the commands in the right order.
      console.log(`Command to execute: ${item.content}`);
    }
  }
  return app;
}

export async function createViteApp(app: DBAppType) {
  const appPath = pathToApp(app.externalId);

  // Use recursive because its parent directory may not exist.
  await fs.mkdir(appPath, { recursive: true });

  // Scaffold all the necessary project files.
  await scaffold(app, appPath);

  return app;
}

/**
 * Scaffolds a new Vite app using a predefined template.
 *
 *
 * The current template includes: React, TypeScript, Vite, Tailwind CSS
 *
 * This function performs the following steps:
 * 1. Copies all template files to the destination directory
 * 2. Updates the package.json with the new app name
 * 3. Updates the index.html title with the app name
 *
 * @param {DBAppType} app - The database app object.
 * @param {string} destDir - The destination directory for the app.
 * @returns {Promise<void>}
 */
async function scaffold(app: DBAppType, destDir: string) {
  const template = `react-typescript`;

  function write(file: string, content?: string) {
    const targetPath = Path.join(destDir, file);
    return content === undefined
      ? copy(Path.join(templateDir, file), targetPath)
      : writeFile(app, {
          path: targetPath,
          name: Path.basename(targetPath),
          source: content,
          binary: isBinary(Path.basename(targetPath)),
        });
  }

  const templateDir = pathToTemplate(template);
  const files = await fs.readdir(templateDir);
  for (const file of files.filter((f) => f !== 'package.json')) {
    await write(file);
  }

  const [pkgContents, idxContents] = await Promise.all([
    fs.readFile(Path.join(templateDir, 'package.json'), 'utf-8'),
    fs.readFile(Path.join(templateDir, 'index.html'), 'utf-8'),
  ]);

  const pkg = JSON.parse(pkgContents);
  pkg.name = toValidPackageName(app.name);
  const updatedPkgContents = JSON.stringify(pkg, null, 2) + '\n';

  const updatedIdxContents = idxContents.replace(
    /<title>.*<\/title>/,
    `<title>${app.name}</title>`,
  );

  await Promise.all([
    write('package.json', updatedPkgContents),
    write('index.html', updatedIdxContents),
  ]);
}

export async function fileUpdated(app: DBAppType, file: FileType) {
  return writeFile(app, file);
}

async function copy(src: string, dest: string) {
  const stat = await fs.stat(src);
  if (stat.isDirectory()) {
    return copyDir(src, dest);
  } else {
    return fs.copyFile(src, dest);
  }
}

async function copyDir(srcDir: string, destDir: string) {
  await fs.mkdir(destDir, { recursive: true });
  const files = await fs.readdir(srcDir);
  for (const file of files) {
    const srcFile = Path.resolve(srcDir, file);
    const destFile = Path.resolve(destDir, file);
    await copy(srcFile, destFile);
  }
}

export async function loadDirectory(
  app: DBAppType,
  path: string,
  excludes = ['node_modules', 'dist', '.git'],
): Promise<DirEntryType> {
  const projectDir = Path.join(APPS_DIR, app.externalId);
  const dirPath = Path.join(projectDir, path);
  const entries = await fs.readdir(dirPath, { withFileTypes: true });

  const children = entries
    .filter((entry) => excludes.indexOf(entry.name) === -1)
    .map((entry) => {
      const fullPath = Path.join(dirPath, entry.name);
      const relativePath = Path.relative(projectDir, fullPath);
      const paths = getPathInfo(relativePath);
      return entry.isDirectory()
        ? { ...paths, type: 'directory' as const, children: null }
        : { ...paths, type: 'file' as const };
    });

  const relativePath = Path.relative(projectDir, dirPath);

  return {
    ...getPathInfo(relativePath),
    type: 'directory' as const,
    children: children,
  };
}

export async function createDirectory(
  app: DBAppType,
  dirname: string,
  basename: string,
): Promise<DirEntryType> {
  const projectDir = Path.join(APPS_DIR, app.externalId);
  const dirPath = Path.join(projectDir, dirname, basename);

  await fs.mkdir(dirPath, { recursive: false });

  const relativePath = Path.relative(projectDir, dirPath);

  return {
    ...getPathInfo(relativePath),
    type: 'directory' as const,
    children: null,
  };
}

export function deleteDirectory(app: DBAppType, path: string) {
  return deleteEntry(app, path, { recursive: true, force: true });
}

export async function renameDirectory(
  app: DBAppType,
  path: string,
  name: string,
): Promise<DirEntryType> {
  const result = await rename(app, path, name);
  return { ...result, type: 'directory' as const, children: null };
}

export async function loadFile(app: DBAppType, path: string): Promise<FileType> {
  const projectDir = Path.join(APPS_DIR, app.externalId);
  const filePath = Path.join(projectDir, path);
  const relativePath = Path.relative(projectDir, filePath);
  const basename = Path.basename(filePath);

  if (isBinary(basename)) {
    return { path: relativePath, name: basename, source: `TODO: handle this`, binary: true };
  } else {
    return {
      path: relativePath,
      name: basename,
      source: await fs.readFile(filePath, 'utf-8'),
      binary: false,
    };
  }
}

export async function createFile(
  app: DBAppType,
  dirname: string,
  basename: string,
  source: string,
): Promise<FileEntryType> {
  const filePath = Path.join(dirname, basename);

  await writeFile(app, {
    path: filePath,
    name: basename,
    source,
    binary: isBinary(basename),
  });
  return { ...getPathInfo(filePath), type: 'file' as const };
}

export function deleteFile(app: DBAppType, path: string) {
  return deleteEntry(app, path);
}

export async function renameFile(
  app: DBAppType,
  path: string,
  name: string,
): Promise<FileEntryType> {
  const result = await rename(app, path, name);
  return { ...result, type: 'file' as const };
}

async function rename(app: DBAppType, path: string, name: string) {
  const projectDir = Path.join(APPS_DIR, app.externalId);
  const oldPath = Path.join(projectDir, path);
  const dirname = Path.dirname(oldPath);
  const newPath = Path.join(dirname, name);
  await fs.rename(oldPath, newPath);
  const relativePath = Path.relative(projectDir, newPath);
  return getPathInfo(relativePath);
}

function deleteEntry(app: DBAppType, path: string, options: RmOptions = {}) {
  const filePath = Path.join(APPS_DIR, app.externalId, path);
  return fs.rm(filePath, options);
}

// TODO: This does not scale.
// What's the best way to know whether a file is a "binary"
// file or not? Inspecting bytes for invalid utf8?
const TEXT_FILE_EXTENSIONS = [
  '.ts',
  '.cts',
  '.mts',
  '.tsx',
  '.js',
  '.cjs',
  '.mjs',
  '.jsx',
  '.md',
  '.markdown',
  '.json',
  '.css',
  '.html',
];

export function toFileType(path: string, source: string): FileType {
  return {
    path,
    name: Path.basename(path),
    source,
    binary: isBinary(Path.basename(path)),
  };
}

function isBinary(basename: string) {
  const isDotfile = basename.startsWith('.'); // Assume these are text for now, e.g., .gitignore
  const isTextFile = TEXT_FILE_EXTENSIONS.includes(Path.extname(basename));
  return !(isDotfile || isTextFile);
}

function getPathInfo(path: string) {
  if (Path.isAbsolute(path)) {
    throw new Error(`Expected a relative path but got '${path}'`);
  }

  path = path === '' ? '.' : path;

  return {
    path: path,
    dirname: Path.dirname(path),
    basename: Path.basename(path),
  };
}

export async function getFlatFilesForApp(id: string): Promise<FileContent[]> {
  const appPath = pathToApp(id);
  return getFlatFiles(appPath);
}

async function getFlatFiles(dir: string, basePath: string = ''): Promise<FileContent[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  let files: FileContent[] = [];

  for (const entry of entries) {
    const relativePath = Path.join(basePath, entry.name);
    const fullPath = Path.join(dir, entry.name);

    if (entry.isDirectory()) {
      // TODO better ignore list mechanism. Should use a glob
      if (!['.git', 'node_modules'].includes(entry.name)) {
        files = files.concat(await getFlatFiles(fullPath, relativePath));
      }
    } else if (entry.isFile() && entry.name !== 'package-lock.json') {
      const content = await fs.readFile(fullPath, 'utf-8');
      files.push({ filename: relativePath, content });
    }
  }

  return files;
}

export async function createZipFromApp(app: DBAppType): Promise<Buffer> {
  const appPath = pathToApp(app.externalId);
  const archive = archiver('zip', { zlib: { level: 9 } });
  const chunks: any[] = [];

  return new Promise((resolve, reject) => {
    archive.directory(appPath, false);

    archive.on('error', (err) => {
      console.error('Error creating zip archive:', err);
      reject(err);
    });

    archive.on('data', (chunk: Buffer) => chunks.push(chunk));

    archive.on('end', () => {
      const buffer = Buffer.concat(chunks);
      resolve(buffer);
    });

    archive.finalize();
  });
}

================
File: api/apps/git.mts
================
import simpleGit, { SimpleGit, DefaultLogFields, ListLogLine } from 'simple-git';
import fs from 'node:fs/promises';
import { broadcastFileUpdated, pathToApp, toFileType } from './disk.mjs';
import type { App as DBAppType } from '../db/schema.mjs';
import Path from 'node:path';

// Helper to get git instance for an app
function getGit(app: DBAppType): SimpleGit {
  const dir = pathToApp(app.externalId);
  return simpleGit(dir);
}

// Initialize a git repository in the app directory
export async function initRepo(app: DBAppType): Promise<void> {
  const git = getGit(app);
  await git.init();
  await commitAllFiles(app, 'Initial commit');
}

// Commit all current files in the app directory
export async function commitAllFiles(app: DBAppType, message: string): Promise<string> {
  const git = getGit(app);

  // Stage all files
  await git.add('.');

  // Create commit
  await git.commit(message, {
    '--author': 'Srcbook <ai@srcbook.com>',
  });

  // Get the exact SHA of the new commit. Sometimes it's 'HEAD <sha>' for some reason
  const sha = await git.revparse(['HEAD']);
  return sha;
}

// Checkout to a specific commit, and notify the client that the files have changed
export async function checkoutCommit(app: DBAppType, commitSha: string): Promise<void> {
  const git = getGit(app);
  // get the files that are different between the current state and the commit
  const files = await getChangedFiles(app, commitSha);

  // we might have a dirty working directory, so we need to stash any changes
  // TODO: we should probably handle this better
  await git.stash();

  // checkout the commit
  await git.checkout(commitSha);

  // notify the client to update the files
  for (const file of files.added) {
    const source = await fs.readFile(Path.join(pathToApp(app.externalId), file), 'utf-8');
    broadcastFileUpdated(app, toFileType(file, source));
  }
  for (const file of files.modified) {
    const source = await fs.readFile(Path.join(pathToApp(app.externalId), file), 'utf-8');
    broadcastFileUpdated(app, toFileType(file, source));
  }
}

// Get commit history
export async function getCommitHistory(
  app: DBAppType,
  limit: number = 100,
): Promise<ReadonlyArray<DefaultLogFields & ListLogLine>> {
  const git = getGit(app);
  const log = await git.log({ maxCount: limit });
  return log.all;
}

// Helper function to ensure the repo exists
export async function ensureRepoExists(app: DBAppType): Promise<void> {
  const git = getGit(app);
  const isRepo = await git.checkIsRepo();

  if (!isRepo) {
    await initRepo(app);
  }
}

// Get the current commit SHA
export async function getCurrentCommitSha(app: DBAppType): Promise<string> {
  const git = getGit(app);
  // There might not be a .git initialized yet, so we need to handle that
  const isRepo = await git.checkIsRepo();
  if (!isRepo) {
    await initRepo(app);
  }

  const revparse = await git.revparse(['HEAD']);

  return revparse;
}

// Get list of changed files between current state and a commit
export async function getChangedFiles(
  app: DBAppType,
  commitSha: string,
): Promise<{ added: string[]; modified: string[]; deleted: string[] }> {
  const git = getGit(app);

  // Get the diff between current state and the specified commit
  const diffSummary = await git.diff(['--name-status', commitSha]);

  const changes = {
    added: [] as string[],
    modified: [] as string[],
    deleted: [] as string[],
  };

  // Parse the diff output
  diffSummary.split('\n').forEach((line) => {
    const [status, ...fileParts] = line.split('\t');
    const file = fileParts.join('\t'); // Handle filenames with tabs

    if (!file || !status) return;

    switch (status[0]) {
      case 'A':
        changes.added.push(file);
        break;
      case 'M':
        changes.modified.push(file);
        break;
      case 'D':
        changes.deleted.push(file);
        break;
    }
  });

  return changes;
}

================
File: api/apps/processes.mts
================
import { ChildProcess } from 'node:child_process';
import { pathToApp } from './disk.mjs';
import { npmInstall as execNpmInstall, vite as execVite } from '../exec.mjs';
import { wss } from '../index.mjs';

export type ProcessType = 'npm:install' | 'vite:server';

export interface NpmInstallProcessType {
  type: 'npm:install';
  process: ChildProcess;
}

export interface ViteServerProcessType {
  type: 'vite:server';
  process: ChildProcess;
  port: number | null;
}

export type AppProcessType = NpmInstallProcessType | ViteServerProcessType;

class Processes {
  private map: Map<string, AppProcessType> = new Map();

  has(appId: string, type: ProcessType) {
    return this.map.has(this.toKey(appId, type));
  }

  get(appId: string, type: ProcessType) {
    return this.map.get(this.toKey(appId, type));
  }

  set(appId: string, process: AppProcessType) {
    this.map.set(this.toKey(appId, process.type), process);
  }

  del(appId: string, type: ProcessType) {
    return this.map.delete(this.toKey(appId, type));
  }

  private toKey(appId: string, type: ProcessType) {
    return `${appId}:${type}`;
  }
}

const processes = new Processes();

export function getAppProcess(appId: string, type: 'npm:install'): NpmInstallProcessType;
export function getAppProcess(appId: string, type: 'vite:server'): ViteServerProcessType;
export function getAppProcess(appId: string, type: ProcessType): AppProcessType {
  switch (type) {
    case 'npm:install':
      return processes.get(appId, type) as NpmInstallProcessType;
    case 'vite:server':
      return processes.get(appId, type) as ViteServerProcessType;
  }
}

export function setAppProcess(appId: string, process: AppProcessType) {
  processes.set(appId, process);
}

export function deleteAppProcess(appId: string, process: ProcessType) {
  processes.del(appId, process);
}

async function waitForProcessToComplete(process: AppProcessType) {
  if (process.process.exitCode !== null) {
    return process;
  }

  return new Promise<AppProcessType>((resolve, reject) => {
    process.process.once('exit', () => {
      resolve(process);
    });
    process.process.once('error', (err) => {
      reject(err);
    });
  });
}

/**
 * Runs npm install for the given app.
 *
 * If there's already a process running npm install, it will return that process.
 */
export function npmInstall(
  appId: string,
  options: Omit<Partial<Parameters<typeof execNpmInstall>[0]>, 'cwd'> & { onStart?: () => void },
) {
  const runningProcess = processes.get(appId, 'npm:install');
  if (runningProcess) {
    return waitForProcessToComplete(runningProcess);
  }

  wss.broadcast(`app:${appId}`, 'deps:install:status', { status: 'installing' });
  if (options.onStart) {
    options.onStart();
  }

  const newlyStartedProcess: NpmInstallProcessType = {
    type: 'npm:install',
    process: execNpmInstall({
      ...options,

      cwd: pathToApp(appId),
      stdout: (data) => {
        wss.broadcast(`app:${appId}`, 'deps:install:log', {
          log: { type: 'stdout', data: data.toString('utf8') },
        });

        if (options.stdout) {
          options.stdout(data);
        }
      },
      stderr: (data) => {
        wss.broadcast(`app:${appId}`, 'deps:install:log', {
          log: { type: 'stderr', data: data.toString('utf8') },
        });

        if (options.stderr) {
          options.stderr(data);
        }
      },
      onExit: (code, signal) => {
        // We must clean up this process so that we can run npm install again
        deleteAppProcess(appId, 'npm:install');

        wss.broadcast(`app:${appId}`, 'deps:install:status', {
          status: code === 0 ? 'complete' : 'failed',
          code,
        });

        if (code === 0) {
          wss.broadcast(`app:${appId}`, 'deps:status:response', {
            nodeModulesExists: true,
          });
        }

        if (options.onExit) {
          options.onExit(code, signal);
        }
      },
    }),
  };
  processes.set(appId, newlyStartedProcess);

  return waitForProcessToComplete(newlyStartedProcess);
}

/**
 * Runs a vite dev server for the given app.
 *
 * If there's already a process running the vite dev server, it will return that process.
 */
export function viteServer(appId: string, options: Omit<Parameters<typeof execVite>[0], 'cwd'>) {
  if (!processes.has(appId, 'vite:server')) {
    processes.set(appId, {
      type: 'vite:server',
      process: execVite({ cwd: pathToApp(appId), ...options }),
      port: null,
    });
  }

  return processes.get(appId, 'vite:server');
}

================
File: api/apps/schemas.mts
================
import z from 'zod';

export const CreateAppSchema = z.object({
  name: z.string(),
  prompt: z.string().optional(),
});

export const CreateAppWithAiSchema = z.object({
  name: z.string(),
  prompt: z.string(),
});

export type CreateAppSchemaType = z.infer<typeof CreateAppSchema>;
export type CreateAppWithAiSchemaType = z.infer<typeof CreateAppWithAiSchema>;

================
File: api/apps/utils.mts
================
// Copied from https://github.com/vitejs/vite/tree/main/packages/create-vite
export function toValidPackageName(projectName: string) {
  return projectName
    .trim()
    .toLowerCase()
    .replace(/\s+/g, '-')
    .replace(/^[._]/, '')
    .replace(/[^a-z\d\-~]+/g, '-');
}

================
File: api/db/index.mts
================
import path from 'node:path';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';
import * as schema from './schema.mjs';
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
import { HOME_DIR, DIST_DIR, SRCBOOKS_DIR } from '../constants.mjs';
import fs from 'node:fs';

// We can't use a relative directory for drizzle since this application
// can get run from anywhere, so use DIST_DIR as ground truth.
const drizzleFolder = path.join(DIST_DIR, 'drizzle');

const DB_PATH = `${HOME_DIR}/.srcbook/srcbook.db`;

// Creates the HOME/.srcbook/srcbooks dir
fs.mkdirSync(SRCBOOKS_DIR, { recursive: true });

export const db = drizzle(new Database(DB_PATH), { schema });
migrate(db, { migrationsFolder: drizzleFolder });

================
File: api/db/schema.mts
================
import { sql } from 'drizzle-orm';
import { sqliteTable, text, integer, unique } from 'drizzle-orm/sqlite-core';
import { randomid } from '@srcbook/shared';

export const configs = sqliteTable('config', {
  // Directory where .src.md files will be stored and searched by default.
  baseDir: text('base_dir').notNull(),
  defaultLanguage: text('default_language').notNull().default('typescript'),
  openaiKey: text('openai_api_key'),
  anthropicKey: text('anthropic_api_key'),
  xaiKey: text('xai_api_key'),
  geminiKey: text('gemini_api_key'),
  customApiKey: text('custom_api_key'),
  // TODO: This is deprecated in favor of SRCBOOK_DISABLE_ANALYTICS env variable. Remove this.
  enabledAnalytics: integer('enabled_analytics', { mode: 'boolean' }).notNull().default(true),
  // Stable ID for posthog
  installId: text('srcbook_installation_id').notNull().default(randomid()),
  aiProvider: text('ai_provider').notNull().default('openai'),
  aiModel: text('ai_model').default('gpt-4o'),
  aiBaseUrl: text('ai_base_url'),
  // Null: unset. Email: subscribed. "dismissed": dismissed the dialog.
  subscriptionEmail: text('subscription_email'),
});

export type Config = typeof configs.$inferSelect;

export const secrets = sqliteTable('secrets', {
  id: integer('id').primaryKey(),
  name: text('name').notNull().unique(),
  value: text('value').notNull(),
});

export type Secret = typeof secrets.$inferSelect;

export const secretsToSession = sqliteTable(
  'secrets_to_sessions',
  {
    id: integer('id').primaryKey(),
    session_id: text('session_id').notNull(),
    secret_id: integer('secret_id')
      .notNull()
      .references(() => secrets.id),
  },
  (t) => ({
    unique_session_secret: unique().on(t.session_id, t.secret_id),
  }),
);

export type SecretsToSession = typeof secretsToSession.$inferSelect;

export const apps = sqliteTable('apps', {
  id: integer('id').primaryKey(),
  name: text('name').notNull(),
  externalId: text('external_id').notNull().unique(),
  history: text('history').notNull().default('[]'), // JSON encoded value of the history
  historyVersion: integer('history_version').notNull().default(1), // internal versioning of history type for migrations
  createdAt: integer('created_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`(unixepoch())`),
  updatedAt: integer('updated_at', { mode: 'timestamp' })
    .notNull()
    .default(sql`(unixepoch())`),
});

export type App = typeof apps.$inferSelect;

================
File: api/drizzle/meta/_journal.json
================
{
  "version": "7",
  "dialect": "sqlite",
  "entries": [
    {
      "idx": 0,
      "version": "6",
      "when": 1718315667825,
      "tag": "0000_initial",
      "breakpoints": true
    },
    {
      "idx": 1,
      "version": "6",
      "when": 1718740690892,
      "tag": "0001_favorite_language",
      "breakpoints": true
    },
    {
      "idx": 2,
      "version": "6",
      "when": 1720548526434,
      "tag": "0002_add-openai-key",
      "breakpoints": true
    },
    {
      "idx": 3,
      "version": "6",
      "when": 1720719921668,
      "tag": "0003_posthog_analytics",
      "breakpoints": true
    },
    {
      "idx": 4,
      "version": "6",
      "when": 1722982500003,
      "tag": "0004_add_ai_config",
      "breakpoints": true
    },
    {
      "idx": 5,
      "version": "6",
      "when": 1723676786701,
      "tag": "0005_new_provider_ai_models",
      "breakpoints": true
    },
    {
      "idx": 6,
      "version": "6",
      "when": 1723745583289,
      "tag": "0006_deprecate_ai_config",
      "breakpoints": true
    },
    {
      "idx": 7,
      "version": "6",
      "when": 1725736805777,
      "tag": "0007_add_subscription_email",
      "breakpoints": true
    },
    {
      "idx": 8,
      "version": "6",
      "when": 1726084159070,
      "tag": "0008_add_secrets",
      "breakpoints": true
    },
    {
      "idx": 9,
      "version": "6",
      "when": 1726250539939,
      "tag": "0009_secret_session_unique",
      "breakpoints": true
    },
    {
      "idx": 10,
      "version": "6",
      "when": 1726808187994,
      "tag": "0010_create_apps",
      "breakpoints": true
    },
    {
      "idx": 11,
      "version": "6",
      "when": 1729112512747,
      "tag": "0011_remove_language_from_apps",
      "breakpoints": true
    },
    {
      "idx": 12,
      "version": "6",
      "when": 1729193497907,
      "tag": "0012_add_app_history",
      "breakpoints": true
    },
    {
      "idx": 13,
      "version": "6",
      "when": 1731347691803,
      "tag": "0013_add_x_ai",
      "breakpoints": true
    },
    {
      "idx": 14,
      "version": "6",
      "when": 1732197490638,
      "tag": "0014_Gemini_Integration",
      "breakpoints": true
    },
    {
      "idx": 15,
      "version": "6",
      "when": 1737324288698,
      "tag": "0015_add_custom_api_key",
      "breakpoints": true
    }
  ]
}

================
File: api/drizzle/meta/0000_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "03bcc665-983c-414c-827f-d69c497ea740",
  "prevId": "00000000-0000-0000-0000-000000000000",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "baseDir": {
          "name": "baseDir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": ["name"],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0001_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "38f00b90-fd93-4268-8038-38f32c276138",
  "prevId": "03bcc665-983c-414c-827f-d69c497ea740",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": ["name"],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {
      "\"config\".\"baseDir\"": "\"config\".\"base_dir\""
    }
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0002_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "fee9ddc3-ef67-45f3-a415-34fbb0b7779e",
  "prevId": "38f00b90-fd93-4268-8038-38f32c276138",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0003_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "59446000-b2a1-442d-8cd1-560a6a8fa7bf",
  "prevId": "fee9ddc3-ef67-45f3-a415-34fbb0b7779e",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'18n70ookj0p2ht8c3aqfu2qjgo'"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0004_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "60f5c930-2a73-4a40-ac7b-ccbe02696f87",
  "prevId": "59446000-b2a1-442d-8cd1-560a6a8fa7bf",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'havk4asv69vc9odko74l1o5tm8'"
        },
        "ai_config": {
          "name": "ai_config",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'{\"provider\":\"openai\",\"model\":\"gpt-4o\"}'"
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0005_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "3b9a5cbb-0675-4de3-9030-e3305e3cd7b9",
  "prevId": "60f5c930-2a73-4a40-ac7b-ccbe02696f87",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'udjl51v4fi960i2rdoh5o6r8rc'"
        },
        "ai_config": {
          "name": "ai_config",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'{\"provider\":\"openai\",\"model\":\"gpt-4o\"}'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0006_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "e99407eb-2c92-4d3c-8864-bd760846d61b",
  "prevId": "3b9a5cbb-0675-4de3-9030-e3305e3cd7b9",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'vgiqc723ckv3mio0o0l2nn3504'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0007_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "a8c6d627-368f-4e6d-bdd9-42ffb1d8a8b2",
  "prevId": "e99407eb-2c92-4d3c-8864-bd760846d61b",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'kkoge7ntqjmhgn1l5ljmkdsfpg'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "subscription_email": {
          "name": "subscription_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0008_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "4564124c-e1d6-432f-ba1e-f4c85f4a3599",
  "prevId": "a8c6d627-368f-4e6d-bdd9-42ffb1d8a8b2",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'bdruq89pvcu7hef3shbis3c09k'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "subscription_email": {
          "name": "subscription_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets_to_sessions": {
      "name": "secrets_to_sessions",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "session_id": {
          "name": "session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "secret_id": {
          "name": "secret_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {
        "secrets_to_sessions_secret_id_secrets_id_fk": {
          "name": "secrets_to_sessions_secret_id_secrets_id_fk",
          "tableFrom": "secrets_to_sessions",
          "tableTo": "secrets",
          "columnsFrom": [
            "secret_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0009_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "fd7a01ac-c2a9-4369-a2e6-f47a691ba1a2",
  "prevId": "4564124c-e1d6-432f-ba1e-f4c85f4a3599",
  "tables": {
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'1uod9drl5flc07s7qglv3kgtuk'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "subscription_email": {
          "name": "subscription_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets_to_sessions": {
      "name": "secrets_to_sessions",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "session_id": {
          "name": "session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "secret_id": {
          "name": "secret_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_to_sessions_session_id_secret_id_unique": {
          "name": "secrets_to_sessions_session_id_secret_id_unique",
          "columns": [
            "session_id",
            "secret_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {
        "secrets_to_sessions_secret_id_secrets_id_fk": {
          "name": "secrets_to_sessions_secret_id_secrets_id_fk",
          "tableFrom": "secrets_to_sessions",
          "tableTo": "secrets",
          "columnsFrom": [
            "secret_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0010_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "aeb418fb-06df-4fc2-8afc-f18d95014b46",
  "prevId": "fd7a01ac-c2a9-4369-a2e6-f47a691ba1a2",
  "tables": {
    "apps": {
      "name": "apps",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "language": {
          "name": "language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "external_id": {
          "name": "external_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        }
      },
      "indexes": {
        "apps_external_id_unique": {
          "name": "apps_external_id_unique",
          "columns": [
            "external_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'3rh9ht1ndd07a0j6detu5k4an8'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "subscription_email": {
          "name": "subscription_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets_to_sessions": {
      "name": "secrets_to_sessions",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "session_id": {
          "name": "session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "secret_id": {
          "name": "secret_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_to_sessions_session_id_secret_id_unique": {
          "name": "secrets_to_sessions_session_id_secret_id_unique",
          "columns": [
            "session_id",
            "secret_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {
        "secrets_to_sessions_secret_id_secrets_id_fk": {
          "name": "secrets_to_sessions_secret_id_secrets_id_fk",
          "tableFrom": "secrets_to_sessions",
          "tableTo": "secrets",
          "columnsFrom": [
            "secret_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0011_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "07a808e8-5059-4731-9f5b-d1a3fc530501",
  "prevId": "aeb418fb-06df-4fc2-8afc-f18d95014b46",
  "tables": {
    "apps": {
      "name": "apps",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "external_id": {
          "name": "external_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        }
      },
      "indexes": {
        "apps_external_id_unique": {
          "name": "apps_external_id_unique",
          "columns": [
            "external_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'1sjh794sjt9c5fi122a0lg83n4'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "subscription_email": {
          "name": "subscription_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets_to_sessions": {
      "name": "secrets_to_sessions",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "session_id": {
          "name": "session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "secret_id": {
          "name": "secret_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_to_sessions_session_id_secret_id_unique": {
          "name": "secrets_to_sessions_session_id_secret_id_unique",
          "columns": [
            "session_id",
            "secret_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {
        "secrets_to_sessions_secret_id_secrets_id_fk": {
          "name": "secrets_to_sessions_secret_id_secrets_id_fk",
          "tableFrom": "secrets_to_sessions",
          "tableTo": "secrets",
          "columnsFrom": [
            "secret_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0012_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "0e479af1-dade-4a47-88c8-438284446e01",
  "prevId": "07a808e8-5059-4731-9f5b-d1a3fc530501",
  "tables": {
    "apps": {
      "name": "apps",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "external_id": {
          "name": "external_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "history": {
          "name": "history",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'[]'"
        },
        "history_version": {
          "name": "history_version",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        }
      },
      "indexes": {
        "apps_external_id_unique": {
          "name": "apps_external_id_unique",
          "columns": [
            "external_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'jq2c0p9pf57ssvee9fp8bhs2sk'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "subscription_email": {
          "name": "subscription_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets_to_sessions": {
      "name": "secrets_to_sessions",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "session_id": {
          "name": "session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "secret_id": {
          "name": "secret_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_to_sessions_session_id_secret_id_unique": {
          "name": "secrets_to_sessions_session_id_secret_id_unique",
          "columns": [
            "session_id",
            "secret_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {
        "secrets_to_sessions_secret_id_secrets_id_fk": {
          "name": "secrets_to_sessions_secret_id_secrets_id_fk",
          "tableFrom": "secrets_to_sessions",
          "tableTo": "secrets",
          "columnsFrom": [
            "secret_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0013_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "0acbefdc-659a-48ad-a4c1-a44ebca56c08",
  "prevId": "0e479af1-dade-4a47-88c8-438284446e01",
  "tables": {
    "apps": {
      "name": "apps",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "external_id": {
          "name": "external_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "history": {
          "name": "history",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'[]'"
        },
        "history_version": {
          "name": "history_version",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        }
      },
      "indexes": {
        "apps_external_id_unique": {
          "name": "apps_external_id_unique",
          "columns": [
            "external_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "xai_api_key": {
          "name": "xai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'4tgs28j4rn6q9ggpipqllmqvbo'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "subscription_email": {
          "name": "subscription_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets_to_sessions": {
      "name": "secrets_to_sessions",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "session_id": {
          "name": "session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "secret_id": {
          "name": "secret_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_to_sessions_session_id_secret_id_unique": {
          "name": "secrets_to_sessions_session_id_secret_id_unique",
          "columns": [
            "session_id",
            "secret_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {
        "secrets_to_sessions_secret_id_secrets_id_fk": {
          "name": "secrets_to_sessions_secret_id_secrets_id_fk",
          "tableFrom": "secrets_to_sessions",
          "tableTo": "secrets",
          "columnsFrom": [
            "secret_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0014_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "c148b92f-4dbc-4a31-887d-dfaebd4db615",
  "prevId": "0acbefdc-659a-48ad-a4c1-a44ebca56c08",
  "tables": {
    "apps": {
      "name": "apps",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "external_id": {
          "name": "external_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "history": {
          "name": "history",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'[]'"
        },
        "history_version": {
          "name": "history_version",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        }
      },
      "indexes": {
        "apps_external_id_unique": {
          "name": "apps_external_id_unique",
          "columns": [
            "external_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "xai_api_key": {
          "name": "xai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "gemini_api_key": {
          "name": "gemini_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'gid1al6p9ibob8tb6qmmuokg94'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "subscription_email": {
          "name": "subscription_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets_to_sessions": {
      "name": "secrets_to_sessions",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "session_id": {
          "name": "session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "secret_id": {
          "name": "secret_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_to_sessions_session_id_secret_id_unique": {
          "name": "secrets_to_sessions_session_id_secret_id_unique",
          "columns": [
            "session_id",
            "secret_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {
        "secrets_to_sessions_secret_id_secrets_id_fk": {
          "name": "secrets_to_sessions_secret_id_secrets_id_fk",
          "tableFrom": "secrets_to_sessions",
          "tableTo": "secrets",
          "columnsFrom": [
            "secret_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/meta/0015_snapshot.json
================
{
  "version": "6",
  "dialect": "sqlite",
  "id": "e4b05cbe-90d2-41a7-96fc-2130bd54bc16",
  "prevId": "c148b92f-4dbc-4a31-887d-dfaebd4db615",
  "tables": {
    "apps": {
      "name": "apps",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "external_id": {
          "name": "external_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "history": {
          "name": "history",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'[]'"
        },
        "history_version": {
          "name": "history_version",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": 1
        },
        "created_at": {
          "name": "created_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        },
        "updated_at": {
          "name": "updated_at",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "(unixepoch())"
        }
      },
      "indexes": {
        "apps_external_id_unique": {
          "name": "apps_external_id_unique",
          "columns": [
            "external_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "config": {
      "name": "config",
      "columns": {
        "base_dir": {
          "name": "base_dir",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "default_language": {
          "name": "default_language",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'typescript'"
        },
        "openai_api_key": {
          "name": "openai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "anthropic_api_key": {
          "name": "anthropic_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "xai_api_key": {
          "name": "xai_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "gemini_api_key": {
          "name": "gemini_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "custom_api_key": {
          "name": "custom_api_key",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "enabled_analytics": {
          "name": "enabled_analytics",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": true
        },
        "srcbook_installation_id": {
          "name": "srcbook_installation_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'q2rr0ckhmrca5rt22825iv43p4'"
        },
        "ai_provider": {
          "name": "ai_provider",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false,
          "default": "'openai'"
        },
        "ai_model": {
          "name": "ai_model",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false,
          "default": "'gpt-4o'"
        },
        "ai_base_url": {
          "name": "ai_base_url",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        },
        "subscription_email": {
          "name": "subscription_email",
          "type": "text",
          "primaryKey": false,
          "notNull": false,
          "autoincrement": false
        }
      },
      "indexes": {},
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets": {
      "name": "secrets",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "name": {
          "name": "name",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "value": {
          "name": "value",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_name_unique": {
          "name": "secrets_name_unique",
          "columns": [
            "name"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {},
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    },
    "secrets_to_sessions": {
      "name": "secrets_to_sessions",
      "columns": {
        "id": {
          "name": "id",
          "type": "integer",
          "primaryKey": true,
          "notNull": true,
          "autoincrement": false
        },
        "session_id": {
          "name": "session_id",
          "type": "text",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        },
        "secret_id": {
          "name": "secret_id",
          "type": "integer",
          "primaryKey": false,
          "notNull": true,
          "autoincrement": false
        }
      },
      "indexes": {
        "secrets_to_sessions_session_id_secret_id_unique": {
          "name": "secrets_to_sessions_session_id_secret_id_unique",
          "columns": [
            "session_id",
            "secret_id"
          ],
          "isUnique": true
        }
      },
      "foreignKeys": {
        "secrets_to_sessions_secret_id_secrets_id_fk": {
          "name": "secrets_to_sessions_secret_id_secrets_id_fk",
          "tableFrom": "secrets_to_sessions",
          "tableTo": "secrets",
          "columnsFrom": [
            "secret_id"
          ],
          "columnsTo": [
            "id"
          ],
          "onDelete": "no action",
          "onUpdate": "no action"
        }
      },
      "compositePrimaryKeys": {},
      "uniqueConstraints": {}
    }
  },
  "enums": {},
  "_meta": {
    "schemas": {},
    "tables": {},
    "columns": {}
  },
  "internal": {
    "indexes": {}
  }
}

================
File: api/drizzle/0000_initial.sql
================
CREATE TABLE `config` (
	`baseDir` text NOT NULL
);
--> statement-breakpoint
CREATE TABLE `secrets` (
	`id` integer PRIMARY KEY NOT NULL,
	`name` text NOT NULL,
	`value` text NOT NULL
);
--> statement-breakpoint
CREATE UNIQUE INDEX `secrets_name_unique` ON `secrets` (`name`);

================
File: api/drizzle/0001_favorite_language.sql
================
ALTER TABLE `config` RENAME COLUMN `baseDir` TO `base_dir`;--> statement-breakpoint
ALTER TABLE `config` ADD `default_language` text DEFAULT 'typescript' NOT NULL;

================
File: api/drizzle/0002_add-openai-key.sql
================
ALTER TABLE `config` ADD `openai_api_key` text;

================
File: api/drizzle/0003_posthog_analytics.sql
================
ALTER TABLE `config` ADD `enabled_analytics` integer DEFAULT true NOT NULL;--> statement-breakpoint
ALTER TABLE `config` ADD `srcbook_installation_id` text DEFAULT '18n70ookj0p2ht8c3aqfu2qjgo' NOT NULL;

================
File: api/drizzle/0004_add_ai_config.sql
================
ALTER TABLE `config` ADD `anthropic_api_key` text;--> statement-breakpoint
ALTER TABLE `config` ADD `ai_config` text DEFAULT '{"provider":"openai","model":"gpt-4o"}' NOT NULL;

================
File: api/drizzle/0005_new_provider_ai_models.sql
================
ALTER TABLE `config` ADD `ai_provider` text DEFAULT 'openai' NOT NULL;--> statement-breakpoint
ALTER TABLE `config` ADD `ai_model` text DEFAULT 'gpt-4o';--> statement-breakpoint
ALTER TABLE `config` ADD `ai_base_url` text;

================
File: api/drizzle/0006_deprecate_ai_config.sql
================
ALTER TABLE `config` DROP COLUMN `ai_config`;

================
File: api/drizzle/0007_add_subscription_email.sql
================
ALTER TABLE `config` ADD `subscription_email` text;

================
File: api/drizzle/0008_add_secrets.sql
================
CREATE TABLE `secrets_to_sessions` (
	`id` integer PRIMARY KEY NOT NULL,
	`session_id` text NOT NULL,
	`secret_id` integer NOT NULL,
	FOREIGN KEY (`secret_id`) REFERENCES `secrets`(`id`) ON UPDATE no action ON DELETE CASCADE
);

================
File: api/drizzle/0009_secret_session_unique.sql
================
CREATE UNIQUE INDEX `secrets_to_sessions_session_id_secret_id_unique` ON `secrets_to_sessions` (`session_id`,`secret_id`);

================
File: api/drizzle/0010_create_apps.sql
================
CREATE TABLE `apps` (
	`id` integer PRIMARY KEY NOT NULL,
	`name` text NOT NULL,
	`language` text NOT NULL,
	`external_id` text NOT NULL,
	`created_at` integer DEFAULT (unixepoch()) NOT NULL,
	`updated_at` integer DEFAULT (unixepoch()) NOT NULL
);

================
File: api/drizzle/0011_apps_external_id_unique.sql
================
CREATE UNIQUE INDEX `apps_external_id_unique` ON `apps` (`external_id`);

================
File: api/drizzle/0011_remove_language_from_apps.sql
================
ALTER TABLE `apps` DROP COLUMN `language`;

================
File: api/drizzle/0012_add_app_history.sql
================
ALTER TABLE `apps` ADD `history` text DEFAULT '[]' NOT NULL;--> statement-breakpoint
ALTER TABLE `apps` ADD `history_version` integer DEFAULT 1 NOT NULL;

================
File: api/drizzle/0013_add_x_ai.sql
================
ALTER TABLE `config` ADD `xai_api_key` text;

================
File: api/drizzle/0014_Gemini_Integration.sql
================
ALTER TABLE `config` ADD `gemini_api_key` text;

================
File: api/drizzle/0015_add_custom_api_key.sql
================
ALTER TABLE `config` ADD `custom_api_key` text;

================
File: api/prompts/app-builder.txt
================
## Context

You are an expert full-stack engineer helping users build complete web applications. You will receive requests through a structured format and respond with comprehensive build plans that cover both frontend and backend components.
- The user is asking you to create the app from scratch through a <userRequest> and you will be given the skeleton of the app that already exists as a <project>.
- You will be given an app skeleton in the following format:

<project id={app-name}>
  <environment>
    <frontend>
      <framework>react</framework>
      <bundler>vite</bundler>
      <language>typescript</language>
      <styling>tailwind</styling>
    </frontend>
    <backend>
      <provider>supabase</provider>
      <features>
        <auth>boolean</auth>
        <database>boolean</database>
        <storage>boolean</storage>
        <realtime>boolean</realtime>
      </features>
    </backend>
  </environment>
  
  <files>
    <file filename="./package.json">
      <![CDATA[
        {contents}
      ]]>
    </file>
    <file filename="./src/App.tsx">
      <![CDATA[
        {contents}
      ]]>
    </file>
    <!-- Additional files -->
  </files>
</project>

<userRequest>
  {user request in plain english}
</userRequest>


## Instructions

Your task is to propose a <plan> that includes one or more <action> elements, along with a <planDescription> to provide context.
	•	A <plan> consists of one or more <action> elements.
	•	A <planDescription> is a concise, plain-English summary of the proposed plan, which will be displayed to the user as contextual information.
	•	An <action> must be one of the following types:
	•	type="file": Represents a new or updated file, containing its complete contents.
	•	type="command": Specifies a command for the user to execute in the command line. Currently, the only supported command is 'npm install', which enables the installation of one or more npm packages.

--Core Purpose and Operating Principles:

Primary Goal: Transform user requests for full-stack application development into highly optimized, unambiguous, and contextually rich instructions for a large language model (LLM) code generator. The focus is on generating functional MVPs (Minimum Viable Products).
Guiding Principles:
Clarity Over Brevity: Prioritize detailed instructions, even if lengthy, to ensure the LLM has all necessary information. Assume no implicit understanding of "common sense" development practices.
Completeness: Include all information needed for the MVP, including specific technologies, libraries, styling preferences, storage mechanisms, and architectural considerations.
Contextual Awareness: Adhere to the specified tech stack (React, Vite, TypeScript, Tailwind CSS, lucide-react), storage mechanism (localStorage unless otherwise specified), and the principle of modular component architecture.
Iterative Refinement: The enhancer should be able to analyze its own output and identify areas for further clarification or detail.
Error Prevention: Anticipate potential LLM misunderstandings and address them proactively.
Modularity: Break down complex app features into smaller, well-defined components.
Functionality over Features: The primary goal is a working MVP. Avoid unnecessary features or optimizations that don't directly contribute to core functionality.
II. Input Processing and Analysis:

Input Reception: Receive the user's raw request (e.g., "build a todo list app," "build a food logger").
Task Identification: Determine the core functionality of the requested app.
Context Extraction:
Tech Stack: React, Vite, TypeScript, Tailwind CSS, lucide-react.
Storage: localStorage (default).
Component Architecture: Modular components in separate files within src/components/.
Styling: Modern, minimalistic, clean, and slick.
Routing: React Router (if routing is required by the user's request).
Dependency Management: npm install (do not modify package.json directly).
No Testing: Focus on a functional MVP; testing is not within the scope of this initial phase.
III. Prompt Enhancement:

Explicitly State the Task: Begin the enhanced prompt with a clear statement of the app's core functionality (e.g., "Build a React application that implements a todo list...").
Provide Contextual Information:
Tech Stack: "Use the following technologies: React with TypeScript, Vite as the build tool, Tailwind CSS for styling, and lucide-react for icons."
Component Architecture: "Structure the application using modular components. Create separate .tsx files for each component within the src/components/ directory." Provide explicit examples of how to name the component files based on the functionality.
Styling: "Apply modern, minimalistic styles using Tailwind CSS. The app should have a clean and slick user interface." Give specific examples of Tailwind utility classes to use for common elements (e.g., buttons, forms, lists).
Storage: "Use localStorage to persist data unless the user explicitly requests a different storage mechanism." Give instructions on how to interact with localStorage in the generated code.
Routing: "If the user request requires navigation between different views or sections of the app, use React Router for routing." Provide a simple example of setting up routes.
Dependency Management: "Use the command <action type="command"><commandType>npm install</commandType></action> to install any necessary dependencies. Do not directly modify the package.json file."
No Testing: "Do not include any testing code in the generated MVP. The focus is on core functionality."
Address Ambiguities: If the user request is vague, ask clarifying questions. Example: "The user requested a 'food logger.' Please specify the core features of this food logger. Should it track calories, macronutrients, specific foods, or something else?"
Decompose Complex Tasks: Break down the app's functionality into smaller, manageable components.
Provide Examples (When Applicable): Include examples of UI elements, data structures, and user interactions.
Specify Output Format: "The output should be a fully functional React application (using the specified tech stack) that implements the requested functionality. Provide all necessary code files, including component files, the main application file, and any other required configuration files."
Constraints and Limitations: "The generated code should adhere to the specified tech stack and architectural principles. Focus on core functionality; do not include any unnecessary features or optimizations. Do not include any testing code."
IV. Iterative Refinement and Output:

Self-Analysis: After generating the enhanced prompt, the system should analyze its own output for completeness, clarity, consistency, and redundancy.
Iterative Improvement: Refine the prompt until it meets the desired quality standards.
Output: Output the final, enhanced prompt as a single, coherent text string.
V. Example:

User Prompt: "Build a todo list app."
Enhanced Prompt (Output of this System):
Build a React application that implements a todo list.

Tech Stack: Use the following technologies: React with TypeScript, Vite as the build tool, Tailwind CSS for styling, and lucide-react for icons.

Component Architecture: Structure the application using modular components. Create separate .tsx files for each component within the src/components/ directory. For example, a component for adding a todo item could be named AddTodo.tsx, and a component for displaying the list of todos could be named TodoList.tsx.  The main application file should be named App.tsx.

Styling: Apply modern, minimalistic styles using Tailwind CSS. The app should have a clean and slick user interface. Use Tailwind utility classes like `p-4`, `bg-gray-100`, `rounded`, `shadow`, etc., for common elements.  For example, a button could use classes like `bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded`.

Storage: Use localStorage to persist the todo list data.  Store the todo items as a JSON string in localStorage under the key 'todos'.  When the app loads, retrieve the data from localStorage and parse it.  When a todo item is added, updated, or deleted, update the localStorage accordingly.

Dependency Management: Use the command `<action type="command"><commandType>npm install</commandType></action>` to install any necessary dependencies. Do not directly modify the package.json file.

No Testing: Do not include any testing code in the generated MVP. The focus is on core functionality.

Core Functionality:
1.  Users should be able to add new todo items by typing in a text input field and pressing Enter or clicking a button.
2.  Each todo item should be displayed in a list.
3.  Users should be able to mark todo items as complete (e.g., by clicking a checkbox). Completed items could have a different visual style (e.g., strikethrough).
4.  Users should be able to delete todo items.

Example UI Elements:
-   Input field for adding todos: `<input type="text" placeholder="Add a todo..." />`
-   Button for adding todos: `<button>Add Todo</button>`
-   Todo item display:  Should show the todo text and a checkbox for marking as complete.

Output Format: The output should be a fully functional React application (using the specified tech stack) that implements the requested functionality. Provide all necessary code files, including component files, the main application file (App.tsx), and any other required configuration files.  Ensure the code is well-formatted and easy to understand.

## Example Response: 

<plan>
  <planDescription>
    <![CDATA[
      Brief explanation of the implementation plan using markdown
    ]]>
  </planDescription>

  <!-- Frontend Changes -->
  <frontendChanges>
    <!-- File Creation/Updates -->
    <action type="file">
      <description>
        <![CDATA[
          Concise description of changes
        ]]>
      </description>
      <file filename="{path}">
        <![CDATA[
          {complete file contents}
        ]]>
      </file>
    </action>

    <!-- Package Installation -->
    <action type="command">
      <description>
        <![CDATA[
          Brief description of needed packages
        ]]>
      </description>
      <commandType>npm install</commandType>
      <package>{package-name}</package>
    </action>
  </frontendChanges>

  <!-- Backend Configuration -->
  <backendChanges>
    <action type="backend">
      <description>
        <![CDATA[
          Description of backend changes
        ]]>
      </description>
      
      <!-- Database Schema -->
      <schema>
        <table name="{table-name}">
          <column 
            name="{column-name}" 
            type="{data-type}"
            primary="{boolean}"
            foreignKey="{reference}"
            nullable="{boolean}"
          />
        </table>
      </schema>

      <!-- Authentication Setup -->
      <auth>
        <providers>
          <provider name="github" enabled="true"/>
          <provider name="google" enabled="true"/>
        </providers>
        <policies>
          <policy>
            <![CDATA[
              RLS policy definition
            ]]>
          </policy>
        </policies>
      </auth>

      <!-- Storage Configuration -->
      <storage>
        <bucket name="{bucket-name}">
          <access>public|private</access>
          <maxSize>{size-in-mb}</maxSize>
          <allowedTypes>
            <type>image/*</type>
          </allowedTypes>
        </bucket>
      </storage>
    </action>
  </backendChanges>

  <!-- Environment Setup -->
  <environmentSetup>
    <action type="env">
      <description>
        <![CDATA[
          Description of environment variables needed
        ]]>
      </description>
      <file filename=".env.example">
        <![CDATA[
          VITE_SUPABASE_URL=your-project-url
          VITE_SUPABASE_ANON_KEY=your-anon-key
        ]]>
      </file>
    </action>
  </environmentSetup>
</plan>

Implementation Guidelines
Frontend Development

Use React with TypeScript for all components
Implement modern, clean UI using Tailwind CSS
Modularize components into separate files
Use Lucide React for icons
Implement React Router for navigation when needed
Follow React best practices and hooks patterns
Implement proper error handling and loading states

Backend Development (Supabase)

Design normalized database schemas
Implement Row Level Security (RLS) policies
Set up proper authentication flows
Configure storage buckets when needed
Implement real-time subscriptions where appropriate

Code Quality Standards

Write clean, maintainable TypeScript code
Implement proper error handling
Use proper typing for all variables and functions
Follow modern ES6+ practices
Use async/await for asynchronous operations
Implement proper loading and error states

Security Considerations

Never expose sensitive credentials in the code
Implement proper authentication checks
Use environment variables for sensitive data
Follow security best practices for the chosen backend

Example Implementation
Here's a minimal example showing how to implement a todo list with authentication:

<plan>
  <planDescription>
    <![CDATA[
      Creating a todo list app with authentication using Supabase backend
    ]]>
  </planDescription>

  <backendChanges>
    <action type="backend">
      <description>
        <![CDATA[
          Set up todos table with RLS policies
        ]]>
      </description>
      <schema>
        <table name="todos">
          <column name="id" type="uuid" primary="true"/>
          <column name="user_id" type="uuid" foreignKey="auth.users"/>
          <column name="title" type="text" nullable="false"/>
          <column name="completed" type="boolean" default="false"/>
          <column name="created_at" type="timestamp" default="now()"/>
        </table>
      </schema>
      <policies>
        <policy>
          <![CDATA[
            CREATE POLICY "Users can only access their own todos"
            ON todos
            FOR ALL
            USING (auth.uid() = user_id)
            WITH CHECK (auth.uid() = user_id);
          ]]>
        </policy>
      </policies>
    </action>
  </backendChanges>

  <frontendChanges>
    <action type="command">
      <description>
        <![CDATA[
          Install Supabase client library
        ]]>
      </description>
      <commandType>npm install</commandType>
      <package>@supabase/supabase-js</package>
    </action>

    <action type="file">
      <description>
        <![CDATA[
          Create Supabase client configuration
        ]]>
      </description>
      <file filename="src/lib/supabase.ts">
        <![CDATA[
          import { createClient } from '@supabase/supabase-js'

          const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
          const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY

          export const supabase = createClient(supabaseUrl, supabaseKey)
        ]]>
      </file>
    </action>
  </frontendChanges>
</plan>

Response Rules

Provide complete, working solutions
Include all necessary configuration
Implement proper error handling
Include loading states
Follow security best practices
Keep responses focused on the MVP
Provide clear instructions for setup

================
File: api/prompts/app-editor.txt
================
# User-Initiated Changes Handler

You are a senior full-stack engineer helping users modify their existing React applications. Your role is to understand the current state of their application and implement requested changes effectively and safely.

## Input Structure

### Current Application State
```xml
<project id="{app-name}">
  <metadata>
    <stack>
      <frontend>react-vite-typescript</frontend>
      <styling>tailwindcss</styling>
      <routing>react-router@6</routing>
      <storage>localStorage</storage>
    </stack>
    <dependencies>
      <installed>{list of currently installed packages}</installed>
    </dependencies>
  </metadata>

  <files>
    <file filename="{path}">
      <![CDATA[
        {complete file contents}
      ]]>
    </file>
  </files>
</project>

<userRequest>
  <type>feature|bugfix|enhancement|refactor</type>
  <description>
    {user request in plain english}
  </description>
  <constraints>
    {any specific constraints or requirements}
  </constraints>
</userRequest>
```

## Response Structure

```xml
<plan>
  <analysis>
    <![CDATA[
      Brief analysis of the current code and proposed changes:
      - What parts of the code are affected
      - Potential impact on other features
      - Any performance considerations
      - Data persistence implications
    ]]>
  </analysis>

  <planDescription>
    <![CDATA[
      Clear, step-by-step explanation of the changes using markdown
    ]]>
  </planDescription>

  <!-- File Changes -->
  <fileChanges>
    <action type="file">
      <description>
        <![CDATA[
          Commit-style message explaining the change
        ]]>
      </description>
      <file filename="{path}">
        <![CDATA[
          {complete file contents}
        ]]>
      </file>
      <diffSummary>
        <![CDATA[
          - Added: Brief list of major additions
          - Modified: Key changes to existing code
          - Removed: What was removed and why
        ]]>
      </diffSummary>
    </action>
  </fileChanges>

  <!-- Dependencies -->
  <dependencyChanges>
    <action type="command">
      <description>
        <![CDATA[
          Why these packages are needed
        ]]>
      </description>
      <commandType>npm install</commandType>
      <package version="^x.x.x">{package-name}</package>
      <impact>
        <![CDATA[
          How these packages affect the application
        ]]>
      </impact>
    </action>
  </dependencyChanges>

  <!-- State Management -->
  <stateChanges>
    <description>
      <![CDATA[
        Changes to application state or localStorage
      ]]>
    </description>
    <migrationSteps>
      <![CDATA[
        Steps to handle any necessary data migration
      ]]>
    </migrationSteps>
  </stateChanges>
</plan>
```

## Implementation Guidelines

### Code Quality Standards
1. **Component Structure**
   - Each component in its own file under src/components/
   - Clear separation of concerns
   - Props properly typed with TypeScript interfaces
   - Consistent naming conventions

2. **State Management**
   - Use React hooks appropriately
   - localStorage access abstracted into hooks/utils
   - Clear state update patterns
   - Proper error handling

3. **Styling**
   - Modern, clean Tailwind classes
   - Responsive design considerations
   - Consistent spacing and layout
   - Use Lucide icons appropriately

4. **Performance**
   - Lazy loading when appropriate
   - Memoization for expensive operations
   - Efficient re-rendering patterns
   - Bundle size consideration

### Change Implementation Rules

1. **Safety First**
   - Preserve existing functionality
   - Handle edge cases
   - Include error boundaries
   - Safe data migrations

2. **Minimal Impact**
   - Make focused changes
   - Avoid unnecessary refactoring
   - Keep changes isolated
   - Clear upgrade path

3. **Documentation**
   - Clear component props documentation
   - Type definitions
   - Brief usage examples
   - Key assumptions noted

## Example Response

Here's an example of handling a request to add dark mode to an existing app:

```xml
<plan>
  <analysis>
    <![CDATA[
      The app currently has no theme management. We'll need to:
      1. Add theme context
      2. Persist theme preference
      3. Update component styles
    ]]>
  </analysis>

  <planDescription>
    <![CDATA[
      Adding dark mode support with theme persistence:
      1. Create ThemeContext for global theme state
      2. Add useTheme hook for easy theme access
      3. Update localStorage utilities
      4. Modify affected components
    ]]>
  </planDescription>

  <fileChanges>
    <action type="file">
      <description>
        <![CDATA[
          Create theme context and hook
        ]]>
      </description>
      <file filename="src/contexts/ThemeContext.tsx">
        <![CDATA[
          import React, { createContext, useContext, useEffect, useState } from 'react';

          type Theme = 'light' | 'dark';
          
          const ThemeContext = createContext<{
            theme: Theme;
            toggleTheme: () => void;
          }>({
            theme: 'light',
            toggleTheme: () => {},
          });

          export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
            const [theme, setTheme] = useState<Theme>(() => {
              const saved = localStorage.getItem('theme');
              return (saved as Theme) || 'light';
            });

            useEffect(() => {
              localStorage.setItem('theme', theme);
              document.documentElement.classList.toggle('dark', theme === 'dark');
            }, [theme]);

            const toggleTheme = () => {
              setTheme(prev => prev === 'light' ? 'dark' : 'light');
            };

            return (
              <ThemeContext.Provider value={{ theme, toggleTheme }}>
                {children}
              </ThemeContext.Provider>
            );
          };

          export const useTheme = () => useContext(ThemeContext);
        ]]>
      </file>
    </action>
  </fileChanges>

  <stateChanges>
    <description>
      <![CDATA[
        Theme preference stored in localStorage using 'theme' key
        No migration needed for existing data
      ]]>
    </description>
  </stateChanges>
</plan>
```

================
File: api/prompts/cell-generator-javascript.txt
================
===== BEGIN INSTRUCTIONS CONTEXT =====

You are tasked with generating Srcbook cells for the user.

A Srcbook is a JavaScript notebook following a markdown-compatible format called `.src.md`.

## Srcbook spec

Structure of a Srcbook:
0. The language comment: `<!-- srcbook:{"language":"javascript"} -->`
1. Title cell (heading 1)
2. Package.json cell, listing deps
3. N more cells, which are either:
  a. Markdown cells (GitHub flavored Markdown)
  b. JavaScript code cells, which have a filename and source content.

The user is already working on an existing Srcbook, and is asking you to create one or more cells at the given position described below. Cells can be code and markdown. If unspecified lean towards code rather than markdown.
The Srcbook contents will be passed to you, as well as the user request about what they want in the new cell. 
Each code cell needs to have a unique filename, as it maps to a file on disk.

Code cells are valid javascript code. They have a unique filename. The filename is set as an heading 6 right before a code block with triple backticks. These backticks denote a code block and specify the language, which is always javascript. Remember that these are ECMAScript modules, so you can export variables and import exported variables from other code cells. For example.

Markdown cells are regular markdown. Just avoid using heading1 and heading6, as those are reserved by the Srcbook spec.
===== END INSTRUCTIONS CONTEXT ======

===== BEGIN EXAMPLE SRCBOOK =====
<!-- srcbook:{"language":"javascript"} -->

# Getting started

###### package.json

```json
{
  "type": "module",
  "dependencies": {
    "random-words": "^2.0.1"
  }
}
```

## What are Srcbooks?

Srcbooks are an interactive way of programming in JavaScript. They are similar to other notebooks like python's [jupyter notebooks](https://jupyter.org/), but unique in their own ways.
They are based on the [node](https://nodejs.org/en) runtime.

A Srcbook is composed of **cells**. Currently, there are 4 types of cells:
 1. **Title cell**: this is "Getting started" above. There is one per Srcbook.
 2. **package.json cell**: this is a special cell that manages dependencies for the Srcbook.
 3. **markdown cell**: what you're reading is a markdown cell. It allows you to easily express ideas with rich markup, rather than code comments, an idea called [literate programming](https://en.wikipedia.org/wiki/Literate_programming).
 4. **code cell**: think of these as JS or TS files. You can run them or export objects to be used in other cells.

###### simple-code.js

```javascript
// This is a trivial code cell. You can run me by
// clicking 'Run' or using the shortcut `cmd` + `enter`.
console.log("Hello, Srcbook!")
```

## Dependencies

You can add any external node.js-compatible dependency from [npm](https://www.npmjs.com/). Let's look at an example below by importing the `random-words` library.

You'll need to make sure you install dependencies, which you can do by running the `package.json` cell above.

###### generate-random-word.js

```javascript
import {generate} from 'random-words';

console.log(generate())
```

## Importing other cells

Behind the scenes, cells are files of JavaScript or TypeScript code. They are ECMAScript 6 modules. Therefore you can export variables from one file and import them in another.

###### star-wars.js

```javascript
export const func = (name) => `I am your father, ${name}`
```

###### logger.js

```javascript
import {func} from './star-wars.js';

console.log(func("Luke"));
```

## Using secrets

For security purposes, you should avoid pasting secrets directly into Srcbooks. The mechanism you should leverage is [secrets](/secrets). These are stored securely and are accessed at runtime as environment variables.

Secrets can then be imported in Srcbooks using `process.env.SECRET_NAME`:
```
const API_KEY = process.env.SECRET_API_KEY;
const token = auth(API_KEY);
```
===== END EXAMPLE SRCBOOK =====

===== BEGIN FINAL INSTRUCTIONS =====
The user's Srcbook will be passed to you, surrounded with "==== BEGIN SRCBOOK ====" and "==== END SRCBOOK ====".
The location of the cell(s) you should create will be marked with  "==== INTRODUCE CELL HERE ====".
The user's intent will be passed to you between "==== BEGIN USER REQUEST ====" and "==== END USER REQUEST ====".
Your job is to write one or more cells. For code cells, the filename and the JavaScript code for this cell according to the Srcbook spec. 
Lean towards code cells if the user request is unclear.
ONLY RETURN THESE THINGS, NO PREAMBULE, NO SUFFIX, ONLY THE CELL CONTENTS.

Below is an example return value for a code cell that you would return. You would return _only_ what is within the <example> tags:
<example>
###### simple-ws-client.js
```javascript
import WebSocket from 'ws';

// Reference the same port the server is running on
const ws = new WebSocket('ws://localhost:5405');

ws.on('open', () => {
  ws.send('Hello from simple-client.js');
  ws.close();
});
```
</example>

 Act as a JavaScript expert, writing the best possible code you can. Focus on being elegant, concise, and clear.
===== END FINAL INSTRUCTIONS ===

================
File: api/prompts/cell-generator-typescript.txt
================
===== BEGIN INSTRUCTIONS CONTEXT =====

You are tasked with generating Srcbook cells for the user.

A Srcbook is a TypeScript notebook following a markdown-compatible format called `.src.md`.

## Srcbook spec

Structure of a Srcbook:
0. The language comment: `<!-- srcbook:{"language":"typescript"} -->`
1. Title cell (heading 1)
2. Package.json cell, listing deps
3. N more cells, which are either:
  a. Markdown cells (GitHub flavored Markdown)
  b. TypeScript code cells, which have a filename and source content.

The user is already working on an existing Srcbook, and is asking you to create one or more cells at the given position described below. Cells can be code and markdown. If unspecified lean towards code rather than markdown.
The Srcbook contents will be passed to you, as well as the user request about what they want in the new cell. 
Each code cell needs to have a unique filename, as it maps to a file on disk.

Code cells are valid TypeScript code. They have a unique filename. The filename is set as an heading 6 right before a code block with triple backticks. These backticks denote a code block and specify the language, which is always typescript. Remember that these are ECMAScript modules, so you can export variables and import exported variables from other code cells. For example:
<example>
###### conditional-types.ts
```typescript
type IsString<T> = T extends string ? "Yes" : "No";

export type A = IsString<string>; // "Yes"
export type B = IsString<number>; // "No"

console.log(`Is string: ${A}`); // Output: Is string: Yes
console.log(`Is string: ${B}`); // Output: Is string: No
```
</example>

Markdown cells are regular markdown. Just avoid using heading1 and heading6 within them, as those are reserved by the Srcbook spec.
===== END INSTRUCTIONS CONTEXT ======

===== BEGIN EXAMPLE SRCBOOK =====
<!-- srcbook:{"language":"typescript"} -->

# Breadth-First Search (BFS) in TypeScript

###### package.json

```json
{
  "type": "module",
  "dependencies": {},
  "devDependencies": {
    "tsx": "latest",
    "typescript": "latest",
    "@types/node": "^20.14.7"
  }
}
```

## Introduction to Breadth-First Search (BFS)

Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or an arbitrary node of a graph) and explores the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.

BFS is particularly useful for finding the shortest path on unweighted graphs, and it can be implemented using a queue data structure.

## BFS Algorithm Steps

1. **Initialize**: Start from the root node and add it to the queue.
2. **Dequeue**: Remove the front node from the queue and mark it as visited.
3. **Enqueue**: Add all unvisited neighbors of the dequeued node to the queue.
4. **Repeat**: Continue the process until the queue is empty.

## BFS Implementation in TypeScript

Let's implement BFS in TypeScript. We'll start by defining a simple graph structure and then implement the BFS algorithm.

###### graph.ts

```typescript
export class Graph {
  private adjacencyList: Map<number, number[]>;

  constructor() {
    this.adjacencyList = new Map();
  }

  addVertex(vertex: number) {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, []);
    }
  }

  addEdge(vertex1: number, vertex2: number) {
    if (this.adjacencyList.has(vertex1) && this.adjacencyList.has(vertex2)) {
      this.adjacencyList.get(vertex1)?.push(vertex2);
      this.adjacencyList.get(vertex2)?.push(vertex1);
    }
  }

  getNeighbors(vertex: number): number[] {
    return this.adjacencyList.get(vertex) || [];
  }
}
```

In the above code, we define a `Graph` class with methods to add vertices and edges, and to retrieve the neighbors of a vertex.

Next, let's implement the BFS algorithm.

###### bfs.ts

```typescript
import { Graph } from './graph.ts';

export function bfs(graph: Graph, startVertex: number): number[] {
  const visited: Set<number> = new Set();
  const queue: number[] = [startVertex];
  const result: number[] = [];

  while (queue.length > 0) {
    const vertex = queue.shift()!;
    if (!visited.has(vertex)) {
      visited.add(vertex);
      result.push(vertex);

      const neighbors = graph.getNeighbors(vertex);
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          queue.push(neighbor);
        }
      }
    }
  }

  return result;
}
```

In the `bfs` function, we use a queue to keep track of the vertices to be explored and a set to keep track of visited vertices. The function returns the order in which the vertices are visited.

## Example Usage

Let's create a graph and perform BFS on it.

###### example.ts

```typescript
import { Graph } from './graph.ts';
import { bfs } from './bfs.ts';

const graph = new Graph();
graph.addVertex(1);
graph.addVertex(2);
graph.addVertex(3);
graph.addVertex(4);
graph.addVertex(5);

graph.addEdge(1, 2);
graph.addEdge(1, 3);
graph.addEdge(2, 4);
graph.addEdge(3, 5);

const bfsResult = bfs(graph, 1);
console.log('BFS Traversal Order:', bfsResult);
```

In this example, we create a graph with 5 vertices and add edges between them. We then perform BFS starting from vertex 1 and print the traversal order.

## Conclusion

Breadth-First Search (BFS) is a fundamental algorithm for graph traversal. It is widely used in various applications, including finding the shortest path in unweighted graphs. In this srcbook, we implemented BFS in TypeScript and demonstrated its usage with a simple example.
===== END EXAMPLE SRCBOOK =====

===== BEGIN FINAL INSTRUCTIONS =====
The user's Srcbook will be passed to you, surrounded with "==== BEGIN SRCBOOK ====" and "==== END SRCBOOK ====".
The location of the cell(s) you should create will be marked with  "==== INTRODUCE CELL HERE ====".
The user's intent will be passed to you between "==== BEGIN USER REQUEST ====" and "==== END USER REQUEST ====".
Your job is to write one or more cells. For code cells, the filename and the TypeScript code for this cell according to the Srcbook spec. 
Lean towards code cells if the user request is unclear.
ONLY RETURN THESE THINGS, NO PREAMBULE, NO SUFFIX, ONLY THE CELL CONTENTS.

Below is an example return value for a code cell that you would return. You would return _only_ what is within the <example> tags:
<example>
###### conditional-types.ts
```typescript
type IsString<T> = T extends string ? "Yes" : "No";

type A = IsString<string>; // "Yes"
type B = IsString<number>; // "No"

console.log(`Is string: ${A}`); // Output: Is string: Yes
console.log(`Is string: ${B}`); // Output: Is string: No
```
</example>

 Act as a TypeScript expert coder, writing the best possible code you can. Focus on being elegant, concise, and clear.
===== END FINAL INSTRUCTIONS ===

================
File: api/prompts/code-updater-javascript.txt
================
===== BEGIN INSTRUCTIONS CONTEXT =====

You are tasked with editing a code snippet (or "cell") in a Srcbook."

A Srcbook is a JavaScript notebook following a markdown-compatible format.

## Srcbook spec

Structure of a Srcbook:
0. The language comment: `<!-- srcbook:{"language":"javascript"} -->`
1. Title cell (heading 1)
2. Package.json cell, listing deps
3. N more cells, which are either:
  a. Markdown cells (GitHub flavored Markdown)
  b. javascript code cells, which have a filename and source content.

The user is already working on an existing Srcbook, and is asking you to edit a specific code cell. 
The Srcbook contents will be passed to you as context, as well as the user request about what the edit intent they have for the code cell.
===== END INSTRUCTIONS CONTEXT ======

===== BEGIN EXAMPLE SRCBOOK =====
<!-- srcbook:{"language":"javascript"} -->

# Getting started

###### package.json

```json
{
  "type": "module",
  "dependencies": {
    "random-words": "^2.0.1"
  }
}
```

## What are Srcbooks?

Srcbooks are an interactive way of programming in JavaScript. They are similar to other notebooks like python's [jupyter notebooks](https://jupyter.org/), but unique in their own ways.
They are based on the [node](https://nodejs.org/en) runtime.

A Srcbook is composed of **cells**. Currently, there are 4 types of cells:
 1. **Title cell**: this is "Getting started" above. There is one per Srcbook.
 2. **package.json cell**: this is a special cell that manages dependencies for the Srcbook.
 3. **markdown cell**: what you're reading is a markdown cell. It allows you to easily express ideas with rich markup, rather than code comments, an idea called [literate programming](https://en.wikipedia.org/wiki/Literate_programming).
 4. **code cell**: think of these as JS or TS files. You can run them or export objects to be used in other cells.

###### simple-code.js

```javascript
// This is a trivial code cell. You can run me by
// clicking 'Run' or using the shortcut `cmd` + `enter`.
console.log("Hello, Srcbook!")
```

## Dependencies

You can add any external node.js-compatible dependency from [npm](https://www.npmjs.com/). Let's look at an example below by importing the `random-words` library.

You'll need to make sure you install dependencies, which you can do by running the `package.json` cell above.

###### generate-random-word.js

```javascript
import {generate} from 'random-words';

console.log(generate())
```

## Importing other cells

Behind the scenes, cells are files of JavaScript or TypeScript code. They are ECMAScript 6 modules. Therefore you can export variables from one file and import them in another.

###### star-wars.js

```javascript
export const func = (name) => `I am your father, ${name}`
```

###### logger.js

```javascript
import {func} from './star-wars.js';

console.log(func("Luke"));
```

## Using secrets

For security purposes, you should avoid pasting secrets directly into Srcbooks. The mechanism you should leverage is [secrets](/secrets). These are stored securely and are accessed at runtime as environment variables.

Secrets can then be imported in Srcbooks using `process.env.SECRET_NAME`:
```
const API_KEY = process.env.SECRET_API_KEY;
const token = auth(API_KEY);
```
===== END EXAMPLE SRCBOOK =====

===== BEGIN FINAL INSTRUCTIONS =====
The user's Srcbook will be passed to you, surrounded with "==== BEGIN SRCBOOK ====" and "==== END SRCBOOK ====".
The specific code cell they want updated will also be passed to you, surrounded with "==== BEGIN CODE CELL ====" and "==== END CODE CELL ====".
The user's intent will be passed to you between "==== BEGIN USER REQUEST ====" and "==== END USER REQUEST ====".
Your job is to edit the cell based on the contents of the Srcbook and the user's intent.
Act as a javascript expert coder, writing the best possible code you can. Focus on being elegant, concise, and clear.
ONLY RETURN THE CODE, NO PREAMBULE, NO BACKTICKS, NO MARKDOWN, NO SUFFIX, ONLY THE JAVASCRIPT CODE.
===== END FINAL INSTRUCTIONS ===

================
File: api/prompts/code-updater-typescript.txt
================
===== BEGIN INSTRUCTIONS CONTEXT =====

You are tasked with editing a code snippet (or "cell") in a Srcbook."

A Srcbook is a TypeScript notebook following a markdown-compatible format.

## Srcbook spec

Structure of a Srcbook:
0. The language comment: `<!-- srcbook:{"language":"typescript"} -->`
1. Title cell (heading 1)
2. Package.json cell, listing deps
3. N more cells, which are either:
  a. Markdown cells (GitHub flavored Markdown)
  b. TypeScript code cells, which have a filename and source content.

The user is already working on an existing Srcbook, and is asking you to edit a specific code cell. 
The Srcbook contents will be passed to you as context, as well as the user request about what the edit intent they have for the code cell.
===== END INSTRUCTIONS CONTEXT ======

===== BEGIN EXAMPLE SRCBOOK =====
<!-- srcbook:{"language":"typescript"} -->

# Breadth-First Search (BFS) in TypeScript

###### package.json

```json
{
  "type": "module",
  "dependencies": {},
  "devDependencies": {
    "tsx": "latest",
    "typescript": "latest",
    "@types/node": "^20.14.7"
  }
}
```

## Introduction to Breadth-First Search (BFS)

Breadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or an arbitrary node of a graph) and explores the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.

BFS is particularly useful for finding the shortest path on unweighted graphs, and it can be implemented using a queue data structure.

## BFS Algorithm Steps

1. **Initialize**: Start from the root node and add it to the queue.
2. **Dequeue**: Remove the front node from the queue and mark it as visited.
3. **Enqueue**: Add all unvisited neighbors of the dequeued node to the queue.
4. **Repeat**: Continue the process until the queue is empty.

## BFS Implementation in TypeScript

Let's implement BFS in TypeScript. We'll start by defining a simple graph structure and then implement the BFS algorithm.

###### graph.ts

```typescript
export class Graph {
  private adjacencyList: Map<number, number[]>;

  constructor() {
    this.adjacencyList = new Map();
  }

  addVertex(vertex: number) {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, []);
    }
  }

  addEdge(vertex1: number, vertex2: number) {
    if (this.adjacencyList.has(vertex1) && this.adjacencyList.has(vertex2)) {
      this.adjacencyList.get(vertex1)?.push(vertex2);
      this.adjacencyList.get(vertex2)?.push(vertex1);
    }
  }

  getNeighbors(vertex: number): number[] {
    return this.adjacencyList.get(vertex) || [];
  }
}
```

In the above code, we define a `Graph` class with methods to add vertices and edges, and to retrieve the neighbors of a vertex.

Next, let's implement the BFS algorithm.

###### bfs.ts

```typescript
import { Graph } from './graph.ts';

export function bfs(graph: Graph, startVertex: number): number[] {
  const visited: Set<number> = new Set();
  const queue: number[] = [startVertex];
  const result: number[] = [];

  while (queue.length > 0) {
    const vertex = queue.shift()!;
    if (!visited.has(vertex)) {
      visited.add(vertex);
      result.push(vertex);

      const neighbors = graph.getNeighbors(vertex);
      for (const neighbor of neighbors) {
        if (!visited.has(neighbor)) {
          queue.push(neighbor);
        }
      }
    }
  }

  return result;
}
```

In the `bfs` function, we use a queue to keep track of the vertices to be explored and a set to keep track of visited vertices. The function returns the order in which the vertices are visited.

## Example Usage

Let's create a graph and perform BFS on it.

###### example.ts

```typescript
import { Graph } from './graph.ts';
import { bfs } from './bfs.ts';

const graph = new Graph();
graph.addVertex(1);
graph.addVertex(2);
graph.addVertex(3);
graph.addVertex(4);
graph.addVertex(5);

graph.addEdge(1, 2);
graph.addEdge(1, 3);
graph.addEdge(2, 4);
graph.addEdge(3, 5);

const bfsResult = bfs(graph, 1);
console.log('BFS Traversal Order:', bfsResult);
```

In this example, we create a graph with 5 vertices and add edges between them. We then perform BFS starting from vertex 1 and print the traversal order.

## Conclusion

Breadth-First Search (BFS) is a fundamental algorithm for graph traversal. It is widely used in various applications, including finding the shortest path in unweighted graphs. In this srcbook, we implemented BFS in TypeScript and demonstrated its usage with a simple example.
===== END EXAMPLE SRCBOOK =====

===== BEGIN FINAL INSTRUCTIONS =====
The user's Srcbook will be passed to you, surrounded with "==== BEGIN SRCBOOK ====" and "==== END SRCBOOK ====".
The specific code cell they want updated will also be passed to you, surrounded with "==== BEGIN CODE CELL ====" and "==== END CODE CELL ====".
The user's intent will be passed to you between "==== BEGIN USER REQUEST ====" and "==== END USER REQUEST ====".
Your job is to edit the cell based on the contents of the Srcbook and the user's intent.
Act as a TypeScript expert coder, writing the best possible code you can. Focus on being elegant, concise, and clear.
ONLY RETURN THE CODE, NO PREAMBULE, NO BACKTICKS, NO MARKDOWN, NO SUFFIX, ONLY THE TYPESCRIPT CODE.
===== END FINAL INSTRUCTIONS ===

================
File: api/prompts/fix-cell-diagnostics.txt
================
You are tasked with suggesting a TypeScript diagnostics fix to a code block (or "cell") in a Srcbook.

A Srcbook is a TypeScript notebook which follows a markdown-compatible format.

The user is already working on an existing Srcbook, and the TypeScript linter has flagged an issue in one of the cells.

You will be given:
 * the entire Srcbook as useful context, surrounded with "==== BEGIN SRCBOOK ====" and "==== END SRCBOOK ====".
 * the specific code cell that needs to be fixed, surrounded with "==== BEGIN CODE CELL ====" and "==== END CODE CELL ====".
 * the diagnostics output from tsserver, surrounded with "==== BEGIN DIAGNOSTICS ====" and "==== END DIAGNOSTICS ====".

Your job is to fix the issues and suggest new code for the cell. Your response will be fed to a diffing algorithm against the original cell code, so you *have* to replace all of the code in the cell.
ONLY RETURN THE CODE. NO PREAMBULE, NO BACKTICKS, NO MARKDOWN, NO SUFFIX, ONLY THE TYPESCRIPT CODE.

================
File: api/prompts/srcbook-generator.txt
================
===== INSTRUCTIONS CONTEXT =====

You are tasked with generating a srcbook about a topic, which will be requested by the user.

A srcbook is a TypeScript or JavaScript notebook following a markdown-compatible format called .src.md. It's an interactive and rich way of programming that follows the literate programming idea.


Srcbooks are either in javascript, or typescript, and their markdown always starts with an html comment specifying the language, for example for javascript:

<!-- srcbook:{"language":"javascript"} -->

## Srcbook spec

Structure of a srcbook:
0. The language comment: <!-- srcbook:{"language":"javascript"} --> for example for javascript
1. Title cell (always first, as short as possible, no more than 44 characters)
2. Package.json cell (always second)
3. Markdown cells (GitHub flavored Markdown)
4. Code cells (either JavaScript or TypeScript), which have filenames and source contents.

Follow these steps to create your srcbook:

1. Title Cell:
Create a title cell as the first cell of your srcbook. Make it as short as possible, no more than 44 characters.
<example>
# Express server basics
</example>

2. Package.json Cell:
Create a package.json cell as the second cell. This should specify the dependencies required for your srcbook. Use triple backticks to denote a code block and specify it as JSON. If TypeScript, the `devDependencies` must always contain `tsx`, `typescript`, and `@types/node` using the `latest` version. Here is an example of a package.json for a TypeScript Srcbook:
<example>
###### package.json
```json
{
  "dependencies": {
    "axios": "^0.21.1"
  },
  "devDependencies": {
    "tsx": "latest",
    "typescript": "latest",
    "@types/node": "latest"
  }
}
```
</example>

3. Markdown Cells:
Create markdown cells to explain concepts, provide context, and guide the reader through the srcbook. Use GitHub flavored Markdown syntax. Include relevant headings, lists, and emphasis where appropriate. Do not use heading 1 (reserved for title) or heading 6 (reserved for code block headers). If it would be helpful and relevant to the user's ask, you may choose to include a diagram or chart using the Mermaid diagramming and charting tool. To do so, write mermaid syntax in a code block with "mermaid" set as the language identifier.

For example:

<example>
## Introduction to websockets

In this srcbook, we'll explore the fundamentals of **websockets** and the ws library using JavaScript. We'll cover:

- Basic concepts
- Key features
- Practical examples
</example>

Below is an example of using mermaid in a markdown cell:

<example>
A Bank account could be modeled using classes. For example:

```mermaid
---
title: Bank example
---
classDiagram
    class BankAccount
    BankAccount : +String owner
    BankAccount : +Bigdecimal balance
    BankAccount : +deposit(amount)
    BankAccount : +withdrawal(amount)
```
</example>

4. Code Cells:
Code cells are either JavaScript or TypeScript. They have a unique filename, for example something.js or something.ts respectively for JS or TS. The filename is set as an H6 right before a code block with triple backticks. Use triple backticks to denote a code block and specify the language as javascript or typescript. Remember that these are ECMAScript modules, so you can export variables and import from other code cells. Make sure to never reuse a filename twice. For example:
<example>
###### file1.js
```javascript
// Function to demonstrate a key concept of a given topic
export function demonstrateFeature(param) {
  // Your code here
  return result;
}

console.log(demonstrateFeature("example"));
```
</example>


===== END INSTRUCTIONS CONTEXT ======

===== BEGING EXAMPLES =====

Below are 3 examples of Srcbooks.

### Example 1: Getting started
<!-- srcbook:{"language":"javascript"} -->

# Getting started

###### package.json

```json
{
  "type": "module",
  "dependencies": {
    "random-words": "^2.0.1"
  }
}
```

## What are Srcbooks?

Srcbooks are an interactive way of programming in JavaScript or TypeScript. They are similar to other notebooks like python's [jupyter notebooks](https://jupyter.org/), but unique in their own ways.
They are based on the [node](https://nodejs.org/en) runtime.

A Srcbook is composed of **cells**. Currently, there are 4 types of cells:
 1. **Title cell**: this is "Getting started" above. There is one per Srcbook.
 2. **package.json cell**: this is a special cell that manages dependencies for the Srcbook.
 3. **markdown cell**: what you're reading is a markdown cell. It allows you to easily express ideas with rich markup, rather than code comments, an idea called [literate programming](https://en.wikipedia.org/wiki/Literate_programming).
 4. **code cell**: think of these as JS or TS files. You can run them or export objects to be used in other cells.

###### simple-code.js

```javascript
// This is a trivial code cell. You can run me by
// clicking 'Run' or using the shortcut `cmd` + `enter`.
console.log("Hello, Srcbook!")
```

## Dependencies

You can add any external node.js-compatible dependency from [npm](https://www.npmjs.com/). Let's look at an example below by importing the `random-words` library.

You'll need to make sure you install dependencies, which you can do by running the `package.json` cell above.

###### generate-random-word.js

```javascript
import {generate} from 'random-words';

console.log(generate())
```

## Importing other cells

Behind the scenes, cells are files of JavaScript or TypeScript code. They are ECMAScript 6 modules. Therefore you can export variables from one file and import them in another.

###### star-wars.js

```javascript
export const func = (name) => `I am your father, ${name}`
```

###### logger.js

```javascript
import {func} from './star-wars.js';

console.log(func("Luke"));
```

## Using secrets

For security purposes, you should avoid pasting secrets directly into Srcbooks. The mechanism you should leverage is [secrets](/secrets). These are stored securely and are accessed at runtime as environment variables.

Secrets can then be imported in Srcbooks using `process.env.SECRET_NAME`:
```
const API_KEY = process.env.SECRET_API_KEY;
const token = auth(API_KEY);
```

## Exporting and sharing Srcbooks

Srcbooks are meant to be collaborative. They export to a friendly `.src.md` format, which is valid markdown and can be opened in any text editor.

You can export Srcbooks by clicking the `Export` link in the top level menu on the left.

You can also import `.src.md` files directly in this application if you want to run, modify, or re-export them.

### Example 2: LangGraph web agent
<!-- srcbook:{"language":"typescript"} -->

# LangGraph web agent

###### package.json

```json
{
  "type": "module",
  "dependencies": {
    "@langchain/community": "^0.2.12",
    "@langchain/core": "^0.2.8",
    "@langchain/langgraph": "^0.0.24",
    "@langchain/openai": "^0.1.3",
    "@types/node": "^20.14.7",
    "better-sqlite3": "^9.6.0",
    "tsx": "latest",
    "typescript": "latest"
  }
}
```

## LangGraph tutorial

Based on [this tutorial](https://langchain-ai.github.io/langgraphjs/reference/).

We're going to build an agent that can search the web using the [Tavily Search API](https://tavily.com/).

First, let's ensure we've setup the right env variables:

###### env-check.ts

```typescript
import assert from 'node:assert';

assert.ok(process.env.OPENAI_API_KEY, 'You need to set OPENAI_API_KEY');
assert.ok(process.env.TAVILY_API_KEY, 'You need to set TAVILY_API_KEY');
```

## Define the agent

Now, let's define the Agent with LangGraph.js

###### agent.ts

```typescript
import { HumanMessage } from "@langchain/core/messages";
import { TavilySearchResults } from "@langchain/community/tools/tavily_search";
import { ChatOpenAI } from "@langchain/openai";
import { END, START, StateGraph, StateGraphArgs } from "@langchain/langgraph";
import { SqliteSaver } from "@langchain/langgraph/checkpoint/sqlite"
// import { MemorySaver } from "@langchain/langgraph";
import { ToolNode } from "@langchain/langgraph/prebuilt";

// Define the state interface
interface AgentState {
  messages: HumanMessage[];
}

// We'll use a local sqlite DB for memory
export const DB_NAME = 'langgraph_memory.db'

// Define the graph state
const graphState: StateGraphArgs<AgentState>["channels"] = {
  messages: {
    value: (x: HumanMessage[], y: HumanMessage[]) => x.concat(y),
    default: () => [],
  },
};

// Define the tools for the agent to use
const tools = [new TavilySearchResults({ maxResults: 1 })];
const toolNode = new ToolNode<AgentState>(tools);

const model = new ChatOpenAI({ model: 'gpt-4o', temperature: 0 }).bindTools(tools);

// Define the function that determines whether to continue or not
function shouldContinue(state: AgentState): "tools" | typeof END {
  const messages = state.messages;
  const lastMessage = messages[messages.length - 1];

  // If the LLM makes a tool call, then we route to the "tools" node
  if (lastMessage.additional_kwargs.tool_calls) {
    return "tools";
  }
  // Otherwise, we stop (reply to the user)
  return END;
}

// Define the function that calls the model
async function callModel(state: AgentState) {
  const messages = state.messages;
  const response = await model.invoke(messages);

  // We return a list, because this will get added to the existing list
  return { messages: [response] };
}

// Define a new graph
const workflow = new StateGraph<AgentState>({ channels: graphState })
  .addNode("agent", callModel)
  .addNode("tools", toolNode)
  .addEdge(START, "agent")
  .addConditionalEdges("agent", shouldContinue)
  .addEdge("tools", "agent");

// Initialize memory to persist state between graph runs
export const memory = SqliteSaver.fromConnString(DB_NAME);
// const checkpointer = new MemorySaver();

// Finally, we compile it!
// This compiles it into a LangChain Runnable.
// Note that we're (optionally) passing the memory when compiling the graph
export const app = workflow.compile({ checkpointer: memory });

```

Now that we've built our app, let's invoke it to first get the weather in SF:

###### sf-weather.ts

```typescript
import {app} from './agent.ts';
import { HumanMessage } from "@langchain/core/messages";

// Reference a thread
const thread = { configurable: { thread_id: "42" }};

// Use the Runnable
const finalState = await app.invoke(
  { messages: [new HumanMessage("what is the weather in sf")] },
  thread
);

console.log(finalState.messages[finalState.messages.length - 1].content)
```

Now when we pass the same `thread_id`, in this case `"42"`, the conversation context is retained via the saved state that we've set in a local sqliteDB (i.e. stored list of messages).

Also, in this next example, we demonstrate streaming output.

###### ny-weather.ts

```typescript
import {app} from './agent.ts';
import { HumanMessage } from '@langchain/core/messages';

const nextState = await app.invoke(
  { messages: [new HumanMessage("what about ny")] },
  { configurable: { thread_id: "42"} }
);

console.log(nextState.messages[nextState.messages.length - 1].content);
```

## Clear memory

The memory was saved in the sqlite db `./langGraph.db`. If you want to clear it, run the following cell

###### clear.ts

```typescript
import {DB_NAME} from './agent.ts';
import fs from 'node:fs';
// I can't find good documentation on the memory module, so let's apply the nuclear method

fs.rmSync(DB_NAME);
```

### Example 3: Intro to websockets
<!-- srcbook:{"language":"javascript"} -->

# Intro to WebSockets

###### package.json

```json
{
  "type": "module",
  "dependencies": {
    "ws": "^8.17.1"
  }
}
```

This Srcbook is a fun demonstration of building a simple WebSocket client and server in Node.js using the [ws library](https://github.com/websockets/ws). We'll explore the basic concepts of communicating over WebSockets and showcase Srcbook's ability to host long-running processes.

## WebSockets

[Wikipedia defines](https://en.wikipedia.org/wiki/WebSocket) WebSocket as:

> WebSocket is a computer communications protocol, providing a simultaneous two-way communication channel over a single Transmission Control Protocol (TCP) connection.

The important callout here is "two-way communication channel," which differentiates it from most web-based network communication that follows a request-response pattern. WebSockets enable the server to send a message, _unprompted_, to a client without other tricks like [polling](https://en.wikipedia.org/wiki/Polling_(computer_science)).

Applications typically leverage WebSockets when they need to repeatedly inform the client of state changes, like communication products that push new messages to the client or update the presence of users in a chat room. Other typical use cases involve realtime notifications, ecommerce item availability updates, and forwarding process output to code cells in Srcbook :)

### WebSockets in Node.js

One of the most popular libraries for WebSockets in Node.js is the [ws library](https://www.npmjs.com/package/ws) with over 70 million weekly downloads.

Below we implement a simple WebSocket _server_ using `ws`.

###### simple-server.js

```javascript
import { WebSocketServer } from 'ws';

// Start this simple server on port 5405
const wss = new WebSocketServer({ port: 5405 });

wss.on('connection', (socket) => {
  socket.on('message', (data) => {
    console.log('Server received: %s', data);
  });
  console.log("New client connected")
});
```

This simple server does nothing more than wait for incoming connections and log the messages it receives.

Next, we need a _client_ to connect and send messages to it. Note the client is running in a Node.js process, not in the browser. Backends communicate over WebSockets too!

###### simple-client.js

```javascript
import WebSocket from 'ws';

// Reference the same port the server is running on
const ws = new WebSocket('ws://localhost:5405');

ws.on('open', () => {
  ws.send('Hello from simple-client.js');
  ws.close();
});

```

Our simple client establishes a connection with the server, sends one message, and closes the connection. To run this example, first run the server and then run the client. Output is logged under the simple-server.js cell above.

## Stateful connections

The example above is not terribly interesting. WebSockets become more useful when the server tracks open connections and sends messages to the client.

###### stateful-server.js

```javascript
import { WebSocketServer } from 'ws';

// Start this simple server on port 5405
const wss = new WebSocketServer({ port: 5406 });

// Utility to create auto-incrementing ids for clients
const createClientId = ((id) => () => ++id)(0);

const connectedClients = [];

function broadcast(senderId, message) {
  for (const client of connectedClients) {
    // The client who is sending the message should not receive it
    if (client.id !== senderId) {
      client.socket.send(JSON.stringify(message));
    }
  }
}

wss.on('connection', (socket) => {
  const clientId = createClientId();

  // Store the client connection
  connectedClients.push({id: clientId, socket});

  // Inform others a new client has connected
  broadcast(clientId, {
    type: 'client:connected',
    payload: `Client ${clientId} connected`
  });

  // When the server receives a broadcast message,
  // send it to all the other connected clients
  socket.on('message', (data) => {
    const message = JSON.parse(data);
    if (message.type === 'broadcast') {
      broadcast(clientId, {
        type: "broadcast",
        payload: message.payload
      })
    }
  });

  socket.on('close', () => {
    // Inform others a client has disconnected
    broadcast(clientId, {
      type: 'client:disconnected',
      payload: `Client ${clientId} disconnected`
    });

    // Important: remember to remove the socket from
    // server state when the connection is closed.
    const idx = connectedClients.findIndex(({id}) => id === clientId);
    connectedClients.splice(idx, 1);
  });
});
```

###### client.js

```javascript
import WebSocket from 'ws';

console.log("Starting up");

const client1 = new WebSocket('ws://localhost:5406');
client1.on('message', (data) => {
  const message = JSON.parse(data);
  console.log(`Client 1 received ${message.type} message: ${message.payload}`)
});

// Simulate latency in between clients connecting
await new Promise((resolve) => setTimeout(resolve, 1500));

const client2 = new WebSocket('ws://localhost:5406');
client2.on('message', (data) => {
  const message = JSON.parse(data);
  console.log(`Client 2 received ${message.type} message: ${message.payload}`)
});

// We put this inside the open event to ensure the client has
// finished connecting to the server before sending a message.
client2.on('open', () => {
  // Client 2 sends a 'broadcast' message which the server will
  // broadcast all other connected clients.
  client2.send(JSON.stringify({type: 'broadcast', payload: 'Hello'}));
});

// Simulate latency in between clients disconnecting
await new Promise((resolve) => setTimeout(resolve, 1500));

client1.close();

// Simulate latency before second client disconnects
await new Promise((resolve) => setTimeout(resolve, 1500));

client2.close();

console.log("Shutting down");
```

## Explanation

The above example illustrates a stateful server that keeps track of the clients whom are connected. The server proactively sends messages to other connected clients when a new client joins and an existing one disconnects. The server also broadcasts messages to all other connected clients on behalf of any given client. This is a heavily simplified version of something like a chat room.

One of the more tedious aspects of this is keeping track of the state about connected clients. This is unlike typical HTTP request/reply patterns in which the server is stateless. It is especially tricky when you scale your WebSocket server horizontally because different clients are connected to different instances of your application. When this happens, state needs to be coordinated amongst all instances of the application, which typically requires extra infrastructure and consequently extra maintanence and performance considerations.

===== END EXAMPLES =====

===== FINAL INSTRUCTIONS =====
The user will describe the srcbook they want, your job is to create it following the above guidelines. Aim for a balance of explanatory markdown cells and demonstrative code cells. If they express intent that they want to learn, use more markdown. If they clearly want to prototype things, use more code. Be brief but thorough. A typical srcbook will have 4 to 10 cells, but if the request makes sense for that rule to be broken, that's fine.

Response with _only_ the srcbook contents, no preambule, prefix, or suffix at the end.
===== END FINAL INSTRUCTIONS ===

================
File: api/server/channels/app.mts
================
import path from 'node:path';
import fs from 'node:fs/promises';
import {
  PreviewStartPayloadSchema,
  PreviewStopPayloadSchema,
  FileUpdatedPayloadSchema,
  FileType,
  FileUpdatedPayloadType,
  PreviewStartPayloadType,
  PreviewStopPayloadType,
  DepsInstallPayloadType,
  DepsInstallPayloadSchema,
  DepsClearPayloadType,
  DepsStatusPayloadSchema,
} from '@srcbook/shared';

import WebSocketServer, {
  type MessageContextType,
  type ConnectionContextType,
} from '../ws-client.mjs';
import { loadApp } from '../../apps/app.mjs';
import { fileUpdated, pathToApp } from '../../apps/disk.mjs';
import { directoryExists } from '../../fs-utils.mjs';
import {
  getAppProcess,
  setAppProcess,
  deleteAppProcess,
  npmInstall,
  viteServer,
} from '../../apps/processes.mjs';

const VITE_PORT_REGEX = /Local:.*http:\/\/localhost:([0-9]{1,4})/;

type AppContextType = MessageContextType<'appId'>;

async function previewStart(
  _payload: PreviewStartPayloadType,
  context: AppContextType,
  wss: WebSocketServer,
) {
  const app = await loadApp(context.params.appId);

  if (!app) {
    return;
  }

  const existingProcess = getAppProcess(app.externalId, 'vite:server');

  if (existingProcess) {
    wss.broadcast(`app:${app.externalId}`, 'preview:status', {
      status: 'running',
      url: `http://localhost:${existingProcess.port}/`,
    });
    return;
  }

  wss.broadcast(`app:${app.externalId}`, 'preview:status', {
    url: null,
    status: 'booting',
  });

  const onChangePort = (newPort: number) => {
    const process = getAppProcess(app.externalId, 'vite:server');

    // This is not expected to happen
    if (!process) {
      wss.broadcast(`app:${app.externalId}`, 'preview:status', {
        url: null,
        status: 'stopped',
        code: null,
      });
      return;
    }

    setAppProcess(app.externalId, { ...process, port: newPort });

    wss.broadcast(`app:${app.externalId}`, 'preview:status', {
      url: `http://localhost:${newPort}/`,
      status: 'running',
    });
  };

  viteServer(app.externalId, {
    args: [],
    stdout: (data) => {
      const encodedData = data.toString('utf8');
      console.log(encodedData);

      wss.broadcast(`app:${app.externalId}`, 'preview:log', {
        log: {
          type: 'stdout',
          data: encodedData,
        },
      });

      const potentialPortMatch = VITE_PORT_REGEX.exec(encodedData);
      if (potentialPortMatch) {
        const portString = potentialPortMatch[1]!;
        const port = parseInt(portString, 10);
        onChangePort(port);
      }
    },
    stderr: (data) => {
      const encodedData = data.toString('utf8');
      console.error(encodedData);

      wss.broadcast(`app:${app.externalId}`, 'preview:log', {
        log: {
          type: 'stderr',
          data: encodedData,
        },
      });
    },
    onExit: (code) => {
      deleteAppProcess(app.externalId, 'vite:server');

      wss.broadcast(`app:${app.externalId}`, 'preview:status', {
        url: null,
        status: 'stopped',
        code: code,
      });
    },
    onError: (_error) => {
      // Errors happen when we try to run vite before node modules are installed.
      // Make sure we clean up the app process and inform the client.
      deleteAppProcess(app.externalId, 'vite:server');

      // TODO: Use a different event to communicate to the client there was an error.
      // If the error is ENOENT, for example, it means node_modules and/or vite is missing.
      wss.broadcast(`app:${app.externalId}`, 'preview:status', {
        url: null,
        status: 'stopped',
        code: null,
      });
    },
  });
}

async function previewStop(
  _payload: PreviewStopPayloadType,
  context: AppContextType,
  conn: ConnectionContextType,
) {
  const app = await loadApp(context.params.appId);

  if (!app) {
    return;
  }

  const result = getAppProcess(app.externalId, 'vite:server');

  if (!result) {
    conn.reply(`app:${app.externalId}`, 'preview:status', {
      url: null,
      status: 'stopped',
      code: null,
    });
    return;
  }

  // Killing the process should result in its onExit handler being called.
  // The onExit handler will remove the process from the processMetadata map
  // and send the `preview:status` event with a value of 'stopped'
  result.process.kill('SIGTERM');
}

async function dependenciesInstall(payload: DepsInstallPayloadType, context: AppContextType) {
  const app = await loadApp(context.params.appId);

  if (!app) {
    return;
  }

  npmInstall(app.externalId, {
    packages: payload.packages ?? undefined,
  });
}

async function clearNodeModules(
  _payload: DepsClearPayloadType,
  context: AppContextType,
  conn: ConnectionContextType,
) {
  const app = await loadApp(context.params.appId);

  if (!app) {
    return;
  }

  const appPath = pathToApp(app.externalId);
  const nodeModulesPath = path.join(appPath, 'node_modules');
  await fs.rm(nodeModulesPath, { recursive: true, force: true });

  conn.reply(`app:${app.externalId}`, 'deps:status:response', {
    nodeModulesExists: false,
  });
}

async function dependenciesStatus(
  _payload: DepsClearPayloadType,
  context: AppContextType,
  conn: ConnectionContextType,
) {
  const app = await loadApp(context.params.appId);

  if (!app) {
    return;
  }

  const appPath = pathToApp(app.externalId);
  const nodeModulesPath = path.join(appPath, 'node_modules');
  conn.reply(`app:${app.externalId}`, 'deps:status:response', {
    nodeModulesExists: await directoryExists(nodeModulesPath),
  });
}

async function onFileUpdated(payload: FileUpdatedPayloadType, context: AppContextType) {
  const app = await loadApp(context.params.appId);

  if (!app) {
    return;
  }

  fileUpdated(app, payload.file as FileType);
}

export function register(wss: WebSocketServer) {
  wss
    .channel('app:<appId>')
    .on('preview:start', PreviewStartPayloadSchema, (payload, context) =>
      previewStart(payload, context, wss),
    )
    .on('preview:stop', PreviewStopPayloadSchema, previewStop)
    .on('deps:install', DepsInstallPayloadSchema, dependenciesInstall)
    .on('deps:clear', DepsInstallPayloadSchema, clearNodeModules)
    .on('deps:status', DepsStatusPayloadSchema, dependenciesStatus)
    .on('file:updated', FileUpdatedPayloadSchema, onFileUpdated)
    .onJoin((_payload, context, conn) => {
      const appExternalId = (context as AppContextType).params.appId;

      // When connecting, send back info about an in flight npm install if one exists
      const npmInstallProcess = getAppProcess(appExternalId, 'npm:install');
      if (npmInstallProcess) {
        conn.reply(`app:${appExternalId}`, 'deps:install:status', { status: 'installing' });
      }
    });
}

================
File: api/server/http.mts
================
import Path from 'node:path';
import { posthog } from '../posthog-client.mjs';
import fs from 'node:fs/promises';
import { SRCBOOKS_DIR } from '../constants.mjs';
import express, { type Application, type Response } from 'express';
import cors from 'cors';
import {
  createSession,
  findSession,
  deleteSessionByDirname,
  updateSession,
  sessionToResponse,
  listSessions,
  exportSrcmdText,
} from '../session.mjs';
import { generateCells, generateSrcbook, healthcheck, streamEditApp } from '../ai/generate.mjs';
import { streamParsePlan } from '../ai/plan-parser.mjs';
import {
  getConfig,
  updateConfig,
  getSecrets,
  addSecret,
  getHistory,
  appendToHistory,
  removeSecret,
  associateSecretWithSession,
  disassociateSecretWithSession,
} from '../config.mjs';
import {
  createSrcbook,
  removeSrcbook,
  importSrcbookFromSrcmdFile,
  importSrcbookFromSrcmdText,
  importSrcbookFromSrcmdUrl,
  updateSessionEnvTypeDeclarations,
} from '../srcbook/index.mjs';
import { readdir } from '../fs-utils.mjs';
import { EXAMPLE_SRCBOOKS } from '../srcbook/examples.mjs';
import { pathToSrcbook } from '../srcbook/path.mjs';
import { isSrcmdPath } from '../srcmd/paths.mjs';
import {
  loadApps,
  loadApp,
  createApp,
  serializeApp,
  deleteApp,
  createAppWithAi,
  updateApp,
} from '../apps/app.mjs';
import { toValidPackageName } from '../apps/utils.mjs';
import {
  deleteFile,
  renameFile,
  loadDirectory,
  loadFile,
  createFile,
  createDirectory,
  renameDirectory,
  deleteDirectory,
  getFlatFilesForApp,
} from '../apps/disk.mjs';
import { CreateAppSchema } from '../apps/schemas.mjs';
import { AppGenerationFeedbackType } from '@srcbook/shared';
import { createZipFromApp } from '../apps/disk.mjs';
import { checkoutCommit, commitAllFiles, getCurrentCommitSha } from '../apps/git.mjs';
import { streamJsonResponse } from './utils.mjs';

const app: Application = express();

const router = express.Router();

router.use(express.json());

router.options('/file', cors());

router.post('/file', cors(), async (req, res) => {
  const { file } = req.body as {
    file: string;
  };

  try {
    const content = await fs.readFile(file, 'utf8');
    const cell = file.includes('.srcbook/srcbooks') && !file.includes('node_modules');
    const filename = cell ? file.split('/').pop() || file : file;

    return res.json({
      error: false,
      result: {
        content: cell ? '' : content,
        filename,
        type: cell ? 'cell' : 'filepath',
      },
    });
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, result: error.stack });
  }
});

router.options('/examples', cors());
router.get('/examples', cors(), (_, res) => {
  return res.json({ result: EXAMPLE_SRCBOOKS });
});

// Create a new srcbook
router.options('/srcbooks', cors());
router.post('/srcbooks', cors(), async (req, res) => {
  const { name, language } = req.body;

  // TODO: Zod
  if (typeof name !== 'string' || name.length < 1 || name.length > 44 || name.trim() === '') {
    return res.json({
      error: true,
      result: 'Srcbook is required and cannot be more than 44 characters',
    });
  }

  posthog.capture({
    event: 'user created srcbook',
    properties: { language },
  });

  try {
    const srcbookDir = await createSrcbook(name, language);
    return res.json({ error: false, result: { name, path: srcbookDir } });
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, result: error.stack });
  }
});

router.options('/srcbooks/:id', cors());
router.delete('/srcbooks/:id', cors(), async (req, res) => {
  const { id } = req.params;
  const srcbookDir = pathToSrcbook(id);
  removeSrcbook(srcbookDir);
  posthog.capture({ event: 'user deleted srcbook' });
  await deleteSessionByDirname(srcbookDir);
  return res.json({ error: false, deleted: true });
});

// Import a srcbook from a .src.md file or srcmd text.
router.options('/import', cors());
router.post('/import', cors(), async (req, res) => {
  const { path, text, url } = req.body;

  if (typeof path === 'string' && !isSrcmdPath(path)) {
    return res.json({ error: true, result: 'Importing only works with .src.md files' });
  }

  try {
    if (typeof path === 'string') {
      posthog.capture({ event: 'user imported srcbook from file' });
      const srcbookDir = await importSrcbookFromSrcmdFile(path);
      return res.json({ error: false, result: { dir: srcbookDir } });
    } else if (typeof url === 'string') {
      posthog.capture({ event: 'user imported srcbook from url' });
      const srcbookDir = await importSrcbookFromSrcmdUrl(url);
      return res.json({ error: false, result: { dir: srcbookDir } });
    } else {
      posthog.capture({ event: 'user imported srcbook from text' });
      const srcbookDir = await importSrcbookFromSrcmdText(text);
      return res.json({ error: false, result: { dir: srcbookDir } });
    }
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, result: error.stack });
  }
});

// Generate a srcbook using AI from a simple string query
router.options('/generate', cors());
router.post('/generate', cors(), async (req, res) => {
  const { query } = req.body;

  try {
    posthog.capture({ event: 'user generated srcbook with AI', properties: { query } });
    const result = await generateSrcbook(query);
    const srcbookDir = await importSrcbookFromSrcmdText(result.text);
    return res.json({ error: false, result: { dir: srcbookDir } });
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, result: error.stack });
  }
});

// Generate a cell using AI from a query string
router.options('/sessions/:id/generate_cells', cors());
router.post('/sessions/:id/generate_cells', cors(), async (req, res) => {
  // @TODO: zod
  const { insertIdx, query } = req.body;

  try {
    posthog.capture({ event: 'user generated cell with AI', properties: { query } });
    const session = await findSession(req.params.id);
    const { error, errors, cells } = await generateCells(query, session, insertIdx);
    const result = error ? errors : cells;
    return res.json({ error, result });
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, result: error.stack });
  }
});

// Test that the AI generation is working with the current configuration
router.options('/ai/healthcheck', cors());
router.get('/ai/healthcheck', cors(), async (_req, res) => {
  try {
    const result = await healthcheck();
    return res.json({ error: false, result });
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, result: error.stack });
  }
});

// Open an existing srcbook by passing a path to the srcbook's directory
router.options('/sessions', cors());
router.post('/sessions', cors(), async (req, res) => {
  const { path } = req.body;

  posthog.capture({ event: 'user opened srcbook' });
  const dir = await readdir(path);

  if (!dir.exists) {
    return res.json({ error: true, result: `${path} is not a srcbook directory` });
  }

  try {
    const session = await createSession(path);
    return res.json({ error: false, result: sessionToResponse(session) });
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, result: error.stack });
  }
});

router.get('/sessions', cors(), async (_req, res) => {
  const sessions = await listSessions();
  return res.json({ error: false, result: Object.values(sessions).map(sessionToResponse) });
});

router.options('/sessions/:id', cors());

router.get('/sessions/:id', cors(), async (req, res) => {
  const { id } = req.params;

  try {
    let session = await findSession(id);

    if (!session) {
      // This might be after a server restart, so we should try
      // to see if we have a directory for this sessionId.
      const exists = await fs.stat(Path.join(SRCBOOKS_DIR, id));
      if (exists) {
        session = await createSession(Path.join(SRCBOOKS_DIR, id));
      }
    }
    updateSession(session, { openedAt: Date.now() }, false);
    return res.json({ error: false, result: sessionToResponse(session) });
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, result: error.stack });
  }
});

router.options('/sessions/:id/export-text', cors());
router.get('/sessions/:id/export-text', cors(), async (req, res) => {
  const session = await findSession(req.params.id);

  posthog.capture({ event: 'user exported srcbook' });

  try {
    const text = exportSrcmdText(session);
    res.setHeader('Content-Type', 'text/markdown');
    res.send(text).end();
    return;
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, result: error.stack });
  }
});

router.options('/sessions/:id/secrets/:name', cors());
router.put('/sessions/:id/secrets/:name', cors(), async (req, res) => {
  const { id, name } = req.params;
  await associateSecretWithSession(name, id);
  await updateSessionEnvTypeDeclarations(id);
  return res.status(204).end();
});

router.delete('/sessions/:id/secrets/:name', cors(), async (req, res) => {
  const { id, name } = req.params;
  await disassociateSecretWithSession(name, id);
  await updateSessionEnvTypeDeclarations(id);
  return res.status(204).end();
});

router.options('/settings', cors());

router.get('/settings', cors(), async (_req, res) => {
  const config = await getConfig();
  return res.json({ error: false, result: config });
});

router.post('/settings', cors(), async (req, res) => {
  try {
    const updated = await updateConfig(req.body);

    posthog.capture({
      event: 'user updated settings',
      properties: { setting_changed: Object.keys(req.body) },
    });

    return res.json({ result: updated });
  } catch (e) {
    const error = e as unknown as Error;
    console.error(error);
    return res.json({ error: true, message: error.stack });
  }
});

router.options('/secrets', cors());

router.get('/secrets', cors(), async (_req, res) => {
  const secrets = await getSecrets();
  return res.json({ result: secrets });
});

// Create a new secret
router.post('/secrets', cors(), async (req, res) => {
  const { name, value } = req.body;
  posthog.capture({ event: 'user created secret' });
  const updated = await addSecret(name, value);
  return res.json({ result: updated });
});

router.options('/secrets/:name', cors());

router.post('/secrets/:name', cors(), async (req, res) => {
  const { name } = req.params;
  const { name: newName, value } = req.body;
  await removeSecret(name);
  const updated = await addSecret(newName, value);
  return res.json({ result: updated });
});

router.delete('/secrets/:name', cors(), async (req, res) => {
  const { name } = req.params;
  const updated = await removeSecret(name);
  return res.json({ result: updated });
});

router.options('/feedback', cors());
router.post('/feedback', cors(), async (req, res) => {
  const { feedback, email } = req.body;
  // Every time you modify the appscript here, you'll need to update the URL below
  // @TODO: once we have an env variable setup, we can use that here.
  const url =
    'https://script.google.com/macros/s/AKfycbxPrg8z47SkJnHyoZBYqNtkcH8hBe12f-f2UJJ3PcIHmKdbMMuJuPoOemEB1ib8a_IKCg/exec';

  const result = await fetch(url, {
    method: 'POST',
    body: JSON.stringify({ feedback, email }),
    headers: { 'Content-Type': 'text/plain;charset=utf-8' },
  });

  return res.json({ success: result.ok });
});

type NpmSearchResult = {
  package: {
    name: string;
    version: string;
    description: string;
  };
};

/*
 * Search for npm packages for a given query.
 * Returns the name, version and description of the packages.
 * Consider debouncing calls to this API on the client side.
 */
router.options('/npm/search', cors());
router.get('/npm/search', cors(), async (req, res) => {
  const { q, size } = req.query;
  const response = await fetch(`https://registry.npmjs.org/-/v1/search?text=${q}&size=${size}`);
  if (!response.ok) {
    return res.json({ error: true, result: [] });
  }
  const packages = await response.json();
  const results = packages.objects.map((o: NpmSearchResult) => {
    return { name: o.package.name, version: o.package.version, description: o.package.description };
  });
  return res.json({ result: results });
});

router.options('/subscribe', cors());
router.post('/subscribe', cors(), async (req, res) => {
  const { email } = req.body;
  const hubResponse = await fetch('https://hub.srcbook.com/api/subscribe', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ email }),
  });

  if (hubResponse.ok) {
    return res.json({ success: true });
  } else {
    return res.status(hubResponse.status).json({ success: false });
  }
});

function error500(res: Response, e: Error) {
  const error = e as unknown as Error;
  console.error(error);
  return res.status(500).json({ error: 'An unexpected error occurred.' });
}

router.options('/apps', cors());
router.post('/apps', cors(), async (req, res) => {
  const result = CreateAppSchema.safeParse(req.body);

  if (result.success === false) {
    const errors = result.error.errors.map((error) => error.message);
    return res.status(400).json({ errors });
  }

  const attrs = result.data;

  posthog.capture({
    event: 'user created app',
    properties: { prompt: typeof attrs.prompt === 'string' ? attrs.prompt : 'N/A' },
  });

  try {
    if (typeof attrs.prompt === 'string') {
      const app = await createAppWithAi({ name: attrs.name, prompt: attrs.prompt });
      return res.json({ data: serializeApp(app) });
    } else {
      // TODO do we really need to keep this?
      const app = await createApp(attrs);
      return res.json({ data: serializeApp(app) });
    }
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps', cors());
router.get('/apps', cors(), async (req, res) => {
  const sort = req.query.sort === 'desc' ? 'desc' : 'asc';

  try {
    const apps = await loadApps(sort);
    return res.json({ data: apps.map(serializeApp) });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id', cors());
router.get('/apps/:id', cors(), async (req, res) => {
  const { id } = req.params;

  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    return res.json({ data: serializeApp(app) });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id', cors());
router.put('/apps/:id', cors(), async (req, res) => {
  const { id } = req.params;
  const { name } = req.body;

  if (typeof name !== 'string' || name.trim() === '') {
    return res.status(400).json({ error: 'Name is required' });
  }

  try {
    const app = await updateApp(id, { name });

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    return res.json({ data: serializeApp(app) });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id', cors());
router.delete('/apps/:id', cors(), async (req, res) => {
  const { id } = req.params;

  try {
    await deleteApp(id);
    return res.json({ deleted: true });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/directories', cors());
router.get('/apps/:id/directories', cors(), async (req, res) => {
  const { id } = req.params;

  // TODO: validate and ensure path is not absolute
  const path = typeof req.query.path === 'string' ? req.query.path : '.';

  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    const directory = await loadDirectory(app, path);

    return res.json({ data: directory });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/edit', cors());
router.post('/apps/:id/edit', cors(), async (req, res) => {
  const { id } = req.params;
  const { query, planId } = req.body;
  posthog.capture({ event: 'user edited app with ai' });
  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }
    const validName = toValidPackageName(app.name);
    const files = await getFlatFilesForApp(String(app.externalId));
    const result = await streamEditApp(validName, files, query, app.externalId, planId);
    const planStream = await streamParsePlan(result, app, query, planId);

    return streamJsonResponse(planStream, res, { status: 200 });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/commit', cors());
router.get('/apps/:id/commit', cors(), async (req, res) => {
  const { id } = req.params;
  const app = await loadApp(id);
  if (!app) {
    return res.status(404).json({ error: 'App not found' });
  }

  const sha = await getCurrentCommitSha(app);
  return res.json({ sha });
});
router.post('/apps/:id/commit', cors(), async (req, res) => {
  const { id } = req.params;
  const { message } = req.body;
  // import the commit function from the apps/git.mjs file
  const app = await loadApp(id);

  if (!app) {
    return res.status(404).json({ error: 'App not found' });
  }

  const sha = await commitAllFiles(app, message);
  return res.json({ sha });
});

router.options('/apps/:id/checkout/:sha', cors());
router.post('/apps/:id/checkout/:sha', cors(), async (req, res) => {
  const { id, sha } = req.params;
  const app = await loadApp(id);

  if (!app) {
    return res.status(404).json({ error: 'App not found' });
  }

  await checkoutCommit(app, sha);
  return res.json({ success: true, sha });
});

router.options('/apps/:id/directories', cors());
router.post('/apps/:id/directories', cors(), async (req, res) => {
  const { id } = req.params;

  // TODO: validate and ensure path is not absolute
  const { dirname, basename } = req.body;

  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    const directory = await createDirectory(app, dirname, basename);

    return res.json({ data: directory });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/directories', cors());
router.delete('/apps/:id/directories', cors(), async (req, res) => {
  const { id } = req.params;

  // TODO: validate and ensure path is not absolute
  const path = typeof req.query.path === 'string' ? req.query.path : '.';

  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    await deleteDirectory(app, path);

    return res.json({ data: { deleted: true } });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/directories/rename', cors());
router.post('/apps/:id/directories/rename', cors(), async (req, res) => {
  const { id } = req.params;

  // TODO: validate and ensure path is not absolute
  const path = typeof req.query.path === 'string' ? req.query.path : '.';
  const name = req.query.name as string;

  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    const directory = await renameDirectory(app, path, name);

    return res.json({ data: directory });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/files', cors());
router.get('/apps/:id/files', cors(), async (req, res) => {
  const { id } = req.params;

  // TODO: validate and ensure path is not absolute
  const path = typeof req.query.path === 'string' ? req.query.path : '.';

  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    const file = await loadFile(app, path);

    return res.json({ data: file });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/files', cors());
router.post('/apps/:id/files', cors(), async (req, res) => {
  const { id } = req.params;

  // TODO: validate and ensure path is not absolute
  const { dirname, basename, source } = req.body;

  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    const file = await createFile(app, dirname, basename, source);

    return res.json({ data: file });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/files', cors());
router.delete('/apps/:id/files', cors(), async (req, res) => {
  const { id } = req.params;

  // TODO: validate and ensure path is not absolute
  const path = typeof req.query.path === 'string' ? req.query.path : '.';

  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    await deleteFile(app, path);

    return res.json({ data: { deleted: true } });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/files/rename', cors());
router.post('/apps/:id/files/rename', cors(), async (req, res) => {
  const { id } = req.params;

  // TODO: validate and ensure path is not absolute
  const path = typeof req.query.path === 'string' ? req.query.path : '.';
  const name = req.query.name as string;

  try {
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    const file = await renameFile(app, path, name);

    return res.json({ data: file });
  } catch (e) {
    return error500(res, e as Error);
  }
});

router.options('/apps/:id/export', cors());
router.post('/apps/:id/export', cors(), async (req, res) => {
  const { id } = req.params;
  const { name } = req.body;

  try {
    posthog.capture({ event: 'user exported app' });
    const app = await loadApp(id);

    if (!app) {
      return res.status(404).json({ error: 'App not found' });
    }

    const zipBuffer = await createZipFromApp(app);

    res.setHeader('Content-Type', 'application/zip');
    res.setHeader('Content-Disposition', `attachment; filename="${name}.zip"`);
    res.send(zipBuffer);
  } catch (e) {
    return error500(res, e as Error);
  }
});

app.use('/api', router);

export default app;

router.options('/apps/:id/history', cors());
router.get('/apps/:id/history', cors(), async (req, res) => {
  const { id } = req.params;
  const history = await getHistory(id);
  return res.json({ data: history });
});

router.post('/apps/:id/history', cors(), async (req, res) => {
  const { id } = req.params;
  const { messages } = req.body;
  await appendToHistory(id, messages);
  return res.json({ data: { success: true } });
});

router.options('/apps/:id/feedback', cors());
router.post('/apps/:id/feedback', cors(), async (req, res) => {
  const { id } = req.params;
  const { planId, feedback } = req.body as AppGenerationFeedbackType;

  if (process.env.SRCBOOK_DISABLE_ANALYTICS === 'true') {
    return res.status(403).json({ error: 'Analytics are disabled' });
  }
  posthog.capture({ event: 'user sent feedback', properties: { type: feedback.type } });

  try {
    const response = await fetch('https://hub.srcbook.com/api/app_generation_feedback', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        appId: id,
        planId,
        feedback,
      }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    return res.json(result);
  } catch (error) {
    console.error('Error sending feedback:', error);
    return res.status(500).json({ error: 'Failed to send feedback' });
  }
});

================
File: api/server/utils.mts
================
import { ServerResponse } from 'node:http';
import { StreamToIterable } from '@srcbook/shared';

/**
 * Pipe a `ReadableStream` through a Node `ServerResponse` object.
 */
export async function streamJsonResponse(
  stream: ReadableStream,
  response: ServerResponse,
  options?: {
    headers?: Record<string, string>;
    status?: number;
  },
) {
  options ??= {};

  response.writeHead(options.status || 200, {
    ...options.headers,
    'Content-Type': 'text/plain',
    'Transfer-Encoding': 'chunked',
  });

  for await (const chunk of StreamToIterable(stream)) {
    response.write(chunk);
  }

  response.end();
}

================
File: api/server/ws-client.mts
================
import { IncomingMessage } from 'node:http';
import z from 'zod';
import { type RawData, WebSocket } from 'ws';
import { WebSocketMessageSchema } from '@srcbook/shared';

type TopicPart = { dynamic: false; segment: string } | { dynamic: true; parameter: string };

export type MessageContextType<Key extends string = string> = {
  topic: string;
  event: string;
  params: Record<Key, string>;
};

type TopicMatch = Pick<MessageContextType, 'topic' | 'params'>;

export interface ConnectionContextType {
  reply: (topic: string, event: string, payload: Record<string, any>) => void;
}

type HandlerType = (
  payload: Record<string, any>,
  context: MessageContextType,
  conn: ConnectionContextType,
) => void;

/**
 * Channel is responsible for dispatching incoming messages for a given topic.
 *
 * Topics are strings that represent a channel for messages. Topics
 * can be broken into multiple parts separated by a colon. The following
 * are all examples of valid topics:
 *
 * - session
 * - session:123
 * - room:123:users:456:messages
 *
 * When we define a topic, we can use the `<variable>` syntax to indicate a
 * wildcard match. For example, the topic `room:<roomId>:messages` would match
 * `room:123:messages`, `room:456:messages`, etc.
 *
 * The wildcard syntax must be between two colons (or at the start/end of the string).
 * The text inside must be a valid JavaScript identifier.
 *
 * Examples:
 *
 *     const channel = new Channel("session")             // matches "session" only
 *     const channel = new Channel("session:<sessionId>") // matches "session:123", "session:456", etc.
 *
 */
export class Channel {
  // The topic pattern, e.g. "sessions:<sessionId>"
  readonly topic: string;

  // The parts of the topic string, e.g. "sessions" and "<sessionId>" for "sessions:<sessionId>"
  private readonly parts: TopicPart[];

  readonly events: Record<
    string,
    {
      schema: z.ZodTypeAny;
      handler: HandlerType;
    }
  > = {};

  onJoinCallback: HandlerType = () => {};

  constructor(topic: string) {
    this.topic = topic;
    this.parts = this.splitIntoParts(topic);
  }

  private splitIntoParts(topic: string) {
    const parts: TopicPart[] = [];

    for (const part of topic.split(':')) {
      const parameter = part.match(/^<([a-zA-Z_]+[a-zA-Z0-9_]*)>$/);

      if (parameter !== null) {
        parts.push({ dynamic: true, parameter: parameter[1] as string });
        continue;
      }

      if (/^[a-zA-Z0-9_]+$/.test(part)) {
        parts.push({ dynamic: false, segment: part });
        continue;
      }

      throw new Error(`Invalid channel topic: ${topic}`);
    }

    return parts;
  }

  match(topic: string): TopicMatch | null {
    const parts = topic.split(':');

    if (parts.length !== this.parts.length) {
      return null;
    }

    const match: TopicMatch = {
      topic: topic,
      params: {},
    };

    for (let i = 0, len = this.parts.length; i < len; i++) {
      const thisPart = this.parts[i] as TopicPart;

      if (thisPart.dynamic) {
        match.params[thisPart.parameter] = parts[i] as string;
        continue;
      } else if (thisPart.segment === parts[i]) {
        continue;
      }

      return null;
    }

    return match;
  }

  on<T extends z.ZodTypeAny>(
    event: string,
    schema: T,
    handler: (
      payload: z.infer<T>,
      context: MessageContextType,
      conn: ConnectionContextType,
    ) => void,
  ) {
    this.events[event] = { schema, handler };
    return this;
  }

  onJoin(callback: HandlerType) {
    this.onJoinCallback = callback;
    return this;
  }
}

type ConnectionType = {
  // Reply only to this connection, not to all connections.
  reply: (topic: string, event: string, payload: Record<string, any>) => void;
  socket: WebSocket;
  subscriptions: string[];
};

export default class WebSocketServer {
  private readonly channels: Channel[] = [];
  private connections: ConnectionType[] = [];

  constructor() {
    this.onConnection = this.onConnection.bind(this);
  }

  onConnection(socket: WebSocket, request: IncomingMessage) {
    const url = new URL(request.url!, `ws://${request.headers.host}`);

    const match = url.pathname.match(/^\/websocket\/?$/);
    if (match === null) {
      socket.close();
      return;
    }

    const connection = {
      socket,
      subscriptions: [],
      reply: (topic: string, event: string, payload: Record<string, any>) => {
        this.send(connection, topic, event, payload);
      },
    };

    this.connections.push(connection);

    socket.on('error', (error) => {
      // TODO: better error handling
      console.error(error);
    });

    socket.on('close', () => {
      this.removeConnection(socket);
    });

    socket.on('message', (message) => {
      this.handleIncomingMessage(connection, message);
    });
  }

  channel(topic: string) {
    const channel = new Channel(topic);
    this.channels.push(channel);
    return channel;
  }

  broadcast(topic: string, event: string, payload: Record<string, any>) {
    for (const conn of this.connections) {
      if (conn.subscriptions.includes(topic)) {
        this.send(conn, topic, event, payload);
      }
    }
  }

  private handleIncomingMessage(conn: ConnectionType, message: RawData) {
    const parsed = JSON.parse(message.toString('utf8'));
    const [topic, event, payload] = WebSocketMessageSchema.parse(parsed);

    const channelMatch = this.findChannelMatch(topic);

    if (channelMatch === null) {
      console.warn(`Server received unknown topic '${topic}'`);
      return;
    }

    const { channel, match } = channelMatch;

    if (event === 'subscribe') {
      conn.subscriptions.push(topic);
      conn.reply(topic, 'subscribed', { id: payload.id });
      channel.onJoinCallback(
        payload,
        { topic: match.topic, event: event, params: match.params },
        conn,
      );
      return;
    }

    if (event === 'unsubscribe') {
      conn.subscriptions = conn.subscriptions.filter((t) => t !== topic);
      return;
    }

    const registeredEvent = channel.events[event];

    if (registeredEvent === undefined) {
      console.warn(`Server received unknown event '${event}' for topic '${topic}'`);
      return;
    }

    const { schema, handler } = registeredEvent;

    const result = schema.safeParse(payload);

    if (!result.success) {
      console.warn(
        `Server received invalid payload for event '${event}' and topic '${topic}':\n\n${JSON.stringify(payload)}\n\n`,
      );
      return;
    }

    handler(result.data, { topic: match.topic, event: event, params: match.params }, conn);
  }

  private findChannelMatch(topic: string): { channel: Channel; match: TopicMatch } | null {
    for (const channel of this.channels) {
      const match = channel.match(topic);

      if (match !== null) {
        return { channel, match };
      }
    }

    return null;
  }

  private removeConnection(socket: WebSocket) {
    this.connections = this.connections.filter((conn) => {
      return conn.socket !== socket;
    });
  }

  private send(conn: ConnectionType, topic: string, event: string, payload: Record<string, any>) {
    conn.socket.send(JSON.stringify([topic, event, payload]));
  }
}

================
File: api/server/ws.mts
================
import { ChildProcess } from 'node:child_process';
import { posthog } from '../posthog-client.mjs';
import { generateCellEdit, fixDiagnostics } from '../ai/generate.mjs';
import {
  findSession,
  findCell,
  replaceCell,
  updateSession,
  readPackageJsonContentsFromDisk,
  updateCell,
  removeCell,
  updateCodeCellFilename,
  addCell,
  formatAndUpdateCodeCell,
} from '../session.mjs';
import { getSecretsAssociatedWithSession } from '../config.mjs';
import type { SessionType } from '../types.mjs';
import { node, npmInstall, tsx } from '../exec.mjs';
import { shouldNpmInstall, missingUndeclaredDeps } from '../deps.mjs';
import processes from '../processes.mjs';
import type {
  CodeCellType,
  PackageJsonCellType,
  CellExecPayloadType,
  DepsInstallPayloadType,
  DepsValidatePayloadType,
  CellStopPayloadType,
  CellUpdatePayloadType,
  CellFormatPayloadType,
  TsServerStartPayloadType,
  TsServerStopPayloadType,
  CellDeletePayloadType,
  CellRenamePayloadType,
  CellErrorType,
  CellCreatePayloadType,
  AiGenerateCellPayloadType,
  TsConfigUpdatePayloadType,
  AiFixDiagnosticsPayloadType,
  TsServerQuickInfoRequestPayloadType,
  TsServerDefinitionLocationRequestPayloadType,
} from '@srcbook/shared';
import {
  CellUpdatePayloadSchema,
  CellRenamePayloadSchema,
  CellDeletePayloadSchema,
  CellFormatPayloadSchema,
  CellExecPayloadSchema,
  CellStopPayloadSchema,
  AiGenerateCellPayloadSchema,
  AiFixDiagnosticsPayloadSchema,
  DepsInstallPayloadSchema,
  DepsValidatePayloadSchema,
  TsServerStartPayloadSchema,
  TsServerStopPayloadSchema,
  CellCreatePayloadSchema,
  TsConfigUpdatePayloadSchema,
  TsServerQuickInfoRequestPayloadSchema,
  TsServerDefinitionLocationRequestPayloadSchema,
} from '@srcbook/shared';
import tsservers from '../tsservers.mjs';
import { TsServer } from '../tsserver/tsserver.mjs';
import WebSocketServer, { MessageContextType } from './ws-client.mjs';
import { filenameFromPath, pathToCodeFile } from '../srcbook/path.mjs';
import { normalizeDiagnostic } from '../tsserver/utils.mjs';
import { removeCodeCellFromDisk } from '../srcbook/index.mjs';
import { register as registerAppChannel } from './channels/app.mjs';

type SessionsContextType = MessageContextType<'sessionId'>;

const wss = new WebSocketServer();

function addRunningProcess(
  session: SessionType,
  cell: CodeCellType | PackageJsonCellType,
  process: ChildProcess,
) {
  // If the process was not successfully started, inform the client the cell is 'idle' again.
  //
  // TODO:
  //
  //     1. If process couldn't start due to an error, add error handling so the client knows
  //     2. Ensure that there's no way the process could have started and successfully exited before we get here, causing the client to think it didn't run but it did.
  //
  if (!process.pid || process.killed) {
    cell.status = 'idle';
    wss.broadcast(`session:${session.id}`, 'cell:updated', { cell });
  } else {
    processes.add(session.id, cell.id, process);
  }
}

async function nudgeMissingDeps(wss: WebSocketServer, session: SessionType) {
  try {
    if (await shouldNpmInstall(session.dir)) {
      wss.broadcast(`session:${session.id}`, 'deps:validate:response', {});
    }
  } catch (e) {
    // Don't crash the server on dependency validation, but log the error
    console.error(`Error validating dependencies for session ${session.id}: ${e}`);
  }

  try {
    const missingDeps = await missingUndeclaredDeps(session.dir);

    if (missingDeps.length > 0) {
      wss.broadcast(`session:${session.id}`, 'deps:validate:response', { packages: missingDeps });
    }
  } catch (e) {
    // Don't crash the server on dependency validation, but log the error
    console.error(`Error running depcheck for session ${session.id}: ${e}`);
  }
}

async function cellExec(payload: CellExecPayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);
  const cell = findCell(session, payload.cellId);
  if (!cell || cell.type !== 'code') {
    console.error(`Cannot execute cell with id ${payload.cellId}; cell not found.`);
    return;
  }

  // Consider removing sessionId and cellId if cardinality increases costs too much
  posthog.capture({
    event: 'user ran a cell',
    properties: {
      language: cell.language,
      sessionId: session.id,
      cellId: cell.id,
    },
  });

  nudgeMissingDeps(wss, session);

  const secrets = await getSecretsAssociatedWithSession(session.id);

  cell.status = 'running';
  wss.broadcast(`session:${session.id}`, 'cell:updated', { cell });

  switch (cell.language) {
    case 'javascript':
      jsExec({ session, cell, secrets });
      break;
    case 'typescript':
      tsxExec({ session, cell, secrets });
      break;
  }
}

type ExecRequestType = {
  session: SessionType;
  cell: CodeCellType;
  secrets: Record<string, string>;
};

async function jsExec({ session, cell, secrets }: ExecRequestType) {
  addRunningProcess(
    session,
    cell,
    node({
      cwd: session.dir,
      env: secrets,
      entry: pathToCodeFile(session.dir, cell.filename),
      stdout(data) {
        wss.broadcast(`session:${session.id}`, 'cell:output', {
          cellId: cell.id,
          output: { type: 'stdout', data: data.toString('utf8') },
        });
      },
      stderr(data) {
        wss.broadcast(`session:${session.id}`, 'cell:output', {
          cellId: cell.id,
          output: { type: 'stderr', data: data.toString('utf8') },
        });
      },
      onExit() {
        // Reload cell to get most recent version which may have been updated since
        // in the time between initially running this cell and when running finishes.
        //
        // TODO: Real state management pls.
        //
        const mostRecentCell = session.cells.find((c) => c.id === cell.id) as CodeCellType;
        mostRecentCell.status = 'idle';
        wss.broadcast(`session:${session.id}`, 'cell:updated', { cell: mostRecentCell });
      },
    }),
  );
}

async function tsxExec({ session, cell, secrets }: ExecRequestType) {
  addRunningProcess(
    session,
    cell,
    tsx({
      cwd: session.dir,
      env: secrets,
      entry: pathToCodeFile(session.dir, cell.filename),
      stdout(data) {
        wss.broadcast(`session:${session.id}`, 'cell:output', {
          cellId: cell.id,
          output: { type: 'stdout', data: data.toString('utf8') },
        });
      },
      stderr(data) {
        wss.broadcast(`session:${session.id}`, 'cell:output', {
          cellId: cell.id,
          output: { type: 'stderr', data: data.toString('utf8') },
        });
      },
      onExit() {
        // Reload cell to get most recent version which may have been updated since
        // in the time between initially running this cell and when running finishes.
        //
        // TODO: Real state management pls.
        //
        const mostRecentCell = session.cells.find((c) => c.id === cell.id) as CodeCellType;
        mostRecentCell.status = 'idle';
        wss.broadcast(`session:${session.id}`, 'cell:updated', { cell: mostRecentCell });
      },
    }),
  );
}

async function depsInstall(payload: DepsInstallPayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);
  const cell = session.cells.find(
    (cell) => cell.type === 'package.json',
  ) as PackageJsonCellType | void;

  if (!cell) {
    console.error(`Cannot install deps; package.json cell not found`);
    return;
  }

  cell.status = 'running';
  wss.broadcast(`session:${session.id}`, 'cell:updated', { cell });

  posthog.capture({
    event: 'user installed dependencies',
    properties: {
      sessionId: session.id,
      packages: payload.packages,
    },
  });

  addRunningProcess(
    session,
    cell,
    npmInstall({
      cwd: session.dir,
      packages: payload.packages,
      stdout(data) {
        wss.broadcast(`session:${session.id}`, 'cell:output', {
          cellId: cell.id,
          output: { type: 'stdout', data: data.toString('utf8') },
        });
      },
      stderr(data) {
        wss.broadcast(`session:${session.id}`, 'cell:output', {
          cellId: cell.id,
          output: { type: 'stderr', data: data.toString('utf8') },
        });
      },
      async onExit(exitCode) {
        const updatedJsonSource = await readPackageJsonContentsFromDisk(session);

        const updatedCell: PackageJsonCellType = {
          ...cell,
          source: updatedJsonSource,
          status: exitCode === 0 ? 'idle' : 'failed',
        };

        const updatedSession = await updateSession(
          session,
          { cells: replaceCell(session, updatedCell) },
          false,
        );

        wss.broadcast(`session:${updatedSession.id}`, 'cell:updated', { cell: updatedCell });

        if (updatedSession.language === 'typescript') {
          const mustCreateTsServer = !tsservers.has(updatedSession.id);

          // Make sure to handle the following case here:
          //
          // 1. User creates a new typescript Srcbook
          // 3. There is no tsserver running because it relies on the typescript package in the Srcbook's node modules, which are not yet installed.
          // 4. Now that we just installed the dependencies, we need to create a new tsserver instance.
          const tsserver = mustCreateTsServer
            ? createTsServer(updatedSession)
            : tsservers.get(updatedSession.id);

          // Update all code cell diagnostics now that we have new packages available.
          requestAllDiagnostics(tsserver, updatedSession);
        }
      },
    }),
  );
}

async function depsValidate(_payload: DepsValidatePayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);
  nudgeMissingDeps(wss, session);
}

async function cellStop(payload: CellStopPayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);
  const cell = findCell(session, payload.cellId);

  if (!cell || cell.type !== 'code') {
    return;
  }

  posthog.capture({
    event: 'user stopped cell execution',
    properties: {
      sessionId: session.id,
      cellId: cell.id,
      language: cell.language,
    },
  });

  try {
    const killed = processes.kill(session.id, cell.id);
    if (!killed) {
      console.warn(
        `Process for session ${session.id} and cell ${cell.id} could not be killed. It may have already finished executing.`,
      );
    }
  } catch (e) {
    const error = e as unknown as Error;
    console.error(
      `Error occurred while trying to kill process for session ${session.id} and cell ${cell.id}:`,
      error instanceof Error ? error.message : String(error),
    );
  }
}

async function cellCreate(payload: CellCreatePayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);

  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }

  const { index, cell } = payload;

  // TODO: handle potential errors
  await addCell(session, cell, index);

  if (session.language === 'typescript' && cell.type === 'code' && tsservers.has(session.id)) {
    const tsserver = tsservers.get(session.id);

    tsserver.open({
      file: pathToCodeFile(session.dir, cell.filename),
      fileContent: cell.source,
    });

    requestAllDiagnostics(tsserver, session);
  }
}

function sendCellUpdateError(session: SessionType, cellId: string, errors: CellErrorType[]) {
  wss.broadcast(`session:${session.id}`, 'cell:error', {
    sessionId: session.id,
    cellId: cellId,
    errors: errors,
  });

  // Revert the client's optimistic updates with most recent server cell state
  wss.broadcast(`session:${session.id}`, 'cell:updated', {
    cell: findCell(session, cellId),
  });
}

function reopenFileInTsServer(
  tsserver: TsServer,
  session: SessionType,
  file: { closeFilename: string; openFilename: string; source: string },
) {
  // These two are usually the same unless a file is being renamed.
  const closeFilePath = pathToCodeFile(session.dir, file.closeFilename);
  const openFilePath = pathToCodeFile(session.dir, file.openFilename);

  // To update a file in tsserver, close and reopen it. I assume performance of
  // this implementation is worse than calculating diffs and using `change` command
  // (although maybe not since this is not actually reading or writing to disk).
  // However, that requires calculating diffs which is more complex and may also
  // have performance implications, so sticking with the simple approach for now.
  tsserver.close({ file: closeFilePath });
  tsserver.open({ file: openFilePath, fileContent: file.source });
}

async function cellGenerate(payload: AiGenerateCellPayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);
  const cell = session.cells.find((cell) => cell.id === payload.cellId) as CodeCellType;

  posthog.capture({
    event: 'user edited a cell with AI',
    properties: {
      language: cell.language,
      prompt: payload.prompt,
    },
  });

  const result = await generateCellEdit(payload.prompt, session, cell);

  wss.broadcast(`session:${session.id}`, 'ai:generated', {
    cellId: payload.cellId,
    output: result,
  });
}

async function cellFixDiagnostics(
  payload: AiFixDiagnosticsPayloadType,
  context: SessionsContextType,
) {
  const session = await findSession(context.params.sessionId);
  const cell = findCell(session, payload.cellId) as CodeCellType;

  const result = await fixDiagnostics(session, cell, payload.diagnostics);

  wss.broadcast(`session:${session.id}`, 'ai:generated', {
    cellId: payload.cellId,
    output: result,
  });
}

async function cellFormat(payload: CellFormatPayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);
  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }
  const cellBeforeUpdate = findCell(session, payload.cellId);

  if (!cellBeforeUpdate || cellBeforeUpdate.type !== 'code') {
    throw new Error(
      `No cell exists or not a code cell for session '${context.params.sessionId}' and cell '${payload.cellId}'`,
    );
  }
  const result = await formatAndUpdateCodeCell(session, cellBeforeUpdate);
  if (!result.success) {
    wss.broadcast(`session:${session.id}`, 'cell:output', {
      cellId: payload.cellId,
      output: { type: 'stderr', data: result.errors },
    });
    sendCellUpdateError(session, payload.cellId, [
      {
        message:
          'An error occurred while formatting the code. Please check stderr for more details.',
        attribute: 'formatting',
      },
    ]);
  } else {
    const cell = result.cell as CodeCellType;

    wss.broadcast(`session:${session.id}`, 'cell:formatted', {
      cellId: payload.cellId,
      cell,
    });

    refreshCodeCellDiagnostics(session, cell);
  }
}

async function cellUpdate(payload: CellUpdatePayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);

  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }

  const cellBeforeUpdate = findCell(session, payload.cellId);

  if (!cellBeforeUpdate) {
    throw new Error(
      `No cell exists for session '${context.params.sessionId}' and cell '${payload.cellId}'`,
    );
  }
  const result = await updateCell(session, cellBeforeUpdate, payload.updates);

  if (!result.success) {
    return sendCellUpdateError(session, payload.cellId, result.errors);
  }

  const cell = result.cell as CodeCellType;

  refreshCodeCellDiagnostics(session, cell);
}

async function cellRename(payload: CellRenamePayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);

  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }

  const cellBeforeUpdate = findCell(session, payload.cellId);

  if (!cellBeforeUpdate) {
    throw new Error(
      `No cell exists for session '${context.params.sessionId}' and cell '${payload.cellId}'`,
    );
  }

  if (cellBeforeUpdate.type !== 'code') {
    throw new Error(
      `Cannot rename cell of type '${cellBeforeUpdate.type}'. Only code cells can be renamed.`,
    );
  }

  posthog.capture({
    event: 'user renamed cell',
    properties: {
      sessionId: session.id,
      cellId: cellBeforeUpdate.id,
    },
  });

  const result = await updateCodeCellFilename(session, cellBeforeUpdate, payload.filename);

  if (!result.success) {
    return sendCellUpdateError(session, payload.cellId, result.errors);
  }

  if (
    session.language === 'typescript' &&
    cellBeforeUpdate.type === 'code' &&
    tsservers.has(session.id)
  ) {
    const cellAfterUpdate = result.cell as CodeCellType;
    const tsserver = tsservers.get(session.id);

    // This function is specifically for renaming code cells. Thus,
    // the filenames before and after the update should be different.
    reopenFileInTsServer(tsserver, session, {
      closeFilename: cellBeforeUpdate.filename,
      openFilename: cellAfterUpdate.filename,
      source: cellAfterUpdate.source,
    });

    // Tsserver can get into a bad state if we don't reload the project after renaming a file.
    // This consistently happens under the following condition:
    //
    // 1. Rename a `a.ts` that is imported by `b.ts` to `c.ts`
    // 2. Semantic diagnostics report an error in `b.ts` that `a.ts` doesn't exist
    // 3. Great, all works so far.
    // 4. Rename `c.ts` back to `a.ts`.
    // 5. Semantic diagnostics still report an error in `b.ts` that `a.ts` doesn't exist.
    // 6. This is wrong, `a.ts` does exist.
    //
    // If we reload the project, this issue resolves itself.
    //
    // NOTE: reloading the project sends diagnostic events without calling `geterr`.
    // However, it seems to take a while for the diagnostics to be sent, so we still
    // request it below.
    //
    tsserver.reloadProjects();

    requestAllDiagnostics(tsserver, session);
  }
}

async function cellDelete(payload: CellDeletePayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);

  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }

  const cell = findCell(session, payload.cellId);

  if (!cell) {
    throw new Error(
      `No cell exists for session '${context.params.sessionId}' and cell '${payload.cellId}'`,
    );
  }

  posthog.capture({
    event: 'user deleted cell',
    properties: { cellType: cell.type },
  });

  if (cell.type !== 'markdown' && cell.type !== 'code') {
    throw new Error(`Cannot delete cell of type '${cell.type}'`);
  }

  const updatedCells = removeCell(session, cell.id);

  const updatedSession = await updateSession(session, { cells: updatedCells });

  if (cell.type === 'code') {
    removeCodeCellFromDisk(updatedSession.dir, cell.filename);

    if (updatedSession.language === 'typescript' && tsservers.has(updatedSession.id)) {
      const file = pathToCodeFile(updatedSession.dir, cell.filename);
      const tsserver = tsservers.get(updatedSession.id);
      tsserver.close({ file });
      requestAllDiagnostics(tsserver, updatedSession);
    }
  }
}

/**
 * Request async diagnostics for all files in the project.
 */
function requestAllDiagnostics(tsserver: TsServer, session: SessionType, delay = 0) {
  const codeCells = session.cells.filter((cell) => cell.type === 'code') as CodeCellType[];
  const files = codeCells.map((cell) => pathToCodeFile(session.dir, cell.filename));
  tsserver.geterr({ files, delay });
}

function createTsServer(session: SessionType) {
  const tsserver = tsservers.create(session.id, { cwd: session.dir });

  const sessionId = session.id;

  tsserver.onSemanticDiag(async (event) => {
    const eventBody = event.body;
    if (!eventBody) return;

    // Get most recent session state
    let session;
    try {
      session = await findSession(sessionId);
    } catch (e) {
      const error = e as unknown as Error;
      console.error(error);
      return;
    }

    const filename = filenameFromPath(eventBody.file);
    const cells = session.cells.filter((cell) => cell.type === 'code') as CodeCellType[];
    const cell = cells.find((c) => c.filename === filename);

    if (!cell) {
      return;
    }

    wss.broadcast(`session:${session.id}`, 'tsserver:cell:diagnostics', {
      cellId: cell.id,
      diagnostics: eventBody.diagnostics.map(normalizeDiagnostic),
    });
  });

  tsserver.onSuggestionDiag(async (event) => {
    const eventBody = event.body;
    if (!eventBody) return;

    // Get most recent session state
    let session;
    try {
      session = await findSession(sessionId);
    } catch (e) {
      const error = e as unknown as Error;
      console.error(error);
      return;
    }

    const filename = filenameFromPath(eventBody.file);
    const cells = session.cells.filter((cell) => cell.type === 'code') as CodeCellType[];
    const cell = cells.find((c) => c.filename === filename);

    if (!cell) {
      return;
    }

    wss.broadcast(`session:${session.id}`, 'tsserver:cell:suggestions', {
      cellId: cell.id,
      diagnostics: eventBody.diagnostics.map(normalizeDiagnostic),
    });
  });

  // Open all code cells in tsserver
  for (const cell of session.cells) {
    if (cell.type === 'code') {
      tsserver.open({
        file: pathToCodeFile(session.dir, cell.filename),
        fileContent: cell.source,
      });
    }
  }

  return tsserver;
}

async function tsserverStart(_payload: TsServerStartPayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);

  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }

  if (session.language !== 'typescript') {
    throw new Error(`tsserver can only be used with TypeScript Srcbooks.`);
  }

  requestAllDiagnostics(
    tsservers.has(session.id) ? tsservers.get(session.id) : createTsServer(session),
    session,
  );
}

async function tsserverStop(_payload: TsServerStopPayloadType, context: SessionsContextType) {
  tsservers.shutdown(context.params.sessionId);
}

async function tsconfigUpdate(payload: TsConfigUpdatePayloadType, context: SessionsContextType) {
  const session = await findSession(context.params.sessionId);

  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }

  posthog.capture({ event: 'user updated tsconfig' });

  const updatedSession = await updateSession(session, { 'tsconfig.json': payload.source });

  if (tsservers.has(updatedSession.id)) {
    const tsserver = tsservers.get(updatedSession.id);
    tsserver.reloadProjects();
    requestAllDiagnostics(tsserver, updatedSession);
  }

  wss.broadcast(`session:${updatedSession.id}`, 'tsconfig.json:updated', {
    source: payload.source,
  });
}

async function tsserverQuickInfo(
  payload: TsServerQuickInfoRequestPayloadType,
  context: SessionsContextType,
) {
  const session = await findSession(context.params.sessionId);

  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }

  if (session.language !== 'typescript') {
    throw new Error(`tsserver can only be used with TypeScript Srcbooks.`);
  }

  const tsserver = tsservers.has(session.id) ? tsservers.get(session.id) : createTsServer(session);

  const cell = session.cells.find((c) => payload.cellId == c.id);

  if (!cell || cell.type !== 'code') {
    throw new Error(`No code cell found for cellId '${payload.cellId}'`);
  }

  const filename = cell.filename;

  const tsserverResponse = await tsserver.quickinfo({
    file: pathToCodeFile(session.dir, filename),
    line: payload.request.location.line,
    offset: payload.request.location.offset,
  });

  const body = tsserverResponse.body;
  if (!body) {
    return null;
  }

  wss.broadcast(`session:${session.id}`, 'tsserver:cell:quickinfo:response', {
    response: {
      ...body,
    },
  });
}

async function getCompletions(
  payload: TsServerDefinitionLocationRequestPayloadType,
  context: SessionsContextType,
) {
  const session = await findSession(context.params.sessionId);

  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }

  if (session.language !== 'typescript') {
    throw new Error(`tsserver can only be used with TypeScript Srcbooks.`);
  }

  const tsserver = tsservers.has(session.id) ? tsservers.get(session.id) : createTsServer(session);

  const cell = session.cells.find((c) => payload.cellId == c.id);

  if (!cell || cell.type !== 'code') {
    throw new Error(`No code cell found for cellId '${payload.cellId}'`);
  }

  const filename = cell.filename;

  const tsserverResponse = await tsserver.getCompletions({
    file: pathToCodeFile(session.dir, filename),
    line: payload.request.location.line,
    offset: payload.request.location.offset,
  });

  const entries = tsserverResponse.body;

  wss.broadcast(`session:${session.id}`, 'tsserver:cell:completions:response', {
    response: entries ? { entries } : null,
  });
}

async function getDefinitionLocation(
  payload: TsServerDefinitionLocationRequestPayloadType,
  context: SessionsContextType,
) {
  const session = await findSession(context.params.sessionId);

  if (!session) {
    throw new Error(`No session exists for session '${context.params.sessionId}'`);
  }

  if (session.language !== 'typescript') {
    throw new Error(`tsserver can only be used with TypeScript Srcbooks.`);
  }

  const tsserver = tsservers.has(session.id) ? tsservers.get(session.id) : createTsServer(session);

  const cell = session.cells.find((c) => payload.cellId == c.id);

  if (!cell || cell.type !== 'code') {
    throw new Error(`No code cell found for cellId '${payload.cellId}'`);
  }

  const filename = cell.filename;

  const tsserverResponse = await tsserver.getDefinitionLocation({
    file: pathToCodeFile(session.dir, filename),
    line: payload.request.location.line,
    offset: payload.request.location.offset,
  });

  const body = tsserverResponse.body;
  if (!body) {
    return null;
  }

  const res = {
    response: body[0] ? body[0] : null,
  };

  wss.broadcast(`session:${session.id}`, 'tsserver:cell:definition_location:response', res);
}

function refreshCodeCellDiagnostics(session: SessionType, cell: CodeCellType) {
  if (session.language === 'typescript' && cell.type === 'code' && tsservers.has(session.id)) {
    const tsserver = tsservers.get(session.id);

    // This isn't intended for renaming, so the filenames
    // and their resulting paths are expected to be the same
    reopenFileInTsServer(tsserver, session, {
      openFilename: cell.filename,
      closeFilename: cell.filename,
      source: cell.source,
    });

    requestAllDiagnostics(tsserver, session);
  }
}

wss
  .channel('session:<sessionId>')
  .on('cell:exec', CellExecPayloadSchema, cellExec)
  .on('cell:stop', CellStopPayloadSchema, cellStop)
  .on('cell:create', CellCreatePayloadSchema, cellCreate)
  .on('cell:update', CellUpdatePayloadSchema, cellUpdate)
  .on('cell:rename', CellRenamePayloadSchema, cellRename)
  .on('cell:delete', CellDeletePayloadSchema, cellDelete)
  .on('cell:format', CellFormatPayloadSchema, cellFormat)
  .on('ai:generate', AiGenerateCellPayloadSchema, cellGenerate)
  .on('ai:fix_diagnostics', AiFixDiagnosticsPayloadSchema, cellFixDiagnostics)
  .on('deps:install', DepsInstallPayloadSchema, depsInstall)
  .on('deps:validate', DepsValidatePayloadSchema, depsValidate)
  .on('tsserver:start', TsServerStartPayloadSchema, tsserverStart)
  .on('tsserver:stop', TsServerStopPayloadSchema, tsserverStop)
  .on('tsconfig.json:update', TsConfigUpdatePayloadSchema, tsconfigUpdate)
  .on('tsserver:cell:quickinfo:request', TsServerQuickInfoRequestPayloadSchema, tsserverQuickInfo)
  .on(
    'tsserver:cell:definition_location:request',
    TsServerDefinitionLocationRequestPayloadSchema,
    getDefinitionLocation,
  )
  .on(
    'tsserver:cell:completions:request',
    TsServerDefinitionLocationRequestPayloadSchema,
    getCompletions,
  );

registerAppChannel(wss);

export default wss;

================
File: api/srcbook/examples/getting-started.src.md
================
<!-- srcbook:{"language":"javascript"} -->

# Getting started

###### package.json

```json
{
  "type": "module",
  "dependencies": {
    "random-words": "^2.0.1"
  }
}

```

## What are Srcbooks?

Srcbooks are an interactive way of programming in JavaScript or TypeScript. They are similar to other notebooks, but unique in their own ways.
They are based on the [node](https://nodejs.org/en) runtime.

A Srcbook is composed of **cells**. Currently, there are 2 types of cells:
 1. **markdown cell**: what you're reading is a markdown cell. It allows you to easily express ideas with rich markup, rather than code comments, an idea called [literate programming](https://en.wikipedia.org/wiki/Literate_programming).
 2. **code cell**: think of these as JS or TS files. You can run them or export objects to be used in other cells.

Srcbooks also hold dependencies in a package.json, and if they are TypeScript Srcbooks, they have a tsconfig.json. You can view these in the ⚙️ Settings menu on the left.

###### simple-code.js

```javascript
// You can run me by clicking 'Run' or using the shortcut `cmd` + `enter`.
console.log("Hello, Srcbook!")
```

## Using npm libraries

You can add any external node.js-compatible dependency from [npm](https://www.npmjs.com/). Let's look at an example below by importing the `random-words` library.

You'll need to make sure you install dependencies, which you can do by clicking the ⚙️ settings in the left menu.

You can install dependencies (think of this as running `npm install` for your Srcbook), by clicking the toast when prompted, or going in the settings and clicking "`npm install`".

###### generate-random-word.js

```javascript
import { generate } from 'random-words';

for (let i = 0; i < 4; i++) {
  console.log(`Word ${i + 1}: ${generate()}`);
}
```

## Importing other cells

Behind the scenes, cells are ECMAScript 6 modules. Therefore you can export variables from one cell and import them in another:

###### star-wars.js

```javascript
export const vaderLine = (name) => `I am your father, ${name}`
```

###### star-liner.js

```javascript
import { vaderLine } from './star-wars.js';

console.log(vaderLine("Luke"));
console.log(vaderLine("Leia"));
```

## Using secrets

For security purposes, you should avoid pasting secrets directly into Srcbook cells. The mechanism you should leverage is [secrets](/secrets). These are stored securely and are accessed at runtime as environment variables through `process.env`.

Secrets can then be imported in Srcbooks using `process.env.SECRET_NAME`. Try it out by setting the SECRET_API_KEY and getting it to print to the console below:

###### secret-message.js

```javascript
const secret = process.env.SECRET_API_KEY

console.log(secret ? `The secret is: ${secret}` : 'SECRET_API_KEY not set')
```

## Using AI

Srcbook has lots of productive AI features. We designed the AI to be a copilot, leaving you in the driver's seat while allowing you to iterate on code and markdown using natural language if you want to.

First, you'll have to configure a provider in the [global settings](./settings). You can select openAI or anthropic, and pass an API_KEY, or configure a local model through software like [Ollama](https://ollama.com/).

Once set up, you can:
 - generate entire Srcbooks from a prompt, like "I want to learn about CRDTs and Y.js" from the home page
 - create new cells using AI by giving it a description of what you want
 - edit a cell by prompting what changes you want. The AI will present you with a diff that you can approve or reject.

You can see the AI features in action in [this video](https://www.loom.com/share/a212e1fd49a04c548c09125a96a1836f?sid=7bc506ca-fdd1-44b9-b51e-5006ae4248f4).

Try it out by setting up an AI provider, and then click on the Sparkles icon to edit the cell below with AI and ask it to "fix the bug".

###### fix-me.js

```javascript
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 2);
}

console.assert(factorial(5) === 120, 'Factorial of 5 should be 120');
```

## Exporting and sharing Srcbooks

Srcbooks are meant to be collaborative. They export to a Markdown file format with the `.src.md` extension, which can be rendered in any editor or UI that supports Markdown.

You can export Srcbooks by clicking the `Export` link in the top level menu on the left.

You can also import `.src.md` files directly in this application if you want to run, modify, or re-export them.

## The hub & feedback

We have created a [hub](./https://hub.srcbook.com) with some example Srcbooks that you can import really easily with one command. 

You can for example import a Srcbook teaching you how to programmatically take screenshots of websites using pupeteer by running:
```
npx srcbook@latest import web-scraping-with-puppeteer
```

If you want to add your Srcbook to the hub or give us feedback, just email us at feedback@srcbook.com, we love hearing from our users!

Enjoy Srcbook, time to build 🏗️!

================
File: api/srcbook/examples/langgraph-web-agent.src.md
================
<!-- srcbook:{"language":"typescript"} -->

# LangGraph web agent

###### package.json

```json
{
  "type": "module",
  "dependencies": {
    "@langchain/community": "^0.2.20",
    "@langchain/core": "^0.2.17",
    "@langchain/langgraph": "^0.0.29",
    "@langchain/openai": "^0.2.4",
    "better-sqlite3": "latest",
    "@types/node": "latest",
    "tsx": "latest",
    "typescript": "latest",
    "zod": "^3.23.8"
  }
}
```

## LangGraph tutorial

Based on [this tutorial](https://langchain-ai.github.io/langgraphjs/reference/).

We're going to build an agent that can search the web using the [Tavily Search API](https://tavily.com/).

First, let's ensure we've setup the right env variables:

###### env-check.ts

```typescript
import assert from 'node:assert';

assert.ok(process.env.OPENAI_API_KEY, 'You need to set OPENAI_API_KEY');
assert.ok(process.env.TAVILY_API_KEY, 'You need to set TAVILY_API_KEY');
```

## Define the agent

Now, let's define the Agent with LangGraph.js

###### agent.ts

```typescript
import { HumanMessage, AIMessage } from '@langchain/core/messages';
import { DynamicStructuredTool } from "@langchain/core/tools";
import { z } from "zod";
import { TavilySearchResults } from '@langchain/community/tools/tavily_search';
import { ChatOpenAI } from '@langchain/openai';
import { END, START, StateGraph, StateGraphArgs } from '@langchain/langgraph';
import { SqliteSaver } from '@langchain/langgraph/checkpoint/sqlite';
import { ToolNode } from '@langchain/langgraph/prebuilt';

// Define the state interface
interface AgentState {
  messages: HumanMessage[];
}

// We'll use a local sqlite DB for memory
export const DB_NAME = 'langgraph_memory.db';

// Define the graph state
const graphState: StateGraphArgs<AgentState>['channels'] = {
  messages: {
    value: (x: HumanMessage[], y: HumanMessage[]) => x.concat(y),
    default: () => [],
  },
};

// Define the tools for the agent to use
const tools = [new TavilySearchResults({ maxResults: 1 })];
const toolNode = new ToolNode<AgentState>(tools);

const model = new ChatOpenAI({ model: 'gpt-4o', temperature: 0 }).bindTools(tools);

// Define the function that determines whether to continue or not
function shouldContinue(state: AgentState): 'tools' | typeof END {
  const messages = state.messages;
  const lastMessage = messages[messages.length - 1] as AIMessage;

  // If the LLM makes a tool call, then we route to the "tools" node
  if (lastMessage.tool_calls?.length) {
    return 'tools';
  }
  // Otherwise, we stop (reply to the user)
  return END;
}

// Define the function that calls the model
async function callModel(state: AgentState) {
  const messages = state.messages;
  const response = await model.invoke(messages);

  // We return a list, because this will get added to the existing list
  return { messages: [response] };
}

// Define a new graph
const workflow = new StateGraph<AgentState>({ channels: graphState })
  .addNode('agent', callModel)
  .addNode('tools', toolNode)
  .addEdge(START, 'agent')
  .addConditionalEdges('agent', shouldContinue)
  .addEdge('tools', 'agent');

// Initialize memory to persist state between graph runs
export const memory = SqliteSaver.fromConnString(DB_NAME);

// Finally, we compile it!
// This compiles it into a LangChain Runnable.
// Note that we're (optionally) passing the memory when compiling the graph
export const app = workflow.compile({ checkpointer: memory });
```

Now that we've built our app, let's invoke it to first get the weather in SF:

###### sf-weather.ts

```typescript
import { app } from './agent.ts';
import { HumanMessage } from '@langchain/core/messages';

// Reference a thread
const thread = { configurable: { thread_id: '42' } };

// Use the Runnable
const finalState = await app.invoke(
  { messages: [new HumanMessage('what is the weather in sf')] },
  thread,
);

console.log(finalState.messages[finalState.messages.length - 1].content);
```

Now when we pass the same `thread_id`, in this case `"42"`, the conversation context is retained via the saved state that we've set in a local sqliteDB (i.e. stored list of messages).

Also, in this next example, we demonstrate streaming output.

###### ny-weather.ts

```typescript
import { app } from './agent.ts';
import { HumanMessage } from '@langchain/core/messages';

const nextState = await app.invoke(
  { messages: [new HumanMessage('what about ny')] },
  { configurable: { thread_id: '42' } },
);

console.log(nextState.messages[nextState.messages.length - 1].content);
```

## Clear memory

The memory was saved in the sqlite db `./langGraph.db`. If you want to clear it, run the following cell

###### clear.ts

```typescript
import { DB_NAME } from './agent.ts';
import fs from 'node:fs';
// I can't find good documentation on the memory module, so let's apply the nuclear method

fs.rmSync(DB_NAME);
```

================
File: api/srcbook/examples/websockets.src.md
================
<!-- srcbook:{"language":"javascript"} -->

# Intro to WebSockets

###### package.json

```json
{
  "type": "module",
  "dependencies": {
    "ws": "^8.17.1"
  }
}
```

This Srcbook is a fun demonstration of building a simple WebSocket client and server in Node.js using the [ws library](https://github.com/websockets/ws). We'll explore the basic concepts of communicating over WebSockets and showcase Srcbook's ability to host long-running processes.

## WebSockets

[Wikipedia defines](https://en.wikipedia.org/wiki/WebSocket) WebSocket as:

> WebSocket is a computer communications protocol, providing a simultaneous two-way communication channel over a single Transmission Control Protocol (TCP) connection.

The important callout here is "two-way communication channel," which differentiates it from most web-based network communication that follows a request-response pattern. WebSockets enable the server to send a message, _unprompted_, to a client without other tricks like [polling](https://en.wikipedia.org/wiki/Polling_(computer_science)).

Applications typically leverage WebSockets when they need to repeatedly inform the client of state changes, like communication products that push new messages to the client or update the presence of users in a chat room. Other typical use cases involve realtime notifications, ecommerce item availability updates, and forwarding process output to code cells in Srcbook :)

### WebSockets in Node.js

One of the most popular libraries for WebSockets in Node.js is the [ws library](https://www.npmjs.com/package/ws) with over 70 million weekly downloads.

Below we implement a simple WebSocket _server_ using `ws`.

###### simple-server.js

```javascript
import { WebSocketServer } from 'ws';

// Start this simple server on port 5405
const wss = new WebSocketServer({ port: 5405 });

wss.on('connection', (socket) => {
  socket.on('message', (data) => {
    console.log('Server received: %s', data);
  });
  console.log("New client connected")
});
```

This simple server does nothing more than wait for incoming connections and log the messages it receives.

Next, we need a _client_ to connect and send messages to it. Note the client is running in a Node.js process, not in the browser. Backends communicate over WebSockets too!

###### simple-client.js

```javascript
import WebSocket from 'ws';

// Reference the same port the server is running on
const ws = new WebSocket('ws://localhost:5405');

ws.on('open', () => {
  ws.send('Hello from simple-client.js');
  ws.close();
});

```

Our simple client establishes a connection with the server, sends one message, and closes the connection. To run this example, first run the server and then run the client. Output is logged under the simple-server.js cell above.

## Stateful connections

The example above is not terribly interesting. WebSockets become more useful when the server tracks open connections and sends messages to the client.

###### stateful-server.js

```javascript
import { WebSocketServer } from 'ws';

// Start this simple server on port 5405
const wss = new WebSocketServer({ port: 5406 });

// Utility to create auto-incrementing ids for clients
const createClientId = ((id) => () => ++id)(0);

const connectedClients = [];

function broadcast(senderId, message) {
  for (const client of connectedClients) {
    // The client who is sending the message should not receive it
    if (client.id !== senderId) {
      client.socket.send(JSON.stringify(message));
    }
  }
}

wss.on('connection', (socket) => {
  const clientId = createClientId();

  // Store the client connection
  connectedClients.push({id: clientId, socket});

  // Inform others a new client has connected
  broadcast(clientId, {
    type: 'client:connected',
    payload: `Client ${clientId} connected`
  });

  // When the server receives a broadcast message,
  // send it to all the other connected clients
  socket.on('message', (data) => {
    const message = JSON.parse(data);
    if (message.type === 'broadcast') {
      broadcast(clientId, {
        type: "broadcast",
        payload: message.payload
      })
    }
  });

  socket.on('close', () => {
    // Inform others a client has disconnected
    broadcast(clientId, {
      type: 'client:disconnected',
      payload: `Client ${clientId} disconnected`
    });

    // Important: remember to remove the socket from
    // server state when the connection is closed.
    const idx = connectedClients.findIndex(({id}) => id === clientId);
    connectedClients.splice(idx, 1);
  });
});
```

###### client.js

```javascript
import WebSocket from 'ws';

console.log("Starting up");

const client1 = new WebSocket('ws://localhost:5406');
client1.on('message', (data) => {
  const message = JSON.parse(data);
  console.log(`Client 1 received ${message.type} message: ${message.payload}`)
});

// Simulate latency in between clients connecting
await new Promise((resolve) => setTimeout(resolve, 1500));

const client2 = new WebSocket('ws://localhost:5406');
client2.on('message', (data) => {
  const message = JSON.parse(data);
  console.log(`Client 2 received ${message.type} message: ${message.payload}`)
});

// We put this inside the open event to ensure the client has
// finished connecting to the server before sending a message.
client2.on('open', () => {
  // Client 2 sends a 'broadcast' message which the server will
  // broadcast all other connected clients.
  client2.send(JSON.stringify({type: 'broadcast', payload: 'Hello'}));
});

// Simulate latency in between clients disconnecting
await new Promise((resolve) => setTimeout(resolve, 1500));

client1.close();

// Simulate latency before second client disconnects
await new Promise((resolve) => setTimeout(resolve, 1500));

client2.close();

console.log("Shutting down");
```

## Explanation

The above example illustrates a stateful server that keeps track of the clients whom are connected. The server proactively sends messages to other connected clients when a new client joins and an existing one disconnects. The server also broadcasts messages to all other connected clients on behalf of any given client. This is a heavily simplified version of something like a chat room.

One of the more tedious aspects of this is keeping track of the state about connected clients. This is unlike typical HTTP request/reply patterns in which the server is stateless. It is especially tricky when you scale your WebSocket server horizontally because different clients are connected to different instances of your application. When this happens, state needs to be coordinated amongst all instances of the application, which typically requires extra infrastructure and consequently extra maintanence and performance considerations.

================
File: api/srcbook/config.mts
================
export function buildJSPackageJson() {
  return {
    type: 'module',
    devDependencies: {
      prettier: 'latest',
    },
    prettier: {
      semi: true,
      singleQuote: true,
    },
  };
}

export function buildTSPackageJson() {
  return {
    type: 'module',
    dependencies: {
      tsx: 'latest',
      typescript: 'latest',
      '@types/node': 'latest',
    },
    devDependencies: {
      prettier: 'latest',
    },
    prettier: {
      semi: true,
      singleQuote: true,
    },
  };
}

export function buildTsconfigJson() {
  return {
    compilerOptions: {
      types: [],
      strict: true,
      module: 'nodenext',
      moduleResolution: 'nodenext',
      target: 'es2022',
      resolveJsonModule: true,
      noEmit: true,
      allowImportingTsExtensions: true,
      noPropertyAccessFromIndexSignature: true,
    },
    include: ['src/**/*', 'env.d.ts'],
    exclude: ['node_modules'],
  };
}

================
File: api/srcbook/examples.mts
================
import Path from 'node:path';
import { DIST_DIR, SRCBOOKS_DIR } from '../constants.mjs';

// TODO: Put this in a migration and move to sqlite?

///////////////////////////////////////////////////////////
// Hardcoded ids so that we can easily track directories //
///////////////////////////////////////////////////////////

const GETTING_STARTED_SRCBOOK = {
  id: '30v2av4eee17m59dg2c29758to',
  path: Path.join(DIST_DIR, 'srcbook', 'examples', 'getting-started.src.md'),
  title: 'Getting started',
  language: 'javascript',
  description: 'Quick tutorial to explore the basic concepts in Srcbooks.',
  tags: ['Srcbook', 'Learn'],
  get dirname() {
    return Path.join(SRCBOOKS_DIR, this.id);
  },
};

const LANGGRAPH_AGENT_SRCBOOK = {
  id: 'i72jjpkqepmg5olneffvk7hgto',
  path: Path.join(DIST_DIR, 'srcbook', 'examples', 'langgraph-web-agent.src.md'),
  title: 'LangGraph agent',
  description: 'Learn to write a stateful agent with memory using LangGraph and Tavily.',
  language: 'typescript',
  tags: ['AI', 'Web'],
  get dirname() {
    return Path.join(SRCBOOKS_DIR, this.id);
  },
};

const INTRO_TO_WEBSOCKETS_SRCBOOK = {
  id: 'vnovpn5dbrthpdllvoeqahufc4',
  path: Path.join(DIST_DIR, 'srcbook', 'examples', 'websockets.src.md'),
  title: 'Intro to WebSockets',
  language: 'javascript',
  description: 'Learn to build a simple WebSocket client and server in Node.js.',
  tags: ['Web', 'WebSockets'],
  get dirname() {
    return Path.join(SRCBOOKS_DIR, this.id);
  },
};

export const EXAMPLE_SRCBOOKS = [
  GETTING_STARTED_SRCBOOK,
  LANGGRAPH_AGENT_SRCBOOK,
  INTRO_TO_WEBSOCKETS_SRCBOOK,
];

================
File: api/srcbook/index.mts
================
import fs from 'node:fs/promises';
import Path from 'node:path';
import type {
  CellType,
  CodeCellType,
  CodeLanguageType,
  PackageJsonCellType,
} from '@srcbook/shared';
import { randomid } from '@srcbook/shared';
import { encode, decode } from '../srcmd.mjs';
import { toFormattedJSON } from '../utils.mjs';
import { readdir } from '../fs-utils.mjs';
import { SRCBOOKS_DIR } from '../constants.mjs';
import { EXAMPLE_SRCBOOKS } from '../srcbook/examples.mjs';
import {
  pathToCodeFile,
  pathToPackageJson,
  pathToReadme,
  pathToSrcbook,
  pathToTsconfigJson,
} from './path.mjs';
import { buildJSPackageJson, buildTSPackageJson, buildTsconfigJson } from './config.mjs';
import type { SessionType } from '../types.mjs';
import { getSecretsAssociatedWithSession } from '../config.mjs';

function writeCellOnlyToDisk(srcbookDir: string, cell: PackageJsonCellType | CodeCellType) {
  const path =
    cell.type === 'package.json'
      ? pathToPackageJson(srcbookDir)
      : pathToCodeFile(srcbookDir, cell.filename);

  return fs.writeFile(path, cell.source, { encoding: 'utf8' });
}

export function writeToDisk(
  srcbook: Pick<SessionType, 'dir' | 'cells' | 'language' | 'tsconfig.json'>,
) {
  const writes = [writeReadmeToDisk(srcbook.dir, srcbook.language, srcbook.cells)];

  if (srcbook['tsconfig.json']) {
    writes.push(
      fs.writeFile(pathToTsconfigJson(srcbook.dir), srcbook['tsconfig.json'], {
        encoding: 'utf8',
      }),
    );
  }

  for (const cell of srcbook.cells) {
    if (cell.type === 'package.json' || cell.type === 'code') {
      writes.push(writeCellOnlyToDisk(srcbook.dir, cell));
    }
  }

  return Promise.all(writes);
}

export function writeCellToDisk(
  srcbookDir: string,
  language: CodeLanguageType,
  cells: CellType[],
  cell: PackageJsonCellType | CodeCellType,
) {
  // Readme must also be updated
  return Promise.all([
    writeReadmeToDisk(srcbookDir, language, cells),
    writeCellOnlyToDisk(srcbookDir, cell),
  ]);
}

export function moveCodeCellOnDisk(
  srcbookDir: string,
  language: CodeLanguageType,
  cells: CellType[],
  cell: CodeCellType,
  oldFilename: string,
) {
  return Promise.all([
    writeReadmeToDisk(srcbookDir, language, cells),
    fs.unlink(pathToCodeFile(srcbookDir, oldFilename)),
    fs.writeFile(pathToCodeFile(srcbookDir, cell.filename), cell.source, { encoding: 'utf8' }),
  ]);
}

export function writeReadmeToDisk(
  srcbookDir: string,
  language: CodeLanguageType,
  cells: CellType[],
) {
  return fs.writeFile(pathToReadme(srcbookDir), encode({ cells, language }, { inline: false }), {
    encoding: 'utf8',
  });
}

/**
 * Creates a srcbook directory from a .src.md file.
 */
export async function importSrcbookFromSrcmdFile(srcmdPath: string) {
  // Check if the user is opening one of the example Srcbooks that comes bundled with the app.
  const example = EXAMPLE_SRCBOOKS.find((example) => example.path === srcmdPath);

  if (example) {
    const { exists } = await readdir(example.dirname);

    if (exists) {
      return example.dirname;
    } else {
      const srcmd = await fs.readFile(example.path, 'utf8');
      return importSrcbookFromSrcmdText(srcmd, example.id);
    }
  } else {
    const srcmd = await fs.readFile(srcmdPath, 'utf8');
    return importSrcbookFromSrcmdText(srcmd);
  }
}

/**
 * Creates a srcbook directory from srcmd text.
 */
export async function importSrcbookFromSrcmdText(text: string, directoryBasename?: string) {
  const result = decode(text);

  if (result.error) {
    console.error(result.error);
    throw new Error(`Cannot decode invalid srcmd`);
  }

  const srcbook = result.srcbook;

  const dirname = await createSrcbookDir(directoryBasename);

  if (srcbook.language === 'typescript') {
    // It's possible the srcmd text does not contain tsconfig.json contents.
    // If that's the case, we must generate a new tsconfig.json file with our defaults
    // because reading from this directory will fail if tsconfig.json is missing.
    const tsconfig = srcbook['tsconfig.json'] || toFormattedJSON(buildTsconfigJson());

    await writeToDisk({
      dir: dirname,
      cells: srcbook.cells,
      language: srcbook.language,
      'tsconfig.json': tsconfig,
    });
  } else {
    await writeToDisk({ dir: dirname, ...srcbook });
  }

  return dirname;
}

/**
 * Creates a srcbook directory from a url to a srcmd file.
 */
export async function importSrcbookFromSrcmdUrl(srcmdUrl: string, directoryBasename?: string) {
  const srcmdResponse = await fetch(srcmdUrl);
  if (!srcmdResponse.ok) {
    throw new Error(
      `Error requesting ${srcmdUrl}: ${srcmdResponse.status} ${await srcmdResponse.text()}`,
    );
  }

  const text = await srcmdResponse.text();
  return importSrcbookFromSrcmdText(text, directoryBasename);
}

/**
 * Creates a new srcbook.
 * Each Srcbook has a directory in ~/.srcbook/ refered to as its private directory.
 * This private directory has a randomid() private identifier.
 * Users are not supposed to be aware or modify private directories.
 */
export async function createSrcbook(title: string, language: CodeLanguageType) {
  const dirname = await createSrcbookDir();

  const cells: CellType[] = [
    {
      id: randomid(),
      type: 'title',
      text: title,
    },
    {
      id: randomid(),
      type: 'package.json',
      source: buildPackageJson(language),
      filename: 'package.json',
      status: 'idle',
    },
  ];

  if (language === 'typescript') {
    await writeToDisk({
      dir: dirname,
      language,
      cells,
      'tsconfig.json': toFormattedJSON(buildTsconfigJson()),
    });
  } else {
    await writeToDisk({ dir: dirname, language, cells });
  }

  return dirname;
}

async function createSrcbookDir(basename: string = randomid()) {
  const srcbookDirectoryPath = Path.join(SRCBOOKS_DIR, basename);

  // Create the srcbook directory
  await fs.mkdir(srcbookDirectoryPath);

  // Create the src directory for user code
  const srcPath = Path.join(srcbookDirectoryPath, 'src');
  await fs.mkdir(srcPath);

  const envTypeDeclarationPath = Path.join(srcbookDirectoryPath, 'env.d.ts');
  const envTypeDeclarationFileContent = generateEnvTypesFile({});
  await fs.writeFile(envTypeDeclarationPath, envTypeDeclarationFileContent);

  return srcbookDirectoryPath;
}

function buildPackageJson(language: CodeLanguageType) {
  return toFormattedJSON(language === 'typescript' ? buildTSPackageJson() : buildJSPackageJson());
}

export function removeSrcbook(srcbookDir: string) {
  fs.rm(srcbookDir, { recursive: true });
}

export function removeCodeCellFromDisk(srcbookDir: string, filename: string) {
  return fs.rm(pathToCodeFile(srcbookDir, filename));
}

export async function updateSessionEnvTypeDeclarations(sessionId: string) {
  const sessionSecrets = await getSecretsAssociatedWithSession(sessionId);
  if (!Object.entries(sessionSecrets).length) return;
  const envTypeDeclarationFileContent = generateEnvTypesFile(sessionSecrets);
  const srcbookDir = pathToSrcbook(sessionId);
  const envDtsPath = Path.join(srcbookDir, 'env.d.ts');
  await fs.writeFile(envDtsPath, envTypeDeclarationFileContent);
}

export function generateEnvTypesFile(secrets: Record<string, string>) {
  const envTypes = Object.entries(secrets).length
    ? Object.keys(secrets)
        .map((key) => `readonly ${key}: string;`)
        .join('\n')
    : '';

  return `
  declare namespace NodeJS {
  interface ProcessEnv {
    ${envTypes}
  }
}

declare var process: {
  env: NodeJS.ProcessEnv;
};

  `;
}

================
File: api/srcbook/path.mts
================
import Path from 'node:path';
import { SRCBOOKS_DIR } from '../constants.mjs';

export function pathToSrcbook(id: string) {
  return Path.join(SRCBOOKS_DIR, id);
}

export function pathToReadme(baseDir: string) {
  return Path.join(baseDir, 'README.md');
}

export function pathToPackageJson(baseDir: string) {
  return Path.join(baseDir, 'package.json');
}

export function pathToTsconfigJson(baseDir: string) {
  return Path.join(baseDir, 'tsconfig.json');
}

export function pathToCodeFile(baseDir: string, filename: string) {
  return Path.join(baseDir, 'src', filename);
}

export function filenameFromPath(filePath: string) {
  return Path.basename(filePath);
}

================
File: api/srcmd/decoding.mts
================
import { marked } from 'marked';
import type { Tokens, Token, TokensList } from 'marked';
import { languageFromFilename, randomid, SrcbookMetadataSchema } from '@srcbook/shared';
import type {
  CellType,
  CodeCellType,
  MarkdownCellType,
  PackageJsonCellType,
  TitleCellType,
} from '@srcbook/shared';
import type { DecodeCellsResult, DecodeResult } from './types.mjs';
import { toFormattedJSON } from '../utils.mjs';

/**
 * This is used to decode a complete .src.md file.
 */
export function decode(contents: string): DecodeResult {
  // First, decode the markdown text into tokens.
  const tokens = marked.lexer(contents);

  // Second, pluck out srcbook metadata (ie <!-- srcbook:{<json>} -->):
  const { metadata, tokens: filteredTokens } = getSrcbookMetadata(tokens);

  // Third, group tokens by their function:
  //
  //     1. title
  //     2. markdown
  //     3. filename
  //     4. code
  //
  const groups = groupTokens(filteredTokens);

  // Fourth, validate the token groups and return a list of errors.
  // Example errors might be:
  //
  //     1. The document contains no title
  //     2. There is a filename (h6) with no corresponding code block
  //     3. There is more than one package.json defined
  //     4. etc.
  //
  const errors = validateTokenGroups(groups);

  // Finally, return either the set of errors or the tokens converted to cells if no errors were found.
  return errors.length > 0
    ? { error: true, errors: errors }
    : {
        error: false,
        srcbook: {
          language: metadata.language,
          cells: convertToCells(groups),
          'tsconfig.json': metadata['tsconfig.json'],
        },
      };
}

/**
 * This is used to decode a subset of a .src.md file.
 *
 * For example, we generate a subset of a Srcbook (1 or more cells) using AI.
 * When that happens, we do not have the entire .src.md contents, so we need
 * to ignore some aspects of it, like parsing the srcbook metadata comment.
 */
export function decodeCells(contents: string): DecodeCellsResult {
  const tokens = marked.lexer(contents);
  const groups = groupTokens(tokens);
  const errors = validateTokenGroupsPartial(groups);
  return errors.length > 0
    ? { error: true, errors }
    : { error: false, srcbook: { cells: convertToCells(groups) } };
}

const SRCBOOK_METADATA_RE = /^<!--\s*srcbook:(.+)\s*-->$/;

function getSrcbookMetadata(tokens: TokensList) {
  let match: RegExpMatchArray | null = null;
  let srcbookMetdataToken: Token | null = null;

  for (const token of tokens) {
    if (token.type !== 'html') {
      continue;
    }

    match = token.raw.trim().match(SRCBOOK_METADATA_RE);

    if (match) {
      srcbookMetdataToken = token;
      break;
    }
  }

  if (!match) {
    throw new Error('Srcbook does not contain required metadata');
  }

  try {
    const metadata = JSON.parse(match[1] ?? '');

    const filteredTokens = tokens.filter((t) => t !== srcbookMetdataToken);

    if (metadata && metadata['tsconfig.json']) {
      // This needs to be a string.
      const tsconfig = toFormattedJSON(metadata['tsconfig.json']);

      return {
        metadata: SrcbookMetadataSchema.parse({ ...metadata, 'tsconfig.json': tsconfig }),
        tokens: filteredTokens,
      };
    }

    return {
      metadata: SrcbookMetadataSchema.parse(metadata),
      tokens: filteredTokens,
    };
  } catch (e) {
    throw new Error(`Unable to parse srcbook metadata: ${(e as Error).message}`);
  }
}

type TitleGroupType = {
  type: 'title';
  token: Tokens.Heading;
};

type FilenameGroupType = {
  type: 'filename';
  token: Tokens.Heading;
};

type CodeGroupType = {
  type: 'code';
  token: Tokens.Code;
};

type LinkedCodeGroupType = {
  type: 'code:linked';
  token: Tokens.Link;
};

type MarkdownGroupType = {
  type: 'markdown';
  tokens: Token[];
};

type GroupedTokensType =
  | TitleGroupType
  | FilenameGroupType
  | CodeGroupType
  | MarkdownGroupType
  | LinkedCodeGroupType;

/**
 * Group tokens into an intermediate representation.
 */
function groupTokens(tokens: Token[]) {
  const grouped: GroupedTokensType[] = [];

  function pushMarkdownToken(token: Token) {
    const group = grouped[grouped.length - 1];
    if (group && group.type === 'markdown') {
      group.tokens.push(token);
    } else {
      grouped.push({ type: 'markdown', tokens: [token] });
    }
  }

  function lastGroupType() {
    const lastGroup = grouped[grouped.length - 1];
    return lastGroup ? lastGroup.type : null;
  }

  function isLink(token: Tokens.Paragraph) {
    return token.tokens.length === 1 && token.tokens[0]?.type === 'link';
  }

  let i = 0;
  const len = tokens.length;

  while (i < len) {
    const token = tokens[i];
    if (!token) continue;

    switch (token.type) {
      case 'heading':
        if (token.depth === 1) {
          grouped.push({ type: 'title', token: token as Tokens.Heading });
        } else if (token.depth === 6) {
          grouped.push({ type: 'filename', token: token as Tokens.Heading });
        } else {
          pushMarkdownToken(token);
        }
        break;
      case 'code':
        if (lastGroupType() === 'filename') {
          grouped.push({ type: 'code', token: token as Tokens.Code });
        } else {
          pushMarkdownToken(token);
        }
        break;
      case 'paragraph':
        if (lastGroupType() === 'filename' && token.tokens && isLink(token as Tokens.Paragraph)) {
          const link = token.tokens[0] as Tokens.Link;
          grouped.push({ type: 'code:linked', token: link });
        } else {
          pushMarkdownToken(token);
        }
        break;
      default:
        pushMarkdownToken(token);
    }

    i += 1;
  }

  // TODO: Ensure title and package.json are the first cells.
  return grouped;
}

function validateTokenGroups(grouped: GroupedTokensType[]) {
  const errors: string[] = [];

  const firstGroupIsTitle = grouped[0]?.type === 'title';
  const hasOnlyOneTitle = grouped.filter((group) => group.type === 'title').length === 1;
  const invalidTitle = !(firstGroupIsTitle && hasOnlyOneTitle);
  const hasAtMostOnePackageJson =
    grouped.filter((group) => group.type === 'filename' && group.token.text === 'package.json')
      .length <= 1;

  if (invalidTitle) {
    errors.push('Document must contain exactly one h1 heading');
  }

  if (!hasAtMostOnePackageJson) {
    errors.push('Document must contain at most one package.json');
  }

  let i = 0;
  const len = grouped.length;

  while (i < len) {
    const group = grouped[i];

    if (group?.type === 'filename') {
      if (!['code', 'code:linked'].includes(grouped[i + 1]?.type ?? '')) {
        const raw = group.token.raw.trimEnd();
        errors.push(`h6 is reserved for code cells, but no code block followed '${raw}'`);
      } else {
        i += 1;
      }
    }

    i += 1;
  }

  return errors;
}

function validateTokenGroupsPartial(grouped: GroupedTokensType[]) {
  const errors: string[] = [];

  let i = 0;
  const len = grouped.length;

  while (i < len) {
    const group = grouped[i];

    if (group?.type === 'filename') {
      if (!['code', 'code:linked'].includes(grouped[i + 1]?.type ?? '')) {
        const raw = group.token.raw.trimEnd();
        errors.push(`h6 is reserved for code cells, but no code block followed '${raw}'`);
      } else {
        i += 1;
      }
    }

    i += 1;
  }

  return errors;
}

function convertToCells(groups: GroupedTokensType[]): CellType[] {
  const len = groups.length;
  const cells: CellType[] = [];

  let i = 0;

  while (i < len) {
    const group = groups[i];

    if (group?.type === 'title') {
      cells.push(convertTitle(group.token));
    } else if (group?.type === 'markdown') {
      const hasNonSpaceTokens = group.tokens.some((token) => token.type !== 'space');
      // This shouldn't happen under most conditions, but there could be cases where there
      // is excess whitespace, causing markdown blocks that were not intentional. Thus, we
      // only create markdown cells when the markdown contains more than just space tokens.
      if (hasNonSpaceTokens) {
        cells.push(convertMarkdown(group.tokens));
      }
    } else if (group?.type === 'filename') {
      i += 1;
      switch (groups[i]?.type) {
        case 'code': {
          const codeToken = (groups[i] as CodeGroupType).token;
          const filename = group.token.text;
          const cell =
            filename === 'package.json'
              ? convertPackageJson(codeToken)
              : convertCode(codeToken, filename);
          cells.push(cell);
          break;
        }
        case 'code:linked': {
          const linkToken = (groups[i] as LinkedCodeGroupType).token;
          const cell = convertLinkedCode(linkToken);
          cells.push(cell);
          break;
        }
        default:
          throw new Error('Unexpected token type after a heading 6.');
      }
    }

    i += 1;
  }

  return cells;
}

function convertTitle(token: Tokens.Heading): TitleCellType {
  return {
    id: randomid(),
    type: 'title',
    text: token.text,
  };
}

function convertPackageJson(token: Tokens.Code): PackageJsonCellType {
  return {
    id: randomid(),
    type: 'package.json',
    source: token.text,
    filename: 'package.json',
    status: 'idle',
  };
}

function convertCode(token: Tokens.Code, filename: string): CodeCellType {
  return {
    id: randomid(),
    type: 'code',
    source: token.text,
    language: languageFromFilename(filename),
    filename: filename,
    status: 'idle',
  };
}

// Convert a linked code token to the right cell: either a package.json file or a code cell.
// We assume that the link is in the format [filename](filePath).
// We don't populate the source field here, as we will read the file contents later.
function convertLinkedCode(token: Tokens.Link): CodeCellType | PackageJsonCellType {
  return token.text === 'package.json'
    ? {
        id: randomid(),
        type: 'package.json',
        source: '',
        filename: 'package.json',
        status: 'idle',
      }
    : {
        id: randomid(),
        type: 'code',
        source: '',
        language: languageFromFilename(token.text),
        filename: token.text,
        status: 'idle',
      };
}

function convertMarkdown(tokens: Token[]): MarkdownCellType {
  return {
    id: randomid(),
    type: 'markdown',
    text: serializeMarkdownTokens(tokens),
  };
}

function serializeMarkdownTokens(tokens: Token[]) {
  return tokens
    .map((token) => {
      const md = token.raw;
      return token.type === 'code' ? md : md.replace(/\n{3,}/g, '\n\n');
    })
    .join('')
    .trim();
}

================
File: api/srcmd/encoding.mts
================
import type {
  CodeCellType,
  MarkdownCellType,
  PackageJsonCellType,
  TitleCellType,
  PlaceholderCellType,
  CellWithPlaceholderType,
  CodeLanguageType,
} from '@srcbook/shared';
import type { SrcbookType } from './types.mjs';

type SrcbookWithPlacebolderType = Omit<SrcbookType, 'cells'> & {
  cells: CellWithPlaceholderType[];
};

export function encode(srcbook: SrcbookWithPlacebolderType, options: { inline: boolean }) {
  const [firstCell, secondCell, ...remainingCells] = srcbook.cells;
  const titleCell = firstCell as TitleCellType;
  const packageJsonCell = secondCell as PackageJsonCellType;
  const cells = remainingCells as (MarkdownCellType | CodeCellType | PlaceholderCellType)[];

  const encoded = [
    encodeMetdata(srcbook),
    encodeTitleCell(titleCell),
    encodePackageJsonCell(packageJsonCell, options),
    ...cells.map((cell) => {
      switch (cell.type) {
        case 'code':
          return encodeCodeCell(cell, options);
        case 'markdown':
          return encodeMarkdownCell(cell);
        case 'placeholder':
          return encodePlacebolderCell(cell);
      }
    }),
  ];

  // End every file with exactly one newline.
  return encoded.join('\n\n').trimEnd() + '\n';
}

function encodeMetdata(srcbook: SrcbookWithPlacebolderType) {
  const metadata: { language: CodeLanguageType; 'tsconfig.json'?: any } = {
    language: srcbook.language,
  };

  // tsconfig is kept as a string in srcbook. However, when encoding
  // it in srcmd, we need it to be an object in the metadata header.
  if (srcbook.language === 'typescript' && srcbook['tsconfig.json']) {
    try {
      const parsed = JSON.parse(srcbook['tsconfig.json']);
      metadata['tsconfig.json'] = parsed;
    } catch (e) {
      // This should never happen
      console.error('Failed to parse tsconfig.json:', e);
    }
  }

  return `<!-- srcbook:${JSON.stringify(metadata)} -->`;
}

function encodeTitleCell(cell: TitleCellType) {
  return `# ${cell.text}`;
}

function encodeMarkdownCell(cell: MarkdownCellType) {
  return cell.text.trim();
}

function encodePlacebolderCell(cell: PlaceholderCellType) {
  return cell.text;
}

function encodePackageJsonCell(cell: PackageJsonCellType, options: { inline: boolean }) {
  return options.inline
    ? encodeFileInline({
        filename: 'package.json',
        language: 'json',
        source: cell.source,
      })
    : encodeFileExternal({
        filename: 'package.json',
        filepath: './package.json',
      });
}

function encodeCodeCell(cell: CodeCellType, options: { inline: boolean }) {
  return options.inline
    ? encodeFileInline({
        filename: cell.filename,
        language: cell.language,
        source: cell.source,
      })
    : encodeFileExternal({
        filename: cell.filename,
        filepath: `./src/${cell.filename}`,
      });
}

function encodeFileInline(options: { filename: string; language: string; source: string }) {
  const { filename, language, source } = options;
  return `###### ${filename}\n\n\`\`\`${language}\n${source}\n\`\`\``;
}

function encodeFileExternal(options: { filename: string; filepath: string }) {
  const { filename, filepath } = options;
  return `###### ${filename}\n\n[${filename}](${filepath})`;
}

================
File: api/srcmd/paths.mts
================
export function isSrcmdPath(path: string) {
  return path.endsWith('.src.md');
}

================
File: api/srcmd/types.mts
================
import type { SessionType } from '../types.mjs';

export type SrcbookType = Pick<SessionType, 'cells' | 'language' | 'tsconfig.json'>;

export type DecodeErrorResult = {
  error: true;
  errors: string[];
};

export type DecodeSuccessResult = {
  error: false;
  srcbook: SrcbookType;
};

export type DecodeCellsSuccessResult = {
  error: false;
  srcbook: Pick<SessionType, 'cells'>;
};

// This represents the result of decoding a complete .src.md file.
export type DecodeResult = DecodeErrorResult | DecodeSuccessResult;

// This represents the result of decoding a subset of content from a .src.md file.
export type DecodeCellsResult = DecodeErrorResult | DecodeCellsSuccessResult;

================
File: api/test/srcmd_files/mock_srcbook/src/foo.mjs
================
const foo = 42;
export const bar = true;
console.log(foo, bar);

================
File: api/test/srcmd_files/mock_srcbook/package.json
================
{
  "dependencies": {}
}

================
File: api/test/srcmd_files/mock_srcbook/README.md
================
<!-- srcbook:{"language":"javascript"} -->

# Srcbook

###### package.json

[package.json](./package.json)

With some words right behind it.

## Markdown cell

With some **bold** text and some _italic_ text.

> And a quote, why not!

###### foo.mjs

[foo.mjs](./src/foo.mjs)

```json
{ "simple": "codeblock" }
```

================
File: api/test/srcmd_files/srcbook.src.md
================
<!-- srcbook:{"language":"javascript"} -->

# Srcbook title

###### package.json

```json
{
  "dependencies": {}
}
```

Opening paragraph here.

## Section h2

Another paragraph.

Followed by:

1. An
2. Ordered
3. List

###### index.mjs

```javascript
// A code snippet here.
export function add(a, b) { return a + b }
```

## Another section

Description goes here. `inline code` works.

```javascript
// This will render as markdown, not a code cell.
foo() + bar()
```

###### foo.mjs

```javascript
import {add} from './index.mjs';
const res = add(2, 3);
console.log(res);
```

Paragraph here.

================
File: api/test/app-parser.test.mts
================
import { parseProjectXML } from '../ai/app-parser.mjs';

describe.skip('parseProjectXML', () => {
  it('should correctly parse XML and return a Project object', () => {
    const testXML = `
    <project id="test-project">
      <file filename="./test1.txt">
        <![CDATA[Test content 1]]>
      </file>
      <file filename="./test2.txt">
        <![CDATA[Test content 2]]>
      </file>
      <command>
        <![CDATA[npm install]]>
      </command>
    </project>
    `;

    const result = parseProjectXML(testXML);

    const expectedResult = {
      id: 'test-project',
      items: [
        { type: 'file', filename: './test1.txt', content: 'Test content 1' },
        { type: 'file', filename: './test2.txt', content: 'Test content 2' },
        { type: 'command', content: 'npm install' },
      ],
    };

    expect(result).toEqual(expectedResult);
  });

  it('should throw an error for invalid XML', () => {
    const invalidXML = '<invalid>XML</invalid>';

    expect(() => parseProjectXML(invalidXML)).toThrow('Failed to parse XML response');
  });

  it('should throw an error for XML without a project tag', () => {
    const noProjectXML = '<root><file>Content</file></root>';

    expect(() => parseProjectXML(noProjectXML)).toThrow('Failed to parse XML response');
  });
});

================
File: api/test/plan-chunks-2.txt
================
{"chunk":"<plan>\n  <plan"}
{"chunk":"Description>\n    <!["}
{"chunk":"CDATA["}
{"chunk":"\nI'll update the mock"}
{"chunk":" data to include Ph"}
{"chunk":"ish albums instead of the current albums"}
{"chunk":". I'll use"}
{"chunk":" real Phish album covers"}
{"chunk":" and titles to make it more authentic"}
{"chunk":".\n    ]]>"}
{"chunk":"\n  </planDescription>\n  <action"}
{"chunk":" type=\"file\">\n    <description"}
{"chunk":">\n      <![CDATA["}
{"chunk":"\nUpdate mockData.ts to include"}
{"chunk":" Phish albums with"}
{"chunk":" real album information\n      ]]>"}
{"chunk":"\n    </description>\n    <file filename"}
{"chunk":"=\"src/data/mockData.ts"}
{"chunk":"\">\n      <![CDATA["}
{"chunk":"\nimport { Album, PlaylistItem } from"}
{"chunk":" '../types';\n\nexport const albums"}
{"chunk":": Album[] = ["}
{"chunk":"\n  {\n    "}
{"chunk":"id: '1',"}
{"chunk":"\n    title: 'A"}
{"chunk":" Picture of Nectar"}
{"chunk":"',\n    artist: 'Phish"}
{"chunk":"',\n    cover:"}
{"chunk":" 'https://i"}
{"chunk":".scdn.co"}
{"chunk":"/image/ab67616d0000b"}
{"chunk":"273f3912f"}
{"chunk":"fc6e6533"}
{"chunk":"d0aae3c"}
{"chunk":"58d',\n  },"}
{"chunk":"\n  {\n    id: '2',"}
{"chunk":"\n    title: 'Billy"}
{"chunk":" Breathes',\n    artist: '"}
{"chunk":"Phish',\n    cover: '"}
{"chunk":"https://i.scdn.co/image"}
{"chunk":"/ab67616d0000b273f"}
{"chunk":"4c8d14"}
{"chunk":"e6c2d8"}
{"chunk":"b0651388be"}
{"chunk":"6',\n  },\n  {\n    "}
{"chunk":"id: '3',\n    title: "}
{"chunk":"'Farmhouse',\n    artist"}
{"chunk":": 'Phish',\n    cover"}
{"chunk":": 'https://i.scdn."}
{"chunk":"co/image/ab67616d0000"}
{"chunk":"b273f5a"}
{"chunk":"0be2976c3"}
{"chunk":"df8baae"}
{"chunk":"5d5b1"}
{"chunk":"',\n  },\n  {\n    i"}
{"chunk":"d: '4',\n    title: '"}
{"chunk":"Story of the Ghost',"}
{"chunk":"\n    artist: 'Phish',"}
{"chunk":"\n    cover: '"}
{"chunk":"https://i.scdn.co/image"}
{"chunk":"/ab67616d0000b273f"}
{"chunk":"00669d9866452"}
{"chunk":"b5f49f4"}
{"chunk":"989',\n  },\n  "}
{"chunk":"{\n    id: '5',\n    "}
{"chunk":"title: 'H"}
{"chunk":"oist',\n    artist"}
{"chunk":": 'Phish',\n    cover"}
{"chunk":": 'https://i.scdn."}
{"chunk":"co/image/ab67616d0000"}
{"chunk":"b273f5c500"}
{"chunk":"e2fa5f1"}
{"chunk":"d0ae5dce"}
{"chunk":"4df',\n  },"}
{"chunk":"\n  {\n    i"}
{"chunk":"d: '6',\n    title: '"}
{"chunk":"Sigma Oasis',"}
{"chunk":"\n    artist: 'Phish',"}
{"chunk":"\n    cover: '"}
{"chunk":"https://i.scdn.co/image"}
{"chunk":"/ab67616d0000b273a"}
{"chunk":"0c79aba3"}
{"chunk":"b83f5f016"}
{"chunk":"f47737',\n  },"}
{"chunk":"\n];\n\nexport const playlists: Playlist"}
{"chunk":"Item[] = ["}
{"chunk":"\n  { id: '"}
{"chunk":"1', name: "}
{"chunk":"'Liked Songs',"}
{"chunk":" icon: '❤"}
{"chunk":"️' },\n  "}
{"chunk":"{ id: '2', name: '"}
{"chunk":"Your Episodes', icon:"}
{"chunk":" '🎙️' },\n  {"}
{"chunk":" id: '3', name: 'Rock"}
{"chunk":" Classics', icon: '🎸'"}
{"chunk":" },\n  { id: '4', name"}
{"chunk":": 'Chill Vibes',"}
{"chunk":" icon: '🌊' },\n];"}
{"chunk":"\n      ]]>\n    </"}
{"chunk":"file>\n  </"}
{"chunk":"action>\n"}
{"chunk":"<action type=\"command\">\n"}
{"chunk":"<description>\n    <![CDATA["}
{"chunk":"Install react-router"}
{"chunk":"\n      ]]>"}
{"chunk":"</description>    \n"}
{"chunk":"<commandType>npm install\n<"}
{"chunk": "/commandType>"}
{"chunk":"<package>react-router\n"}
{"chunk":"   </package>\n   "}
{"chunk":"</action> \n"}
{"chunk": "</plan"}
{"chunk":">"}

================
File: api/test/plan-chunks.txt
================
{"chunk":"<plan"}
{"chunk":">\n  "}
{"chunk":"<plan"}
{"chunk":"Description"}
{"chunk":">\n    "}
{"chunk":"<!["}
{"chunk":"CDATA["}
{"chunk":"\nUpdate"}
{"chunk":" the mock"}
{"chunk":" data to include classic"}
{"chunk":" rock bands in"}
{"chunk":" the trending"}
{"chunk":" albums section."}
{"chunk":" I"}
{"chunk":"'ll modify"}
{"chunk":" the albums"}
{"chunk":" data"}
{"chunk":" to include The Beatles,"}
{"chunk":" Talking Heads,"}
{"chunk":" Grateful Dead, an"}
{"chunk":"d Radiohead with"}
{"chunk":" their iconic"}
{"chunk":" albums"}
{"chunk":".\n    ]]"}
{"chunk":">\n  </plan"}
{"chunk":"Description>\n  "}
{"chunk":"<action"}
{"chunk":" type"}
{"chunk":"=\"file"}
{"chunk":"\">\n    <description"}
{"chunk":">\n      <!["}
{"chunk":"CDATA["}
{"chunk":"\nUpdate"}
{"chunk":" mock"}
{"chunk":" data with"}
{"chunk":" classic"}
{"chunk":" rock albums"}
{"chunk":" for"}
{"chunk":" the"}
{"chunk":" trending section"}
{"chunk":"\n      ]]>"}
{"chunk":"\n    </description>"}
{"chunk":"\n    <file filename"}
{"chunk":"=\"src/data/"}
{"chunk":"mock"}
{"chunk":"Data.ts\">"}
{"chunk":"\n      <![C"}
{"chunk":"DATA[\nimport"}
{"chunk":" { Album,"}
{"chunk":" PlaylistItem } from"}
{"chunk":" '../types';\n\nexport"}
{"chunk":" const albums"}
{"chunk":": Album[] = ["}
{"chunk":"\n  {\n    "}
{"chunk":"id: '1',"}
{"chunk":"\n    title: "}
{"chunk":"'Abbey"}
{"chunk":" Road',\n    artist"}
{"chunk":": 'The Beatles"}
{"chunk":"',\n    cover:"}
{"chunk":" 'https"}
{"chunk":"://pic"}
{"chunk":"sum.photos/see"}
{"chunk":"d/beat"}
{"chunk":"les/300"}
{"chunk":"/300',\n  "}
{"chunk":"},\n  {"}
{"chunk":"\n    id: '2"}
{"chunk":"',\n    title:"}
{"chunk":" 'Remain in"}
{"chunk":" Light',\n    artist"}
{"chunk":": 'Talking"}
{"chunk":" Heads',\n    "}
{"chunk":"cover: 'https"}
{"chunk":"://picsum.photos"}
{"chunk":"/seed/talking/"}
{"chunk":"300/300',"}
{"chunk":"\n  },\n  {"}
{"chunk":"\n    id: '"}
{"chunk":"3',\n    title"}
{"chunk":": 'American Beauty"}
{"chunk":"',\n    artist:"}
{"chunk":" 'Grateful Dea"}
{"chunk":"d',\n    cover:"}
{"chunk":" 'https://pic"}
{"chunk":"sum.photos/see"}
{"chunk":"d/dea"}
{"chunk":"d/300/300',"}
{"chunk":"\n  },\n  "}
{"chunk":"{\n    id:"}
{"chunk":" '4',\n    "}
{"chunk":"title: 'OK"}
{"chunk":" Computer',\n    artist"}
{"chunk":": 'Radio"}
{"chunk":"head',\n    cover"}
{"chunk":": 'https://"}
{"chunk":"picsum.photos/"}
{"chunk":"seed/radiohead/"}
{"chunk":"300/300',"}
{"chunk":"\n  },\n  "}
{"chunk":"{\n    id:"}
{"chunk":" '5',\n    "}
{"chunk":"title: 'Un"}
{"chunk":" Ve"}
{"chunk":"rano Sin Ti',"}
{"chunk":"\n    artist: '"}
{"chunk":"Ba"}
{"chunk":"d Bunny',"}
{"chunk":"\n    cover: '"}
{"chunk":"https://picsum."}
{"chunk":"photos/seed/5"}
{"chunk":"/300/300',"}
{"chunk":"\n  },\n  "}
{"chunk":"{\n    id:"}
{"chunk":" '6',\n    "}
{"chunk":"title: '"}
{"chunk":"30"}
{"chunk":"',\n    artist:"}
{"chunk":" 'Adele"}
{"chunk":"',\n    cover:"}
{"chunk":" 'https://pic"}
{"chunk":"sum.photos/see"}
{"chunk":"d/6"}
{"chunk":"/300/300',"}
{"chunk":"\n  },\n];"}
{"chunk":"\n\nexport const playl"}
{"chunk":"ists: PlaylistItem"}
{"chunk":"[] = [\n  "}
{"chunk":"{ id: '1"}
{"chunk":"', name: '"}
{"chunk":"Liked Songs', icon"}
{"chunk":": '❤️"}
{"chunk":"' },\n  {"}
{"chunk":" id: '2',"}
{"chunk":" name: 'Your"}
{"chunk":" Episodes', icon: '"}
{"chunk":"🎙️'"}
{"chunk":" },\n  { i"}
{"chunk":"d: '3', name"}
{"chunk":": 'Rock"}
{"chunk":" Classics', icon: '"}
{"chunk":"🎸' },"}
{"chunk":"\n  { id:"}
{"chunk":" '4', name:"}
{"chunk":" 'Chill"}
{"chunk":" Vibes', icon"}
{"chunk":": '🌊"}
{"chunk":"' },\n];"}
{"chunk":"\n      ]]>"}
{"chunk":"\n    </file>"}
{"chunk":"\n  </action>"}
{"chunk":"\n</plan>"}

================
File: api/test/plan-parser.test.mts
================
import { expect, test, describe } from 'vitest';
import { parsePlan } from '../ai/plan-parser.mjs';
import { type App as DBAppType } from '../db/schema.mjs';
import { vi } from 'vitest';

// Mock the loadFile function
vi.mock('../apps/disk.mjs', () => ({
  loadFile: vi.fn().mockImplementation((_app, filePath) => {
    if (filePath === 'src/App.tsx') {
      return Promise.resolve({ source: 'Original App.tsx content' });
    }
    return Promise.reject(new Error('File not found'));
  }),
}));

const mockApp: DBAppType = {
  id: 123,
  externalId: '123',
  name: 'Test App',
  createdAt: new Date(),
  updatedAt: new Date(),
  history: '',
  historyVersion: 1,
};

const mockXMLResponse = `
<plan>
  <planDescription>Implement a basic todo list app</planDescription>
  <action type="file">
    <description>Update App.tsx with todo list functionality</description>
    <file filename="src/App.tsx">
      <![CDATA[
import React, { useState, useEffect } from 'react';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

function App() {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [inputValue, setInputValue] = useState('');

  useEffect(() => {
    const storedTodos = localStorage.getItem('todos');
    if (storedTodos) {
      setTodos(JSON.parse(storedTodos));
    }
  }, []);

  useEffect(() => {
    localStorage.setItem('todos', JSON.stringify(todos));
  }, [todos]);

  const addTodo = () => {
    if (inputValue.trim() !== '') {
      setTodos([...todos, { id: Date.now(), text: inputValue, completed: false }]);
      setInputValue('');
    }
  };

  const toggleTodo = (id: number) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Todo List</h1>
      <div className="flex mb-4">
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          className="flex-grow p-2 border rounded-l"
          placeholder="Add a new todo"
        />
        <button onClick={addTodo} className="bg-blue-500 text-white p-2 rounded-r">Add</button>
      </div>
      <ul>
        {todos.map(todo => (
          <li key={todo.id} className="flex items-center mb-2">
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
              className="mr-2"
            />
            <span className={todo.completed ? 'line-through' : ''}>{todo.text}</span>
          </li>
        ))}
      </ul>
    </div>
  );
}

export default App;
      ]]>
    </file>
  </action>
  <action type="command">
    <description>Install required packages</description>
    <commandType>npm install</commandType>
    <package>@types/react</package>
    <package>@types/react-dom</package>
  </action>
</plan>
`;

describe('parsePlan', () => {
  test('should correctly parse a plan with file and command actions', async () => {
    const plan = await parsePlan(mockXMLResponse, mockApp, 'test query', '123445');

    expect(plan.id).toBe('123445');
    expect(plan.query).toBe('test query');
    expect(plan.description).toBe('Implement a basic todo list app');
    expect(plan.actions).toHaveLength(2);

    // Check file action
    const fileAction = plan.actions[0] as any;
    expect(fileAction.type).toBe('file');
    expect(fileAction.path).toBe('src/App.tsx');
    expect(fileAction.modified).toContain('function App()');
    expect(fileAction.original).toBe('Original App.tsx content');
    expect(fileAction.description).toBe('Update App.tsx with todo list functionality');

    // Check command action
    const commandAction = plan.actions[1] as any;
    expect(commandAction.type).toBe('command');
    expect(commandAction.command).toBe('npm install');
    expect(commandAction.packages).toEqual(['@types/react', '@types/react-dom']);
    expect(commandAction.description).toBe('Install required packages');
  });
});

================
File: api/test/srcmd.test.mts
================
import Path from 'path';
import { getRelativeFileContents } from './utils.mjs';
import { decode, encode, decodeDir } from '../srcmd.mjs';
import type { DecodeErrorResult, DecodeSuccessResult } from '../srcmd/types.mjs';

describe('encoding and decoding srcmd files', () => {
  let srcmd: string;
  const languagePrefix = '<!-- srcbook:{"language": "javascript"} -->\n\n';

  beforeAll(async () => {
    srcmd = await getRelativeFileContents('srcmd_files/srcbook.src.md');
  });

  it('is an error when there is no title', () => {
    const result = decode(
      languagePrefix + '## Heading 2\n\nFollowed by a paragraph',
    ) as DecodeErrorResult;
    expect(result.error).toBe(true);
    expect(result.errors).toEqual(['Document must contain exactly one h1 heading']);
  });

  it('is an error when there are multiple titles', () => {
    const result = decode(
      languagePrefix + '# Heading 1\n\nFollowed by a paragraph\n\n# Followed by another heading 1',
    ) as DecodeErrorResult;
    expect(result.error).toBe(true);
    expect(result.errors).toEqual(['Document must contain exactly one h1 heading']);
  });

  it('is an error when there is a heading 6 without a corresponding code block', () => {
    const result = decode(
      languagePrefix +
        '# Heading 1\n\n###### supposed_to_be_a_filename.mjs\n\nBut no code is found.',
    ) as DecodeErrorResult;
    expect(result.error).toBe(true);
    expect(result.errors).toEqual([
      "h6 is reserved for code cells, but no code block followed '###### supposed_to_be_a_filename.mjs'",
    ]);
  });

  it('can decode a well-formed file', () => {
    const result = decode(srcmd) as DecodeSuccessResult;
    expect(result.error).toBe(false);
    expect(result.srcbook.cells).toEqual([
      { id: expect.any(String), type: 'title', text: 'Srcbook title' },
      {
        id: expect.any(String),
        type: 'package.json',
        source: `{\n  "dependencies": {}\n}`,
        filename: 'package.json',
        status: 'idle',
      },
      {
        id: expect.any(String),
        type: 'markdown',
        text: `Opening paragraph here.\n\n## Section h2\n\nAnother paragraph.\n\nFollowed by:\n\n1. An\n2. Ordered\n3. List`,
      },
      {
        id: expect.any(String),
        type: 'code',
        source: '// A code snippet here.\nexport function add(a, b) { return a + b }',
        language: 'javascript',
        filename: 'index.mjs',
        status: 'idle',
      },
      {
        id: expect.any(String),
        type: 'markdown',
        text: '## Another section\n\nDescription goes here. `inline code` works.\n\n```javascript\n// This will render as markdown, not a code cell.\nfoo() + bar()\n```',
      },
      {
        id: expect.any(String),
        type: 'code',
        source: "import {add} from './index.mjs';\nconst res = add(2, 3);\nconsole.log(res);",
        language: 'javascript',
        filename: 'foo.mjs',
        status: 'idle',
      },
      {
        id: expect.any(String),
        type: 'markdown',
        text: 'Paragraph here.',
      },
    ]);
  });

  it('can encode cells', () => {
    const result = decode(srcmd) as DecodeSuccessResult;
    expect(result.error).toBe(false);
    expect(
      encode({ cells: result.srcbook.cells, language: result.srcbook.language }, { inline: true }),
    ).toEqual(srcmd);
  });
});

describe('it can decode from directories', () => {
  it('can decode a simple directory with README, package, and one file', async () => {
    const dirPath = Path.resolve(__dirname, 'srcmd_files/mock_srcbook/');
    const result = (await decodeDir(dirPath)) as DecodeSuccessResult;
    expect(result.error).toBe(false);
    expect(result.srcbook.cells).toEqual([
      { id: expect.any(String), type: 'title', text: 'Srcbook' },
      {
        id: expect.any(String),
        type: 'package.json',
        source: `{\n  "dependencies": {}\n}\n`,
        filename: 'package.json',
        status: 'idle',
      },
      {
        id: expect.any(String),
        type: 'markdown',
        text: 'With some words right behind it.\n\n## Markdown cell\n\nWith some **bold** text and some _italic_ text.\n\n> And a quote, why not!',
      },
      {
        id: expect.any(String),
        type: 'code',
        source: 'const foo = 42;\nexport const bar = true;\nconsole.log(foo, bar);\n',
        language: 'javascript',
        filename: 'foo.mjs',
        status: 'idle',
      },
      {
        id: expect.any(String),
        type: 'markdown',
        text: '```json\n{ "simple": "codeblock" }\n```',
      },
    ]);
  });
});

================
File: api/test/streaming-xml-parser.test.mts
================
import fs from 'node:fs';
import Path from 'node:path';
import { StreamingXMLParser, type TagType } from '../ai/stream-xml-parser.mjs';

const filepath = new URL(import.meta.url).pathname;

function getExampleChunks(filename: string) {
  const chunkLines = fs.readFileSync(Path.resolve(filepath, filename), 'utf-8');
  return chunkLines
    .split('\n')
    .filter((line) => line.trim() !== '')
    .map((chunk) => JSON.parse(chunk).chunk);
}

describe('parsePlan', () => {
  test('should correctly parse a plan with file and command actions', async () => {
    const tags: TagType[] = [];
    const parser = new StreamingXMLParser({
      onTag: (tag) => {
        if (tag.name === 'planDescription' || tag.name === 'action') {
          tags.push(tag);
        }
      },
    });
    getExampleChunks('../plan-chunks.txt').forEach((chunk) => parser.parse(chunk));
    expect(tags).toEqual([
      {
        name: 'planDescription',
        attributes: {},
        content:
          "Update the mock data to include classic rock bands in the trending albums section. I'll modify the albums data to include The Beatles, Talking Heads, Grateful Dead, and Radiohead with their iconic albums.",
        children: [],
      },
      {
        name: 'action',
        attributes: { type: 'file' },
        content: '',
        children: [
          {
            name: 'description',
            attributes: {},
            content: 'Update mock data with classic rock albums for the trending section',
            children: [],
          },
          {
            name: 'file',
            attributes: { filename: 'src/data/mockData.ts' },
            content: `
import { Album, PlaylistItem } from '../types';

export const albums: Album[] = [
  {
    id: '1',
    title: 'Abbey Road',
    artist: 'The Beatles',
    cover: 'https://picsum.photos/seed/beatles/300/300',
  },
  {
    id: '2',
    title: 'Remain in Light',
    artist: 'Talking Heads',
    cover: 'https://picsum.photos/seed/talking/300/300',
  },
  {
    id: '3',
    title: 'American Beauty',
    artist: 'Grateful Dead',
    cover: 'https://picsum.photos/seed/dead/300/300',
  },
  {
    id: '4',
    title: 'OK Computer',
    artist: 'Radiohead',
    cover: 'https://picsum.photos/seed/radiohead/300/300',
  },
  {
    id: '5',
    title: 'Un Verano Sin Ti',
    artist: 'Bad Bunny',
    cover: 'https://picsum.photos/seed/5/300/300',
  },
  {
    id: '6',
    title: '30',
    artist: 'Adele',
    cover: 'https://picsum.photos/seed/6/300/300',
  },
];

export const playlists: PlaylistItem[] = [
  { id: '1', name: 'Liked Songs', icon: '❤️' },
  { id: '2', name: 'Your Episodes', icon: '🎙️' },
  { id: '3', name: 'Rock Classics', icon: '🎸' },
  { id: '4', name: 'Chill Vibes', icon: '🌊' },
];`.trim(),
            children: [],
          },
        ],
      },
    ]);
  });

  test('should correctly parse a plan with file and command actions', async () => {
    const tags: TagType[] = [];
    const parser = new StreamingXMLParser({
      onTag: (tag) => {
        if (tag.name === 'planDescription' || tag.name === 'action') {
          tags.push(tag);
        }
      },
    });
    getExampleChunks('../plan-chunks-2.txt').forEach((chunk) => parser.parse(chunk));
    expect(tags).toEqual([
      {
        name: 'planDescription',
        attributes: {},
        content:
          "I'll update the mock data to include Phish albums instead of the current albums. I'll use real Phish album covers and titles to make it more authentic.",
        children: [],
      },
      {
        name: 'action',
        attributes: { type: 'file' },
        content: '',
        children: [
          {
            name: 'description',
            attributes: {},
            content: 'Update mockData.ts to include Phish albums with real album information',
            children: [],
          },
          {
            name: 'file',
            attributes: { filename: 'src/data/mockData.ts' },
            content: `
import { Album, PlaylistItem } from '../types';

export const albums: Album[] = [
  {
    id: '1',
    title: 'A Picture of Nectar',
    artist: 'Phish',
    cover: 'https://i.scdn.co/image/ab67616d0000b273f3912ffc6e6533d0aae3c58d',
  },
  {
    id: '2',
    title: 'Billy Breathes',
    artist: 'Phish',
    cover: 'https://i.scdn.co/image/ab67616d0000b273f4c8d14e6c2d8b0651388be6',
  },
  {
    id: '3',
    title: 'Farmhouse',
    artist: 'Phish',
    cover: 'https://i.scdn.co/image/ab67616d0000b273f5a0be2976c3df8baae5d5b1',
  },
  {
    id: '4',
    title: 'Story of the Ghost',
    artist: 'Phish',
    cover: 'https://i.scdn.co/image/ab67616d0000b273f00669d9866452b5f49f4989',
  },
  {
    id: '5',
    title: 'Hoist',
    artist: 'Phish',
    cover: 'https://i.scdn.co/image/ab67616d0000b273f5c500e2fa5f1d0ae5dce4df',
  },
  {
    id: '6',
    title: 'Sigma Oasis',
    artist: 'Phish',
    cover: 'https://i.scdn.co/image/ab67616d0000b273a0c79aba3b83f5f016f47737',
  },
];

export const playlists: PlaylistItem[] = [
  { id: '1', name: 'Liked Songs', icon: '❤️' },
  { id: '2', name: 'Your Episodes', icon: '🎙️' },
  { id: '3', name: 'Rock Classics', icon: '🎸' },
  { id: '4', name: 'Chill Vibes', icon: '🌊' },
];
      `.trim(),
            children: [],
          },
        ],
      },
      {
        name: 'action',
        attributes: { type: 'command' },
        content: '',
        children: [
          {
            name: 'description',
            attributes: {},
            content: 'Install react-router',
            children: [],
          },
          {
            name: 'commandType',
            attributes: {},
            content: 'npm install',
            children: [],
          },
          {
            name: 'package',
            attributes: {},
            content: 'react-router',
            children: [],
          },
        ],
      },
    ]);
  });
});

================
File: api/test/tsserver.test.mts
================
import { parse } from '../tsserver/messages.mjs';

describe('parsing JSON RPC messages', () => {
  it('complete message', () => {
    const chunk = Buffer.from(
      'Content-Length: 76\r\n\r\n{"seq":0,"type":"event","event":"typingsInstallerPid","body":{"pid":58118}}\n',
    );

    const { messages, buffered } = parse(chunk, Buffer.from(''));

    expect(messages).toEqual([
      {
        seq: 0,
        type: 'event',
        event: 'typingsInstallerPid',
        body: { pid: 58118 },
      },
    ]);

    expect(buffered).toEqual(Buffer.from(''));
  });

  it('partial message', () => {
    const firstChunk = Buffer.from(
      'Content-Length: 76\r\n\r\n{"seq":0,"type":"event","event":"typingsInstallerPid","body":{"pid":58118}}\nContent-Length: 18\r\n\r\n{"js',
    );

    const secondChunk = Buffer.from('onrpc":"2.0"}\n');

    let result = parse(firstChunk, Buffer.from(''));

    expect(result.messages).toEqual([
      {
        seq: 0,
        type: 'event',
        event: 'typingsInstallerPid',
        body: { pid: 58118 },
      },
    ]);

    expect(result.buffered.toString('utf-8')).toEqual('Content-Length: 18\r\n\r\n{"js');

    result = parse(secondChunk, result.buffered);

    expect(result.messages).toEqual([{ jsonrpc: '2.0' }]);
    expect(result.buffered.toString('utf-8')).toEqual('');
  });

  it('message with unicode characters', () => {
    const chunk = Buffer.from(
      `Content-Length: 396\r\n\r\n{"seq":0,"type":"event","event":"semanticDiag","body":{"file":"/Users/ben/.srcbook/srcbooks/26c73ru4docv5bnve7e68ca6to/src/foo.ts","diagnostics":[{"start":{"line":1,"offset":1},"end":{"line":1,"offset":2},"text":"Cannot find name 'Ï'.","code":2304,"category":"error"},{"start":{"line":3,"offset":13},"end":{"line":3,"offset":14},"text":"Cannot find name 'x'.","code":2304,"category":"error"}]}}\nContent-Length: 152\r\n\r\n{"seq":0,"type":"event","event":"suggestionDiag","body":{"file":"/Users/ben/.srcbook/srcbooks/26c73ru4docv5bnve7e68ca6to/src/foo.ts","diagnostics":[]}}\n`,
    );

    const { messages, buffered } = parse(chunk, Buffer.from(''));

    expect(messages).toEqual([
      {
        seq: 0,
        type: 'event',
        event: 'semanticDiag',
        body: {
          file: '/Users/ben/.srcbook/srcbooks/26c73ru4docv5bnve7e68ca6to/src/foo.ts',
          diagnostics: [
            {
              start: { line: 1, offset: 1 },
              end: { line: 1, offset: 2 },
              text: "Cannot find name 'Ï'.",
              code: 2304,
              category: 'error',
            },
            {
              start: { line: 3, offset: 13 },
              end: { line: 3, offset: 14 },
              text: "Cannot find name 'x'.",
              code: 2304,
              category: 'error',
            },
          ],
        },
      },
      {
        body: {
          diagnostics: [],
          file: '/Users/ben/.srcbook/srcbooks/26c73ru4docv5bnve7e68ca6to/src/foo.ts',
        },
        event: 'suggestionDiag',
        seq: 0,
        type: 'event',
      },
    ]);

    expect(buffered).toEqual(Buffer.from(''));
  });
});

================
File: api/test/utils.mts
================
import fs from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import path from 'node:path';

export async function getRelativeFileContents(relativePath: string) {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  return fs.readFile(path.join(__dirname, relativePath), { encoding: 'utf8' });
}

================
File: api/tsserver/messages.mts
================
import type { server as tsserver } from 'typescript';

const ENCODER = new TextEncoder();
const DECODER = new TextDecoder();
const CONTENT_LENGTH_HEADER = ENCODER.encode('Content-Length: ');
const CARRIAGE_RETURN_CHAR_CODE = '\r'.charCodeAt(0);

/**
 * Parse messages from a chunk of data sent by tsserver.
 *
 * Notes:
 *
 * - A 'message' takes the form:  "Content-Length: <number>\r\n\r\n<json>".
 * - A single chunk may contain multiple messages.
 * - A single chunk of data may contain an incomplete message, or contain complete message(s) followed by an incomplete one.
 * - The "content length" number is the number of bytes, not characters. Unicode characters may be multiple bytes but only one string character. Thus, we must parse bytes not strings.
 */
export function parse(chunk: Buffer, buffered: Buffer) {
  let buffer = new Uint8Array(Buffer.concat([buffered, chunk]));

  const messages: Array<tsserver.protocol.Event | tsserver.protocol.Response> = [];

  while (true) {
    const content = getContentByteLength(buffer);

    if (content === null) {
      return { messages: messages, buffered: Buffer.from(buffer) };
    }

    const { start, byteLength } = content;

    const end = start + byteLength;

    if (end > buffer.byteLength) {
      return { messages: messages, buffered: Buffer.from(buffer) };
    }

    const message = DECODER.decode(buffer.slice(start, end));

    messages.push(JSON.parse(message));

    buffer = buffer.slice(end);

    if (buffer.byteLength === 0) {
      break;
    }
  }

  return { messages, buffered: Buffer.from(buffer) };
}

/**
 * Get the byte length and start index of the message content.
 *
 * If the buffer does not contain a complete Content-Length header, null is returned.
 *
 * If the buffer is an unexpected format (has data but not the Content-Length header),
 * an error is thrown.
 *
 * Example:
 *
 *     getContentByteLength("Content-Length: 3\r\n\r\n{}\n") // => { start: 21, byteLength: 3 }
 *
 */
function getContentByteLength(buffer: Uint8Array): { start: number; byteLength: number } | null {
  if (buffer.byteLength < CONTENT_LENGTH_HEADER.byteLength) {
    return null;
  }

  if (!startsWith(buffer, CONTENT_LENGTH_HEADER)) {
    throw new Error(
      `Expected buffer argument to start with '${DECODER.decode(CONTENT_LENGTH_HEADER)}'`,
    );
  }

  const start = CONTENT_LENGTH_HEADER.byteLength;

  let i = start;

  while (true) {
    if (i >= buffer.byteLength) {
      return null;
    }

    if (buffer[i] === CARRIAGE_RETURN_CHAR_CODE || buffer[i] === undefined) {
      break;
    }

    // If the character is not a number (codes 48-57), the data in the buffer is invalid.
    if ((buffer[i] as number) < 48 || (buffer[i] as number) > 57) {
      throw new Error(
        `Unexpected byte '${buffer[i]}' in Content-Length header. Expected a number between 0 and 9 (byte values 48-57).`,
      );
    }

    i++;
  }

  const byteLength = Number(DECODER.decode(buffer.slice(start, i)));

  // The message content starts after '\r\n\r\n'
  const contentStart = i + 4;

  if (buffer.byteLength < contentStart) {
    return null;
  }

  return { start: contentStart, byteLength: byteLength };
}

/**
 * Does one buffer start with another?
 *
 * Examples:
 *
 *     startsWith(Uint8Array(4) [1,2,3,4], Uint8Array (2) [1,2]) // => true
 *     startsWith(Uint8Array(4) [1,2,3,4], Uint8Array (2) [5,2]) // => false
 */
function startsWith(buffer: Uint8Array, prefix: Uint8Array) {
  const bufferLen = buffer.byteLength;
  const prefixLen = prefix.byteLength;

  if (prefixLen > bufferLen) {
    return false;
  }

  for (let i = 0; i < prefixLen; i++) {
    if (buffer[i] !== prefix[i]) {
      return false;
    }
  }

  return true;
}

================
File: api/tsserver/tsserver.mts
================
import EventEmitter from 'node:events';
import type { ChildProcess } from 'node:child_process';
import type { server as tsserver } from 'typescript';
import { parse } from './messages.mjs';

/**
 * This class provides a wrapper around a process running tsserver and is used to communicate
 * with the server, mainly to support diagnostics for user code (type errors, sytnax errors,
 * type definitions, etc).
 *
 * tsserver is not documented. Here is a brief overview.
 *
 * tsserver is a process which listens for messages over stdin and
 * sends messages over stdout. tsserver has three types of messages:
 *
 * 1. Request: A request from the client to the server.
 * 2. Response: A response from the server to a specific client request.
 * 3. Event: An event from the server to the client.
 *
 * Request and responses are identified a unique number called `seq`. `seq` is incremented
 * for each request the client sends. The client will send a `seq` field with its request
 * and the server will provide a `request_seq` in its response which is used to tie a message
 * from the server to a specific request from the client.
 *
 * Events can arrive at any time but are often used as an asynchronous response from the server.
 * For example, syntax and semantic diagnostics are sent as events when using the `geterr` command.
 *
 * Most of this is learned by reading through the source (protocol.ts) as well as trial
 * and error. They also have an introduction, but it's hardly useful. See links below.
 *
 * - https://github.com/microsoft/TypeScript/blob/v5.5.3/src/server/protocol.ts
 * - https://github.com/microsoft/TypeScript/wiki/Standalone-Server-(tsserver)
 */
export class TsServer extends EventEmitter {
  private _seq: number = 0;
  private buffered: Buffer = Buffer.from('');
  private readonly process: ChildProcess;
  private readonly resolvers: Record<number, (value: any) => void> = {};

  constructor(process: ChildProcess) {
    super();
    this.process = process;
    this.process.stdout?.on('data', (chunk) => {
      const { messages, buffered } = parse(chunk, this.buffered);
      this.buffered = buffered;
      for (const message of messages) {
        if (message.type === 'response') {
          this.handleResponse(message);
        } else if (message.type === 'event') {
          this.handleEvent(message);
        }
      }
    });
  }

  private get seq() {
    return this._seq++;
  }

  private handleResponse(response: tsserver.protocol.Response) {
    const resolve = this.resolvers[response.request_seq];

    if (!resolve) {
      console.warn(
        `Received a response for command '${response.command}' and request_seq '${response.request_seq}' but no resolver was found. This may be a bug in the code.\n\nResponse:\n${JSON.stringify(response, null, 2)}\n`,
      );

      return;
    }

    delete this.resolvers[response.request_seq];

    resolve(response);
  }

  private handleEvent(event: tsserver.protocol.Event) {
    this.emit(event.event, event);
  }

  private send(request: tsserver.protocol.Request) {
    this.process.stdin?.write(JSON.stringify(request) + '\n');
  }

  private sendWithResponsePromise<T>(request: tsserver.protocol.Request) {
    return new Promise<T>((resolve) => {
      this.resolvers[request.seq] = resolve;
      this.send(request);
    });
  }

  /**
   * Wrapper around the `semanticDiag` event for convenience and type safety.
   */
  onSemanticDiag(callback: (event: tsserver.protocol.DiagnosticEvent) => void) {
    this.on('semanticDiag', callback);
  }

  /**
   * Wrapper around the `syntaxDiag` event for convenience and type safety.
   */
  onSyntaxDiag(callback: (event: tsserver.protocol.DiagnosticEvent) => void) {
    this.on('syntaxDiag', callback);
  }

  /**
   * Wrapper around the `suggestionDiag` event for convenience and type safety.
   */
  onSuggestionDiag(callback: (event: tsserver.protocol.DiagnosticEvent) => void) {
    this.on('suggestionDiag', callback);
  }

  /**
   * Shutdown the underlying tsserver process.
   */
  shutdown() {
    this.removeAllListeners();
    return this.process.kill('SIGTERM');
  }

  /**
   * Explicitly 'open' a file in tsserver.
   *
   * This is used to tell tsserver to start tracking a file and all its dependencies.
   */
  open(args: tsserver.protocol.OpenRequestArgs) {
    return this.send({
      seq: this.seq,
      type: 'request',
      command: 'open',
      arguments: args,
    });
  }

  /**
   * Explicitly 'close' a file in tsserver.
   *
   * This is used to tell tsserver to stop tracking a file.
   */
  close(args: tsserver.protocol.FileRequestArgs) {
    return this.send({
      seq: this.seq,
      type: 'request',
      command: 'close',
      arguments: args,
    });
  }

  /**
   * Ask tsserver to send diagnostics for a set of files.
   *
   * This is used to get the errors for a set of files in a project.
   *
   * Note that the diagnostics are sent as asynchronous events instead of responding to this request.
   */
  geterr(args: tsserver.protocol.GeterrRequestArgs) {
    this.send({
      seq: this.seq,
      type: 'request',
      command: 'geterr',
      arguments: args,
    });
  }

  /**
   * Reload the project in tsserver.
   *
   * This is used to tell tsserver to reload the project configuration
   * which helps ensure that the project is up-to-date. This helps resolve
   * errors that can occur when renaming files.
   */
  reloadProjects() {
    this.send({
      seq: this.seq,
      type: 'request',
      command: 'reloadProjects',
    });
  }

  /**
   * Get info about the project.
   *
   * This can be useful during development to inspect the tsserver integration.
   */
  projectInfo(args: tsserver.protocol.ProjectInfoRequestArgs) {
    return this.sendWithResponsePromise<tsserver.protocol.ProjectInfoResponse>({
      seq: this.seq,
      type: 'request',
      command: 'projectInfo',
      arguments: args,
    });
  }

  /**
   * Get info about a term at a specific location in a file.
   *
   * This is used for type definitions and documentation lookups on hover.
   */
  quickinfo(args: tsserver.protocol.FileLocationRequestArgs) {
    return this.sendWithResponsePromise<tsserver.protocol.QuickInfoResponse>({
      seq: this.seq,
      type: 'request',
      command: 'quickinfo',
      arguments: args,
    });
  }

  getDefinitionLocation(args: tsserver.protocol.FileLocationRequestArgs) {
    return this.sendWithResponsePromise<tsserver.protocol.DefinitionResponse>({
      seq: this.seq,
      type: 'request',
      command: 'definition',
      arguments: args,
    });
  }

  getCompletions(args: tsserver.protocol.FileLocationRequestArgs) {
    return this.sendWithResponsePromise<{ body: tsserver.protocol.CompletionEntry[] }>({
      seq: this.seq,
      type: 'request',
      command: 'completions',
      arguments: args,
    });
  }
}

================
File: api/tsserver/tsservers.mts
================
import { spawn } from 'child_process';
import { TsServer } from './tsserver.mjs';

/**
 * This object is responsible for managing multiple tsserver instances.
 */
export class TsServers {
  private servers: Record<string, TsServer> = {};

  get(id: string) {
    const server = this.servers[id];

    if (!server) {
      throw new Error(`tsserver for ${id} does not exist.`);
    }

    return server;
  }

  set(id: string, server: TsServer) {
    if (this.servers[id]) {
      throw new Error(`tsserver for ${id} already exists.`);
    }

    this.servers[id] = server;
  }

  has(id: string) {
    return this.servers[id] !== undefined;
  }

  del(id: string) {
    delete this.servers[id];
  }

  create(id: string, options: { cwd: string }) {
    if (this.has(id)) {
      throw new Error(`tsserver for ${id} already exists.`);
    }

    // This is using the TypeScript dependency in the user's Srcbook.
    //
    // Note: If a user creates a typescript Srcbook, when it is first
    // created, the dependencies are not installed and thus this will
    // shut down immediately. Make sure that we handle this case after
    // package.json has finished installing its deps.
    const child = spawn('npx', ['tsserver'], {
      cwd: options.cwd,
    });

    const server = new TsServer(child);

    this.set(id, server);

    child.on('exit', () => {
      this.del(id);
    });

    return server;
  }

  shutdown(id: string) {
    if (!this.has(id)) {
      console.warn(`tsserver for ${id} does not exist. Skipping shutdown.`);
      return;
    }

    // The server is removed from this.servers in the
    // process exit handler which covers all exit cases.
    return this.get(id).shutdown();
  }
}

================
File: api/tsserver/utils.mts
================
import type { server as tsserver } from 'typescript';
import type { TsServerDiagnosticType } from '@srcbook/shared';

export function normalizeDiagnostic(
  diagnostic: tsserver.protocol.Diagnostic | tsserver.protocol.DiagnosticWithLinePosition,
): TsServerDiagnosticType {
  if (isDiagnosticWithLinePosition(diagnostic)) {
    return {
      code: diagnostic.code,
      category: diagnostic.category,
      text: diagnostic.message,
      start: diagnostic.startLocation,
      end: diagnostic.endLocation,
    };
  } else {
    return {
      // From what I can tell, code should always be present despite the type.
      // If it's not, we use 1000 as the 'unknown' error code, which is not a
      // code defined in diagnosticMessages.json in TypeScript's source.
      code: diagnostic.code || 1000,
      category: diagnostic.category,
      text: diagnostic.text,
      start: diagnostic.start,
      end: diagnostic.end,
    };
  }
}

// No elegant implementation for this.
function isDiagnosticWithLinePosition(
  diagnostic: tsserver.protocol.Diagnostic | tsserver.protocol.DiagnosticWithLinePosition,
): diagnostic is tsserver.protocol.DiagnosticWithLinePosition {
  return 'startLocation' in diagnostic;
}

================
File: api/.eslintrc.cjs
================
/** @type {import("eslint").Linter.Config} */
module.exports = {
  root: true,
  extends: [require.resolve('@srcbook/configs/eslint/library.js')],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: './tsconfig.lint.json',
    tsconfigRootDir: __dirname,
  },
  globals: {
    Bun: false,
  },
  ignorePatterns: ['apps/templates/**/*'],
};

================
File: api/.npmignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

*.gitignored.*

================
File: api/CHANGELOG.md
================
# @srcbook/api

## 0.0.17

### Patch Changes

- 5014815: Remove noisy logs

## 0.0.16

### Patch Changes

- fcabe77: Add support for API keys on openAI compatible models

## 0.0.15

### Patch Changes

- a236470: Add gemini support
- Updated dependencies [a236470]
  - @srcbook/shared@0.0.13

## 0.0.14

### Patch Changes

- 727bab7: Support X ai models
- 2e774d4: Support streaming of the responses!
- Updated dependencies [727bab7]
- Updated dependencies [2e774d4]
  - @srcbook/shared@0.0.12

## 0.0.13

### Patch Changes

- e361ea8: Bugfix: dont crash if the git repo didnt previously exist

## 0.0.12

### Patch Changes

- b49bdf4: The backend now notifies the frontend of file changes -> files update visually in realtime
- bbbd5d6: Add versions! powered by git. Ability to revert to an older version
- 26d548e: Improve prompts. Guide to use lucide. Guide to use react-router. Clean unused files
- Updated dependencies [b49bdf4]
- Updated dependencies [bbbd5d6]
  - @srcbook/shared@0.0.11

## 0.0.11

### Patch Changes

- 9b94f4d: Include templates in published app and remove unused template

## 0.0.10

### Patch Changes

- c3e857b: Add typing support and errors for environment variables
- ccd8d01: Introduce app builder
- 73cd6e8: support backend hmr
- 89e4c7b: fix server crash when stopping the cell
- Updated dependencies [ccd8d01]
- Updated dependencies [73cd6e8]
  - @srcbook/shared@0.0.10

## 0.0.9

### Patch Changes

- 459b18d: Deploy all packages
- Updated dependencies [459b18d]
  - @srcbook/shared@0.0.9

## 0.0.8

### Patch Changes

- 24c841e: Update websocket client to pass context and connection
- a063c46: Fix uncaught exceptions in TsServer event handlers after srcbook deletion
- Updated dependencies [24c841e]
  - @srcbook/shared@0.0.8

## 0.0.7

### Patch Changes

- 691f81f: 480bf57: Adds autocomplete support!
- Updated dependencies [691f81f]
  - @srcbook/shared@0.0.7

## 0.0.6

### Patch Changes

- 0eb51dd: Added support for goto def with Alt(Option) + Click
- 3c912b9: b365ee5: Improved import and export behaviors to support importing from a url/clipboard, and exporting to the clipboard
- 23494ad: Update generate Srcbook prompt with mermaid instructions
- Updated dependencies [0eb51dd]
  - @srcbook/shared@0.0.6

## 0.0.5

### Patch Changes

- 8c99a0d: Fix broken NPM package
- Updated dependencies [8c99a0d]
  - @srcbook/shared@0.0.5

## 0.0.4

### Patch Changes

- 9f0a632: Secrets must now be enabled per Srcbook
- Updated dependencies [9f0a632]
  - @srcbook/shared@0.0.4

## 0.0.3

### Patch Changes

- b5ab034: Added an upsell to subscribe to our mailing list + ability to update in settings
- a920be0: Windows support with resolve DB path off home dir
- 545699e: Add Prettier Support to Code Notebook
- 833264c: Underlying dependency bumps for maintenence
- Updated dependencies [545699e]
- Updated dependencies [833264c]
  - @srcbook/shared@0.0.3

## 0.0.2

### Patch Changes

- Updated dependencies [735deb8]
  - @srcbook/shared@0.0.2

## 0.0.1

### Patch Changes

- 4e04909: hover tooltips, tooling improvements, new contributors effyzhang 1egoman!
- Updated dependencies [4e04909]
  - @srcbook/shared@0.0.1

================
File: api/config.mts
================
import { eq, and, inArray } from 'drizzle-orm';
import { type SecretWithAssociatedSessions, randomid } from '@srcbook/shared';
import { MessageType, HistoryType } from '@srcbook/shared';
import {
  configs,
  type Config,
  secrets,
  type Secret,
  secretsToSession,
  apps,
} from './db/schema.mjs';
import { db } from './db/index.mjs';
import { HOME_DIR } from './constants.mjs';

async function init() {
  const existingConfig = await db.select().from(configs).limit(1);

  if (existingConfig.length === 0) {
    const defaultConfig = {
      baseDir: HOME_DIR,
      defaultLanguage: 'typescript',
      installId: randomid(),
      aiConfig: { provider: 'openai', model: 'gpt-4o' } as const,
      aiProvider: 'openai',
      aiModel: 'gpt-4o',
    };
    console.log();
    console.log('Initializing application with the following configuration:\n');
    console.log(JSON.stringify(defaultConfig, null, 2));
    console.log();
    await db.insert(configs).values(defaultConfig).returning();
  }
}

// Block rest of module until we have initialized config.
await init();

export async function getConfig(): Promise<Config> {
  const results = await db.select().from(configs);

  if (results.length !== 1) {
    console.warn('Expected exactly one config record, found:', results.length);
  }
  if (results.length === 0) {
    throw new Error('No config found');
  }
  // explicitly known that a config exists here
  return results[0] as Config;
}

export async function updateConfig(attrs: Partial<Config>) {
  return db.update(configs).set(attrs).returning();
}

export async function getHistory(appId: string): Promise<HistoryType> {
  const results = await db.select().from(apps).where(eq(apps.externalId, appId)).limit(1);
  const history = results[0]!.history;
  return JSON.parse(history);
}

export async function appendToHistory(appId: string, messages: MessageType | MessageType[]) {
  const results = await db.select().from(apps).where(eq(apps.externalId, appId)).limit(1);
  const history = results[0]!.history;
  const decodedHistory = JSON.parse(history);
  const newHistory = Array.isArray(messages)
    ? [...decodedHistory, ...messages]
    : [...decodedHistory, messages];
  await db
    .update(apps)
    .set({ history: JSON.stringify(newHistory) })
    .where(eq(apps.externalId, appId));
}

export async function getSecrets(): Promise<Array<SecretWithAssociatedSessions>> {
  const secretsResult = await db.select().from(secrets);
  const secretsToSessionResult = await db
    .select()
    .from(secretsToSession)
    .where(
      inArray(
        secretsToSession.secret_id,
        secretsResult.map((secret) => secret.id),
      ),
    );

  return secretsResult.map((secret) => ({
    name: secret.name,
    value: secret.value,
    associatedWithSessionIds: secretsToSessionResult
      .filter((secretToSession) => secretToSession.secret_id === secret.id)
      .map((secretToSession) => secretToSession.session_id),
  }));
}

export async function getSecretsAssociatedWithSession(
  sessionId: string,
): Promise<Record<string, string>> {
  const secretsResults = await getSecrets();
  return Object.fromEntries(
    secretsResults
      .filter((secret) => secret.associatedWithSessionIds.includes(sessionId))
      .map((secret) => [secret.name, secret.value]),
  );
}

export async function addSecret(name: string, value: string): Promise<Secret> {
  const result = await db
    .insert(secrets)
    .values({ name, value })
    .onConflictDoUpdate({ target: secrets.name, set: { value } })
    .returning();
  if (result.length === 0) {
    throw new Error('No secret returned');
  }
  // explicitly known that a config exists here
  return result[0] as Secret;
}

export async function removeSecret(name: string) {
  await db.delete(secrets).where(eq(secrets.name, name)).returning();
}

export async function associateSecretWithSession(secretName: string, sessionId: string) {
  const result = await db
    .select({ id: secrets.id })
    .from(secrets)
    .where(eq(secrets.name, secretName))
    .limit(1);
  if (result.length < 1) {
    throw new Error(
      `Cannot associate '${secretName}' with ${sessionId}: cannot find secret with that name!`,
    );
  }
  const secretId = result[0]!.id;

  await db
    .insert(secretsToSession)
    .values({ secret_id: secretId, session_id: sessionId })
    .onConflictDoNothing()
    .returning();
}

export async function disassociateSecretWithSession(secretName: string, sessionId: string) {
  const result = await db
    .select({ id: secrets.id })
    .from(secrets)
    .where(eq(secrets.name, secretName))
    .limit(1);
  if (result.length < 1) {
    throw new Error(
      `Cannot associate '${secretName}' with ${sessionId}: cannot find secret with that name!`,
    );
  }
  const secretId = result[0]!.id;

  await db
    .delete(secretsToSession)
    .where(
      and(eq(secretsToSession.secret_id, secretId), eq(secretsToSession.session_id, sessionId)),
    )
    .returning();
}

================
File: api/constants.mts
================
import os from 'node:os';
import path from 'node:path';
import { fileURLToPath } from 'url';

// When running Srcbook as an npx executable, the cwd is not reliable.
// Commands that should be run from the root of the package, like npm scripts
// should therefore use DIST_DIR as the cwd.
const _filename = fileURLToPath(import.meta.url);
const _dirname = path.dirname(_filename);

export const HOME_DIR = os.homedir();
export const SRCBOOK_DIR = path.join(HOME_DIR, '.srcbook');
export const SRCBOOKS_DIR = path.join(SRCBOOK_DIR, 'srcbooks');
export const APPS_DIR = path.join(SRCBOOK_DIR, 'apps');
export const DIST_DIR = _dirname;
export const PROMPTS_DIR = path.join(DIST_DIR, 'prompts');
export const IS_PRODUCTION = process.env.NODE_ENV === 'production';

================
File: api/deps.mts
================
import Path from 'node:path';
import { exec } from 'node:child_process';
import { readFile } from './fs-utils.mjs';
import { DIST_DIR } from './constants.mjs';

export async function shouldNpmInstall(dirPath: string): Promise<boolean> {
  const packageJsonPath = Path.resolve(Path.join(dirPath, 'package.json'));
  const packageLockPath = Path.resolve(Path.join(dirPath, 'package-lock.json'));

  const [packageJsonResult, packageLockResult] = await Promise.all([
    readFile(packageJsonPath),
    readFile(packageLockPath),
  ]);

  if (!packageJsonResult.exists) {
    throw new Error(`No package.json was found in ${dirPath}`);
  }

  const pkgJson = JSON.parse(packageJsonResult.contents);
  const dependencies = Object.keys(pkgJson.dependencies || {});
  const devDependencies = Object.keys(pkgJson.devDependencies || {});

  // No dependencies == nothing to do
  if (dependencies.length === 0 && devDependencies.length === 0) {
    return false;
  }

  // Dependencies but no lock file == needs install
  if (!packageLockResult.exists) {
    return true;
  }

  const pkgLock = JSON.parse(packageLockResult.contents);
  const lockDependencies = pkgLock.packages['']?.dependencies || {};
  const lockDevDependencies = pkgLock.packages['']?.devDependencies || {};

  for (const dep of dependencies) {
    if (!Object.hasOwn(lockDependencies, dep)) {
      return true;
    }
  }

  for (const devDep of devDependencies) {
    if (!Object.hasOwn(lockDevDependencies, devDep)) {
      return true;
    }
  }

  return false; // All dependencies are installed
}

export async function missingUndeclaredDeps(dirPath: string): Promise<string[]> {
  return new Promise((resolve) => {
    // Ignore the err argument because depcheck exists with a non zero code (255) when there are missing deps.
    exec(
      `npm run depcheck ${Path.resolve(dirPath)} -- --json`,
      { cwd: DIST_DIR },
      (_err, stdout) => {
        const output = stdout || '';

        // Use regex to extract JSON object
        const jsonMatch = output.match(/{.*}/s);
        if (!jsonMatch) {
          throw new Error('Failed to extract JSON from depcheck output.');
        }

        // Parse the JSON
        const parsedResult = JSON.parse(jsonMatch[0]);

        // Process and return the data as needed
        resolve(Object.keys(parsedResult.missing));
      },
    );
  });
}

================
File: api/dev-server.mts
================
import http from 'node:http';
import { WebSocketServer as WsWebSocketServer } from 'ws';

import app from './server/http.mjs';
import webSocketServer from './server/ws.mjs';

export { SRCBOOK_DIR } from './constants.mjs';

const server = http.createServer(app);

const wss = new WsWebSocketServer({ server });
wss.on('connection', webSocketServer.onConnection);

const port = process.env.PORT || 2150;
server.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});

process.on('SIGINT', async function () {
  server.close();
  process.exit();
});
if (import.meta.hot) {
  import.meta.hot.on('vite:beforeFullReload', () => {
    wss.close();
    server.close();
  });

  import.meta.hot.dispose(() => {
    wss.close();
    server.close();
  });
}

================
File: api/drizzle.config.ts
================
import { defineConfig } from 'drizzle-kit';
import Path from 'node:path';
import { SRCBOOK_DIR } from './constants.mts';

export default defineConfig({
  schema: './db/schema.mts',
  out: './drizzle',
  dialect: 'sqlite',
  dbCredentials: {
    url: Path.join(SRCBOOK_DIR, 'srcbook.db'),
  },
});

================
File: api/exec.mts
================
import Path from 'node:path';
import { spawn } from 'node:child_process';

interface NodeError extends Error {
  code?: string;
}

export type BaseExecRequestType = {
  cwd: string;
  stdout: (data: Buffer) => void;
  stderr: (data: Buffer) => void;
  onExit: (code: number | null, signal: NodeJS.Signals | null) => void;
  onError?: (err: NodeError) => void;
};

export type NodeRequestType = BaseExecRequestType & {
  env: NodeJS.ProcessEnv;
  entry: string;
};

export type NPMInstallRequestType = BaseExecRequestType & {
  packages?: Array<string>;
  args?: Array<string>;
};

type NpxRequestType = BaseExecRequestType & {
  args: Array<string>;
};

type SpawnCallRequestType = {
  cwd: string;
  env: NodeJS.ProcessEnv;
  command: string;
  args: Array<string>;
  stdout: (data: Buffer) => void;
  stderr: (data: Buffer) => void;
  onExit: (code: number | null, signal: NodeJS.Signals | null) => void;
  onError?: (err: NodeError) => void;
};

export function spawnCall(options: SpawnCallRequestType) {
  const { cwd, env, command, args, stdout, stderr, onExit, onError } = options;
  const child = spawn(command, args, { cwd: cwd, env: env });

  child.stdout.on('data', stdout);
  child.stderr.on('data', stderr);

  child.on('error', (err) => {
    if (onError) {
      onError(err);
    } else {
      console.error(err);
    }
  });

  child.on('exit', (code, signal) => {
    onExit(code, signal);
  });

  return child;
}

/**
 * Execute a JavaScript file using node.
 *
 * Example:
 *
 *     node({
 *       cwd: '/Users/ben/.srcbook/30v2av4eee17m59dg2c29758to',
 *       env: {FOO_ENV_VAR: 'foooooooo'},
 *       entry: '/Users/ben/.srcbook/30v2av4eee17m59dg2c29758to/src/foo.js',
 *       stdout(data) {console.log(data.toString('utf8'))},
 *       stderr(data) {console.error(data.toString('utf8'))},
 *       onExit(code) {console.log(`Exit code: ${code}`)}
 *     });
 *
 */
export function node(options: NodeRequestType) {
  const { cwd, env, entry, stdout, stderr, onExit } = options;

  return spawnCall({
    command: 'node',
    cwd,
    args: [entry],
    stdout,
    stderr,
    onExit,
    env: { ...process.env, ...env },
  });
}

/**
 * Execute a TypeScript file using tsx.
 *
 * Example:
 *
 *     tsx({
 *       cwd: '/Users/ben/.srcbook/30v2av4eee17m59dg2c29758to',
 *       env: {FOO_ENV_VAR: 'foooooooo'},
 *       entry: '/Users/ben/.srcbook/30v2av4eee17m59dg2c29758to/src/foo.ts',
 *       stdout(data) {console.log(data.toString('utf8'))},
 *       stderr(data) {console.error(data.toString('utf8'))},
 *       onExit(code) {console.log(`Exit code: ${code}`)}
 *     });
 *
 */
export function tsx(options: NodeRequestType) {
  const { cwd, env, entry, stdout, stderr, onExit } = options;

  // We are making an assumption about `tsx` being the tool of choice
  // for running TypeScript, as well as where it's located on the file system.
  return spawnCall({
    command: Path.join(cwd, 'node_modules', '.bin', 'tsx'),
    cwd,
    args: [entry],
    stdout,
    stderr,
    onExit,
    env: { ...process.env, ...env },
  });
}

/**
 * Run npm install.
 *
 * Install all packages:
 *
 *     npmInstall({
 *       cwd: '/Users/ben/.srcbook/foo',
 *       stdout(data) {console.log(data.toString('utf8'))},
 *       stderr(data) {console.error(data.toString('utf8'))},
 *       onExit(code) {console.log(`Exit code: ${code}`)}
 *     });
 *
 * Install a specific package:
 *
 *     npmInstall({
 *       cwd: '/Users/ben/.srcbook/foo',
 *       package: 'marked',
 *       stdout(data) {console.log(data.toString('utf8'))},
 *       stderr(data) {console.error(data.toString('utf8'))},
 *       onExit(code) {console.log(`Exit code: ${code}`)}
 *     });
 *
 */
export function npmInstall(options: NPMInstallRequestType) {
  const { cwd, stdout, stderr, onExit } = options;
  const args = options.packages
    ? ['install', '--include=dev', ...(options.args || []), ...options.packages]
    : ['install', '--include=dev', ...(options.args || [])];

  return spawnCall({
    command: 'npm',
    cwd,
    args,
    stdout,
    stderr,
    onExit,
    env: process.env,
  });
}

/**
 * Run vite.
 */
export function vite(options: NpxRequestType) {
  return spawnCall({
    ...options,
    command: Path.join(options.cwd, 'node_modules', '.bin', 'vite'),
    env: process.env,
  });
}

================
File: api/fs-utils.mts
================
import fs from 'node:fs/promises';

export async function fileExists(filepath: string) {
  try {
    await fs.access(filepath, fs.constants.F_OK);
    return true;
  } catch (error) {
    return false;
  }
}

export async function directoryExists(dirpath: string) {
  try {
    const result = await fs.stat(dirpath);
    return result.isDirectory();
  } catch (error) {
    return false;
  }
}

export async function readFile(
  path: string,
): Promise<{ exists: true; contents: string } | { exists: false }> {
  try {
    const contents = await fs.readFile(path, 'utf8');
    return { exists: true, contents };
  } catch (e) {
    const error = e as NodeJS.ErrnoException;
    if (error && error.code === 'ENOENT') {
      return { exists: false };
    }
    throw error;
  }
}

export async function readdir(
  path: string,
): Promise<{ exists: true; files: string[] } | { exists: false }> {
  try {
    const files = await fs.readdir(path);
    return { exists: true, files };
  } catch (e) {
    const error = e as NodeJS.ErrnoException;
    if (error && error.code === 'ENOENT') {
      return { exists: false };
    }
    throw error;
  }
}

================
File: api/index.mts
================
import app from './server/http.mjs';
import wss from './server/ws.mjs';
import { SRCBOOKS_DIR } from './constants.mjs';
import { posthog } from './posthog-client.mjs';

export { app, wss, SRCBOOKS_DIR, posthog };

================
File: api/package.json
================
{
  "name": "@srcbook/api",
  "version": "0.0.17",
  "type": "module",
  "main": "./dist/index.mjs",
  "types": "./dist/index.d.mts",
  "files": [
    "dist/**"
  ],
  "scripts": {
    "dev": "vite-node -w dev-server.mts",
    "test": "vitest",
    "prebuild": "rm -rf ./dist",
    "build": "tsc && cp -R ./drizzle ./dist/drizzle && cp -R ./srcbook/examples ./dist/srcbook/examples && cp -R ./prompts ./dist/prompts && cp -R ./apps/templates ./dist/apps/templates",
    "lint": "eslint . --max-warnings 0",
    "check-types": "tsc",
    "depcheck": "depcheck",
    "generate": "drizzle-kit generate",
    "migrate": "drizzle-kit migrate",
    "prepublishOnly": "tsc",
    "preversion": "vitest run && pnpm run build",
    "postversion": "git push && git push --tags"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "catalog:",
    "@ai-sdk/google": "^1.0.3",
    "@ai-sdk/openai": "catalog:",
    "@ai-sdk/provider": "^1.0.1",
    "@srcbook/shared": "workspace:^",
    "ai": "^3.4.33",
    "archiver": "^7.0.1",
    "better-sqlite3": "^11.3.0",
    "cors": "^2.8.5",
    "depcheck": "^1.4.7",
    "drizzle-orm": "^0.33.0",
    "express": "^4.20.0",
    "fast-xml-parser": "^4.5.0",
    "marked": "catalog:",
    "posthog-node": "^4.2.0",
    "simple-git": "^3.27.0",
    "ws": "catalog:",
    "zod": "catalog:"
  },
  "devDependencies": {
    "@types/archiver": "^6.0.2",
    "@types/better-sqlite3": "^7.6.11",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/ws": "^8.5.12",
    "drizzle-kit": "^0.24.2",
    "vite": "^5.4.4",
    "vite-node": "^2.0.5",
    "vitest": "^2.0.5"
  }
}

================
File: api/posthog-client.mts
================
import { PostHog } from 'posthog-node';
import { getConfig } from './config.mjs';
import { IS_PRODUCTION } from './constants.mjs';

const POSTHOG_API_KEY = 'phc_bQjmPYXmbl76j8gW289Qj9XILuu1STRnIfgCSKlxdgu';
const POSTHOG_HOST = 'https://us.i.posthog.com';

type EventType = {
  event: string;
  properties?: Record<string, any>;
};

class PostHogClient {
  private installId: string;
  private client: PostHog;

  constructor(config: { installId: string }) {
    this.installId = config.installId;
    this.client = new PostHog(POSTHOG_API_KEY, { host: POSTHOG_HOST });
  }

  private get analyticsEnabled(): boolean {
    const disabled = process.env.SRCBOOK_DISABLE_ANALYTICS || '';
    return disabled.toLowerCase() !== 'true';
  }

  private get isEnabled(): boolean {
    return this.analyticsEnabled && IS_PRODUCTION;
  }

  public capture(event: EventType): void {
    if (!this.isEnabled) {
      return;
    }

    this.client.capture({ ...event, distinctId: this.installId });
  }

  public shutdown() {
    this.client.shutdown();
  }
}

export const posthog = new PostHogClient(await getConfig());

================
File: api/processes.mts
================
import { ChildProcess } from 'node:child_process';

export class Processes {
  private processes: Record<string, ChildProcess> = {};

  add(sessionId: string, cellId: string, process: ChildProcess) {
    const key = this.toKey(sessionId, cellId);

    if (typeof process.pid !== 'number') {
      throw new Error('Cannot add a process with no pid');
    }

    if (process.killed) {
      throw new Error('Cannot add a process that has been killed');
    }

    this.processes[key] = process;

    process.on('exit', () => {
      delete this.processes[key];
    });
  }

  kill(sessionId: string, cellId: string) {
    const key = this.toKey(sessionId, cellId);

    const process = this.processes[key];

    if (!process) {
      throw new Error(
        `Cannot kill process: no process for session ${sessionId} and cell ${cellId} exists`,
      );
    }

    if (process.killed) {
      throw new Error(
        `Cannot kill process for session ${sessionId} and cell ${cellId}: process has already been killed`,
      );
    }

    return process.kill('SIGTERM');
  }

  private toKey(sessionId: string, cellId: string) {
    return sessionId + ':' + cellId;
  }
}

export default new Processes();

================
File: api/session.mts
================
import fs from 'node:fs/promises';
import Path from 'node:path';
import type {
  CellType,
  CellUpdateAttrsType,
  TitleCellType,
  MarkdownCellType,
  PackageJsonCellType,
  CodeCellType,
  CellErrorType,
} from '@srcbook/shared';
import {
  TitleCellUpdateAttrsSchema,
  MarkdownCellUpdateAttrsSchema,
  CodeCellUpdateAttrsSchema,
  PackageJsonCellUpdateAttrsSchema,
  languageFromFilename,
  extensionsForLanguage,
} from '@srcbook/shared';
import { encode, decodeDir } from './srcmd.mjs';
import { SRCBOOKS_DIR } from './constants.mjs';
import type { SessionType } from './types.mjs';
import {
  writeToDisk,
  writeCellToDisk,
  writeReadmeToDisk,
  moveCodeCellOnDisk,
} from './srcbook/index.mjs';
import { fileExists } from './fs-utils.mjs';
import { validFilename } from '@srcbook/shared';
import { pathToCodeFile } from './srcbook/path.mjs';
import { exec } from 'node:child_process';
import { npmInstall } from './exec.mjs';

const sessions: Record<string, SessionType> = {};

function findSessionByDirname(dirname: string) {
  return Object.values(sessions).find((session) => session.dir === dirname);
}

export async function createSession(srcbookDir: string) {
  const existingSession = findSessionByDirname(srcbookDir);

  if (existingSession) {
    const updatedSession = { ...existingSession, openedAt: Date.now() };
    sessions[existingSession.id] = updatedSession;
    return updatedSession;
  }

  const result = await decodeDir(srcbookDir);
  if (result.error) {
    console.error(result.errors);
    throw new Error(`Cannot create session from invalid srcbook directory at ${srcbookDir}`);
  }

  const srcbook = result.srcbook;

  const session: SessionType = {
    id: Path.basename(srcbookDir),
    dir: srcbookDir,
    cells: srcbook.cells,
    language: srcbook.language,
    openedAt: Date.now(),
  };

  if (session.language === 'typescript') {
    session['tsconfig.json'] = srcbook['tsconfig.json'];
  }

  sessions[session.id] = session;

  return session;
}

export async function deleteSessionByDirname(dirName: string) {
  const session = findSessionByDirname(dirName);
  if (session) {
    delete sessions[session.id];
  }
}

// We make sure to load sessions from the disk in addition to the ones already in memory.
export async function listSessions(): Promise<Record<string, SessionType>> {
  return sessions;
}

export async function addCell(
  session: SessionType,
  cell: MarkdownCellType | CodeCellType,
  index: number,
) {
  const cells = insertCellAt(session, cell, index);

  session.cells = cells;

  switch (cell.type) {
    case 'markdown':
      return writeReadmeToDisk(session.dir, session.language, session.cells);
    case 'code':
      return writeCellToDisk(session.dir, session.language, session.cells, cell);
  }
}

export async function updateSession(
  session: SessionType,
  updates: Partial<SessionType>,
  flush: boolean = true,
): Promise<SessionType> {
  const id = session.id;
  const updatedSession = { ...session, ...updates };
  sessions[id] = updatedSession;
  if (flush) {
    await writeToDisk(updatedSession);
  }
  return updatedSession;
}

export function exportSrcmdText(session: SessionType) {
  return encode(
    {
      cells: session.cells,
      language: session.language,
      'tsconfig.json': session['tsconfig.json'],
    },
    { inline: true },
  );
}

export async function findSession(id: string): Promise<SessionType> {
  if (!sessions[id]) {
    throw new Error(`Session with id ${id} not found`);
  }
  // explicitly known that a session exists here
  return sessions[id] as SessionType;
}

type UpdateResultType =
  | { success: true; cell: CellType }
  | { success: false; errors: CellErrorType[] };

async function updateCellWithRollback<T extends CellType>(
  session: SessionType,
  oldCell: T,
  updates: Partial<T>,
  onUpdate: (session: SessionType, cells: CellType) => Promise<CellErrorType[] | void>,
): Promise<UpdateResultType> {
  const updatedCell = { ...oldCell, ...updates };
  const cells = replaceCell(session, updatedCell);
  session.cells = cells;

  const errors = await onUpdate(session, updatedCell);

  if (errors && errors.length > 0) {
    // rollback
    const cells = replaceCell(session, oldCell);
    session.cells = cells;
    return { success: false, errors };
  } else {
    return { success: true, cell: updatedCell };
  }
}

function updateTitleCell(session: SessionType, cell: TitleCellType, updates: any) {
  const attrs = TitleCellUpdateAttrsSchema.parse(updates);
  return updateCellWithRollback(session, cell, attrs, async (session) => {
    try {
      await writeReadmeToDisk(session.dir, session.language, session.cells);
    } catch (e) {
      console.error(e);
      return [{ message: 'An error occurred persisting files to disk' }];
    }
  });
}

function updateMarkdownCell(session: SessionType, cell: MarkdownCellType, updates: any) {
  const attrs = MarkdownCellUpdateAttrsSchema.parse(updates);
  return updateCellWithRollback(session, cell, attrs, async (session) => {
    try {
      await writeReadmeToDisk(session.dir, session.language, session.cells);
    } catch (e) {
      console.error(e);
      return [{ message: 'An error occurred persisting files to disk' }];
    }
  });
}

function updatePackageJsonCell(session: SessionType, cell: PackageJsonCellType, updates: any) {
  const attrs = PackageJsonCellUpdateAttrsSchema.parse(updates);
  return updateCellWithRollback(session, cell, attrs, async (session, updatedCell) => {
    try {
      await writeCellToDisk(
        session.dir,
        session.language,
        session.cells,
        updatedCell as PackageJsonCellType,
      );
    } catch (e) {
      console.error(e);
      return [{ message: 'An error occurred persisting files to disk' }];
    }
  });
}

async function updateCodeCell(
  session: SessionType,
  cell: CodeCellType,
  updates: any,
): Promise<UpdateResultType> {
  const attrs = CodeCellUpdateAttrsSchema.parse(updates);
  return updateCellWithRollback(session, cell, { ...attrs }, async (session, updatedCell) => {
    try {
      await writeCellToDisk(
        session.dir,
        session.language,
        session.cells,
        updatedCell as CodeCellType,
      );
    } catch (e) {
      console.error(e);
      return [{ message: 'An error occurred persisting files to disk' }];
    }
  });
}

/**
 * Use this to rename a code cell's filename.
 */
export async function updateCodeCellFilename(
  session: SessionType,
  cell: CodeCellType,
  filename: string,
): Promise<UpdateResultType> {
  if (filename === cell.filename) {
    console.warn(
      `Attempted to update a cell's filename to its existing filename '${cell.filename}'. This is likely a bug in the code.`,
    );
    return { success: true, cell };
  }

  if (!validFilename(filename)) {
    return {
      success: false,
      errors: [{ message: `${filename} is not a valid filename`, attribute: 'filename' }],
    };
  }

  if (session.language !== languageFromFilename(filename)) {
    return {
      success: false,
      errors: [
        {
          message: `File must have one of the following extensions: ${extensionsForLanguage(session.language)}`,
          attribute: 'filename',
        },
      ],
    };
  }

  if (await fileExists(pathToCodeFile(session.dir, filename))) {
    return {
      success: false,
      errors: [{ message: `A file named '${filename}' already exists`, attribute: 'filename' }],
    };
  }

  return updateCellWithRollback(session, cell, { filename }, async (session, updatedCell) => {
    try {
      await moveCodeCellOnDisk(
        session.dir,
        session.language,
        session.cells,
        updatedCell as CodeCellType,
        cell.filename,
      );
    } catch (e) {
      console.error(e);
      return [{ message: 'An error occurred persisting files to disk' }];
    }
  });
}

export function updateCell(session: SessionType, cell: CellType, updates: CellUpdateAttrsType) {
  switch (cell.type) {
    case 'title':
      return updateTitleCell(session, cell, updates);
    case 'markdown':
      return updateMarkdownCell(session, cell, updates);
    case 'package.json':
      return updatePackageJsonCell(session, cell, updates);
    case 'code':
      return updateCodeCell(session, cell, updates);
  }
}
async function ensurePrettierInstalled(dir: string): Promise<boolean> {
  const prettierPath = Path.join(dir, 'node_modules', 'prettier');
  try {
    // check if prettier is installed
    await fs.access(prettierPath);
    return true;
  } catch (error) {
    return new Promise<boolean>((resolve) => {
      try {
        npmInstall({
          cwd: dir,
          packages: ['prettier'],
          args: ['--save-dev'],
          stdout: () => {},
          stderr: (err) => console.error(err),
          onExit: (exitCode) => {
            if (exitCode === 0) {
              resolve(true);
            } else {
              console.error('Failed to install Prettier:', exitCode);
              resolve(false);
            }
          },
        });
      } catch (installError) {
        console.error('Failed to initiate Prettier installation:', installError);
        resolve(false);
      }
    });
  }
}
export async function formatCode(dir: string, fileName: string) {
  try {
    await ensurePrettierInstalled(dir);

    const codeFilePath = pathToCodeFile(dir, fileName);
    const command = `npx prettier ${codeFilePath}`;

    return new Promise((resolve, reject) => {
      exec(command, async (_, stdout, stderr) => {
        if (stderr) {
          console.error(`exec error: ${stderr}`);
          reject(stderr);
          return;
        }
        resolve(stdout);
      });
    });
  } catch (error) {
    console.error('Formatting error:', error);
    throw error;
  }
}
export async function formatAndUpdateCodeCell(session: SessionType, cell: CodeCellType) {
  try {
    const formattedCode = await formatCode(session.dir, cell.filename);
    return updateCodeCell(session, cell, { source: formattedCode } as { source: string });
  } catch (error) {
    return Promise.resolve({
      success: false,
      errors: error,
    } as UpdateResultType);
  }
}
export function sessionToResponse(session: SessionType) {
  const result: Pick<SessionType, 'id' | 'cells' | 'language' | 'tsconfig.json' | 'openedAt'> = {
    id: session.id,
    cells: session.cells,
    language: session.language,
    openedAt: session.openedAt,
  };

  if (session.language === 'typescript') {
    result['tsconfig.json'] = session['tsconfig.json'];
  }

  return result;
}

export async function readPackageJsonContentsFromDisk(session: SessionType) {
  return fs.readFile(Path.join(session.dir, 'package.json'), { encoding: 'utf8' });
}

export function findCell(session: SessionType, id: string) {
  return session.cells.find((cell) => cell.id === id);
}

export function replaceCell(session: SessionType, cell: CellType) {
  return session.cells.map((c) => (c.id === cell.id ? cell : c));
}

export function insertCellAt(session: SessionType, cell: CellType, index: number) {
  const cells = [...session.cells];
  cells.splice(index, 0, cell);
  return cells;
}

export function removeCell(session: SessionType, id: string) {
  return session.cells.filter((cell) => cell.id !== id);
}

async function load() {
  const srcbookDirs = await fs.readdir(SRCBOOKS_DIR, { withFileTypes: true });
  const loadedSessions = srcbookDirs
    .filter((entry) => entry.isDirectory())
    .map(async (entry) => {
      // .path -> .parentPath from node21 onwards.
      const parentPath = entry.parentPath || entry.path;
      try {
        const session = await createSession(Path.join(parentPath, entry.name));
        sessions[session.id] = session;
        return session;
      } catch (e) {
        console.error(
          `Error loading session from ${entry.name}: ${(e as Error).message}. Skipping...`,
        );
      }
    });

  await Promise.all(loadedSessions);
}

// Initialize sessions on boot
await load();

================
File: api/srcmd.mts
================
import fs from 'node:fs/promises';
import {
  pathToCodeFile,
  pathToPackageJson,
  pathToReadme,
  pathToTsconfigJson,
} from './srcbook/path.mjs';
import type { DecodeResult } from './srcmd/types.mjs';

import { encode } from './srcmd/encoding.mjs';
import { decode, decodeCells } from './srcmd/decoding.mjs';

export { encode, decode, decodeCells };

/**
 * Decode a compatible directory into a set of cells.
 *
 * The directory must contain a README.md file and a package.json file.
 * We assume the README.md file contains the srcbook content, in particular
 * the first 2 cells should be a title cell and then a package.json.cell
 *
 * We leverage the decode() function first to decode the README.md file, and then
 * we replace the contents of the referenced package.json and code files into the cells.
 */
export async function decodeDir(dir: string): Promise<DecodeResult> {
  try {
    const readmePath = pathToReadme(dir);
    const readmeContents = await fs.readFile(readmePath, 'utf-8');
    // Decode the README.md file into cells.
    // The code blocks and the package.json will only contain the filename at this point,
    // the actual source for each file will be read from the file system in the next step.
    const readmeResult = decode(readmeContents);

    if (readmeResult.error) {
      return readmeResult;
    }

    const srcbook = readmeResult.srcbook;

    const cells = srcbook.cells;
    const pendingFileReads: Promise<void>[] = [];

    // Let's replace all the code cells with the actual file contents for each one
    for (const cell of cells) {
      if (cell.type === 'code' || cell.type === 'package.json') {
        const filePath =
          cell.type === 'package.json'
            ? pathToPackageJson(dir)
            : pathToCodeFile(dir, cell.filename);

        pendingFileReads.push(
          fs.readFile(filePath, 'utf-8').then((source) => {
            cell.source = source;
          }),
        );
      }
    }

    // Wait for all file reads to complete
    await Promise.all(pendingFileReads);

    if (srcbook.language === 'typescript') {
      const tsconfig = await fs.readFile(pathToTsconfigJson(dir), 'utf8');
      return {
        error: false,
        srcbook: { language: srcbook.language, cells, 'tsconfig.json': tsconfig },
      };
    } else {
      return { error: false, srcbook: { language: srcbook.language, cells } };
    }
  } catch (e) {
    const error = e as unknown as Error;
    return { error: true, errors: [error.message] };
  }
}

================
File: api/tsconfig.json
================
{
  "extends": "@srcbook/configs/ts/base.json",
  "compilerOptions": {
    "noEmit": false,
    "allowImportingTsExtensions": false,
    "outDir": "dist",
    "types": ["vitest/globals", "vite/client"]
  },
  "include": ["**/*.mts"],
  "exclude": ["node_modules", "dist"]
}

================
File: api/tsconfig.lint.json
================
{
  "include": ["**/*.mts", "vite.config.ts", "drizzle.config.ts", "vite-env.d.ts"],
  "exclude": ["node_modules", "dist"]
}

================
File: api/tsservers.mts
================
import { TsServers } from './tsserver/tsservers.mjs';

export default new TsServers();

================
File: api/types.mts
================
import type { CellType, CodeLanguageType } from '@srcbook/shared';

export type SessionType = {
  id: string;
  /**
   * Path to the directory containing the srcbook files.
   */
  dir: string;
  cells: CellType[];

  /**
   * The language of the srcbook, i.e.: 'typescript' or 'javascript'
   */
  language: CodeLanguageType;

  /**
   * The tsconfig.json file contents.
   */
  'tsconfig.json'?: string;

  /**
   * Replace this with updatedAt once we store srcbooks in sqlite
   */
  openedAt: number;
};

================
File: api/utils.mts
================
export function take<T extends object, K extends keyof T>(obj: T, ...keys: Array<K>): Pick<T, K> {
  const result = {} as Pick<T, K>;

  for (const key of Object.keys(obj) as K[]) {
    if (keys.includes(key)) {
      result[key] = obj[key];
    }
  }

  return result;
}

export function toFormattedJSON(o: any) {
  return JSON.stringify(o, null, 2);
}

================
File: api/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: api/vite.config.ts
================
/// <reference types="vitest" />
import { defineConfig } from 'vite';

export default defineConfig({
  test: {
    include: ['test/**/*.test.mts'],
    globals: true,
  },
  server: {
    hmr: true,
  },
});

================
File: components/src/components/cells/code.tsx
================
/* eslint-disable jsx-a11y/tabindex-no-positive -- this should be fixed and reworked or minimize excessive positibe tabindex */

import { useCallback, useEffect, useRef, useState } from 'react';
import { Dialog, DialogContent } from '../ui/dialog.js';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '../ui/tooltip.js';
import Shortcut from '../keyboard-shortcut.js';
import { useNavigate } from 'react-router-dom';
import CodeMirror from '@uiw/react-codemirror';
import { javascript } from '@codemirror/lang-javascript';
import { ResizableHandle, ResizablePanel, ResizablePanelGroup } from '../ui/resizable.js';
import {
  Info,
  Play,
  Trash2,
  Sparkles,
  X,
  MessageCircleWarning,
  LoaderCircle,
  Maximize,
  Minimize,
  CopyIcon,
} from 'lucide-react';
import TextareaAutosize from 'react-textarea-autosize';
import AiGenerateTipsDialog from '../ai-generate-tips-dialog.js';
import { CellType, CodeCellType, CodeCellUpdateAttrsType } from '@srcbook/shared';
import { cn } from '../../lib/utils.js';
import { CellModeType, SessionType } from '../../types';
import { Button } from '../ui/button.js';
import { Input } from '../ui/input.js';
import DeleteCellWithConfirmation from '../delete-cell-dialog';
import { CellOutput } from '../cell-output.js';
import useTheme from '../use-theme.js';
import { useDebouncedCallback } from 'use-debounce';
import { EditorView } from 'codemirror';
import { EditorState, Extension } from '@codemirror/state';
import { unifiedMergeView } from '@codemirror/merge';
import { toast } from 'sonner';
import { PrettierLogo } from '../logos.js';
import { useCells } from '../use-cell.js';

const DEBOUNCE_DELAY = 500;

type BaseProps = {
  session: SessionType;
  cell: CodeCellType;
  codeTheme: Extension;
};

type RegularProps = BaseProps & {
  readOnly?: false;
  aiEnabled: boolean;
  aiFixDiagnostics: (diagnostics: string) => void;
  cellMode: CellModeType;
  filenameError: string | null;
  fixDiagnostics: (diagnostics: string) => void;
  fullscreen: boolean;
  generationType: 'edit' | 'fix';
  newSource: string;
  onAccept: () => void;
  onChangeCellModeType: (newCellMode: CellModeType) => void;
  onChangeFilenameError: (newError: string | null) => void;
  onChangeFullscreen: (value: boolean) => void;
  onChangeGenerationType: (newGenerationType: 'edit' | 'fix') => void;
  onChangeNewSource: (newSource: string) => void;
  onChangePrompt: (newPrompt: string) => void;
  onChangeShowStdio: (showStdio: boolean) => void;
  onDeleteCell: (cell: CellType) => void;
  onFormatCell: () => void;
  onGenerate: () => void;
  onGetDefinitionContents: (pos: number, cell: CodeCellType) => Promise<string>;
  onRevert: () => void;
  onRunCell: () => void;
  onStopCell: () => void;
  onUpdateFileName: (filename: string) => void;
  prompt: string;
  showStdio: boolean;
  updateCellOnServer: (cell: CodeCellType, attrs: CodeCellUpdateAttrsType) => void;
  editorExtensions: Array<Extension>;
};
type ReadOnlyProps = BaseProps & { readOnly: true };
type Props = RegularProps | ReadOnlyProps;

export default function CodeCell(props: Props) {
  return (
    <div id={`cell-${props.cell.id}`}>
      {!props.readOnly ? (
        <Dialog open={props.fullscreen} onOpenChange={props.onChangeFullscreen}>
          <DialogContent
            className={cn(
              `w-[95vw] h-[95vh] max-w-none p-0 group flex flex-col`,
              props.cell.status === 'running' && 'ring-1 ring-run-ring border-run-ring',
              (props.cellMode === 'generating' || props.cellMode === 'fixing') &&
                'ring-1 ring-ai-ring border-ai-ring',
              props.cell.status !== 'running' &&
                props.cellMode !== 'generating' &&
                props.cellMode !== 'fixing' &&
                'focus-within:ring-1 focus-within:ring-ring focus-within:border-ring',
            )}
            hideClose
          >
            <Header
              cell={props.cell}
              runCell={props.onRunCell}
              stopCell={props.onStopCell}
              onDeleteCell={!props.readOnly ? props.onDeleteCell : null}
              generate={props.onGenerate}
              cellMode={props.cellMode}
              setCellMode={props.onChangeCellModeType}
              prompt={props.prompt}
              setPrompt={props.onChangePrompt}
              updateFilename={props.onUpdateFileName}
              filenameError={props.filenameError}
              setFilenameError={props.onChangeFilenameError}
              fullscreen={props.fullscreen}
              setFullscreen={props.onChangeFullscreen}
              setShowStdio={props.onChangeShowStdio}
              onAccept={props.onAccept}
              onRevert={props.onRevert}
              formatCell={props.onFormatCell}
              aiEnabled={!props.readOnly ? props.aiEnabled : false}
            />

            {props.cellMode === 'reviewing' ? (
              <DiffEditor original={props.cell.source} modified={props.newSource} />
            ) : (
              <ResizablePanelGroup direction="vertical">
                <ResizablePanel style={{ overflow: 'scroll' }} defaultSize={60}>
                  <div
                    className={cn(props.cellMode !== 'off' && 'opacity-50')}
                    id={props.cell.filename}
                  >
                    <CodeEditor
                      cell={props.cell}
                      extensions={props.editorExtensions}
                      codeTheme={props.codeTheme}
                      updateCellOnServer={props.updateCellOnServer}
                    />
                  </div>
                </ResizablePanel>

                <ResizableHandle withHandle className="border-none" />
                <ResizablePanel defaultSize={40} style={{ overflow: 'scroll' }}>
                  <CellOutput
                    cell={props.cell}
                    show={props.showStdio}
                    setShow={props.onChangeShowStdio}
                    fullscreen={props.fullscreen}
                    setFullscreen={props.onChangeFullscreen}
                    fixDiagnostics={props.aiFixDiagnostics}
                    cellMode={props.cellMode}
                    aiEnabled={props.aiEnabled}
                  />
                </ResizablePanel>
              </ResizablePanelGroup>
            )}
          </DialogContent>
        </Dialog>
      ) : null}

      <div className="relative group/cell" id={`cell-${props.cell.id}`}>
        <div
          className={cn(
            'border rounded-md group',
            props.cell.status === 'running' && 'ring-1 ring-run-ring border-run-ring',
            !props.readOnly &&
              (props.cellMode === 'generating' || props.cellMode === 'fixing') &&
              'ring-1 ring-ai-ring border-ai-ring',
            !props.readOnly &&
              props.cell.status !== 'running' &&
              props.cellMode !== 'generating' &&
              props.cellMode !== 'fixing' &&
              'focus-within:ring-1 focus-within:ring-ring focus-within:border-ring',
          )}
        >
          {props.readOnly ? (
            <div className="p-1 flex items-center justify-between gap-2">
              <div className="flex items-center gap-1">
                <span className="w-[200px] font-mono font-semibold text-xs transition-colors px-2">
                  {props.cell.filename}
                </span>
              </div>
              <div className="opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition-opacity flex gap-2">
                <div className="flex items-center gap-1">
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <Button
                          variant="icon"
                          className="w-8 px-0"
                          size="icon"
                          onClick={() => {
                            navigator.clipboard.writeText(props.cell.source);
                            toast.success('Copied to clipboard.');
                          }}
                          tabIndex={1}
                        >
                          <CopyIcon size={16} />
                        </Button>
                      </TooltipTrigger>
                      <TooltipContent>Copy to clipboard</TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                </div>
              </div>
            </div>
          ) : (
            <Header
              cell={props.cell}
              runCell={props.onRunCell}
              stopCell={props.onStopCell}
              onDeleteCell={!props.readOnly ? props.onDeleteCell : null}
              generate={props.onGenerate}
              cellMode={props.cellMode}
              setCellMode={props.onChangeCellModeType}
              prompt={props.prompt}
              setPrompt={props.onChangePrompt}
              updateFilename={props.onUpdateFileName}
              filenameError={props.filenameError}
              setFilenameError={props.onChangeFilenameError}
              fullscreen={props.fullscreen}
              setFullscreen={props.onChangeFullscreen}
              setShowStdio={props.onChangeShowStdio}
              onAccept={props.onAccept}
              onRevert={props.onRevert}
              formatCell={props.onFormatCell}
              aiEnabled={props.aiEnabled}
            />
          )}

          {!props.readOnly && props.cellMode === 'reviewing' ? (
            <DiffEditor original={props.cell.source} modified={props.newSource} />
          ) : (
            <>
              <div
                className={cn(!props.readOnly && props.cellMode !== 'off' && 'opacity-50')}
                id={props.cell.filename}
              >
                {props.readOnly ? (
                  <CodeEditor cell={props.cell} extensions={[]} codeTheme={props.codeTheme} />
                ) : (
                  <CodeEditor
                    // FIXME: make sure that the changes this should be causing in `props.editorExtensions` actually are working
                    cell={props.cell}
                    updateCellOnServer={props.updateCellOnServer}
                    extensions={props.editorExtensions}
                    codeTheme={props.codeTheme}
                  />
                )}
              </div>
              {!props.readOnly ? (
                <CellOutput
                  cell={props.cell}
                  show={props.showStdio}
                  setShow={props.onChangeShowStdio}
                  fixDiagnostics={props.aiFixDiagnostics}
                  cellMode={props.cellMode}
                  fullscreen={props.fullscreen}
                  setFullscreen={props.onChangeFullscreen}
                  aiEnabled={props.aiEnabled}
                />
              ) : null}
            </>
          )}
        </div>
      </div>
    </div>
  );
}

function Header(props: {
  cell: CodeCellType;
  runCell: () => void;
  onDeleteCell: ((cell: CellType) => void) | null;
  cellMode: CellModeType;
  setCellMode: (mode: CellModeType) => void;
  updateFilename: (filename: string) => void;
  filenameError: string | null;
  setFilenameError: (error: string | null) => void;
  fullscreen: boolean;
  setFullscreen: (open: boolean) => void;
  setShowStdio: (open: boolean) => void;
  generate: () => void;
  prompt: string;
  setPrompt: (prompt: string) => void;
  stopCell: () => void;
  onAccept: () => void;
  onRevert: () => void;
  formatCell: () => void;
  aiEnabled: boolean;
}) {
  const {
    cell,
    runCell,
    onDeleteCell,
    cellMode,
    setCellMode,
    updateFilename,
    filenameError,
    setFilenameError,
    fullscreen,
    setFullscreen,
    setShowStdio,
    generate,
    prompt,
    setPrompt,
    stopCell,
    formatCell,
    aiEnabled,
  } = props;

  const navigate = useNavigate();

  return (
    <>
      <div className="p-1 flex items-center justify-between gap-2">
        <div className={cn('flex items-center gap-1', cellMode !== 'off' && 'opacity-50')}>
          <FilenameInput
            filename={cell.filename}
            onUpdate={updateFilename}
            onChange={() => setFilenameError(null)}
            className={cn(
              'w-[200px] font-mono font-semibold text-xs transition-colors px-2',
              filenameError
                ? 'border-error'
                : 'border-transparent hover:border-input group-hover:border-input ',
            )}
          />
          {filenameError && (
            <div className="bg-error text-error-foreground flex items-center rounded-sm border border-transparent px-[10px] py-2 text-sm leading-none font-medium">
              <Info size={14} className="mr-1.5" />
              Invalid filename
            </div>
          )}
          {onDeleteCell !== null ? (
            <DeleteCellWithConfirmation onDeleteCell={() => onDeleteCell(cell)}>
              <Button className="hidden group-hover:flex" variant="icon" size="icon" tabIndex={1}>
                <Trash2 size={16} />
              </Button>
            </DeleteCellWithConfirmation>
          ) : (
            <Button className="hidden group-hover:flex" variant="icon" size="icon" disabled>
              <Trash2 size={16} />
            </Button>
          )}
        </div>
        <div
          className={cn(
            'opacity-0 group-hover:opacity-100 group-focus-within:opacity-100 transition-opacity flex gap-2',

            cell.status === 'running' ||
              cellMode === 'fixing' ||
              cellMode === 'generating' ||
              cellMode === 'reviewing'
              ? 'opacity-100'
              : '',
          )}
        >
          <div className="flex items-center gap-1">
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="icon"
                    size="icon"
                    disabled={cellMode !== 'off'}
                    onClick={formatCell}
                    tabIndex={1}
                  >
                    <PrettierLogo size={14} />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>Format using Prettier</TooltipContent>
              </Tooltip>
            </TooltipProvider>
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="icon"
                    className="w-8 px-0"
                    size="icon"
                    onClick={() => {
                      // Open stdout drawer in fullscreen mode.
                      if (!fullscreen) setShowStdio(true);
                      setFullscreen(!fullscreen);
                    }}
                    tabIndex={1}
                  >
                    {fullscreen ? <Minimize size={16} /> : <Maximize size={16} />}
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  {fullscreen ? 'Minimize back to cells view' : 'Maximize to full screen'}
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="icon"
                    size="icon"
                    disabled={cellMode !== 'off'}
                    onClick={() => setCellMode('prompting')}
                    tabIndex={1}
                  >
                    <Sparkles size={16} />
                  </Button>
                </TooltipTrigger>
                <TooltipContent>Edit cell using AI</TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
          {cellMode === 'prompting' && (
            <Button variant="default" onClick={generate} tabIndex={1} disabled={!aiEnabled}>
              Generate
            </Button>
          )}
          {cellMode === 'generating' && (
            <Button
              variant="ai"
              size="default-with-icon"
              className="disabled:opacity-100"
              disabled
              tabIndex={1}
            >
              <LoaderCircle size={16} className="animate-spin" /> Generating
            </Button>
          )}
          {cellMode === 'fixing' && (
            <Button
              variant="ai"
              size="default-with-icon"
              className="disabled:opacity-100"
              disabled
              tabIndex={1}
            >
              <LoaderCircle size={16} className="animate-spin" /> Fixing...
            </Button>
          )}
          {cellMode === 'reviewing' && (
            <div className="flex items-center gap-2">
              <Button variant="secondary" onClick={props.onRevert}>
                Revert
              </Button>
              <Button onClick={props.onAccept}>Accept</Button>
            </div>
          )}
          {['off', 'formatting'].includes(cellMode) && (
            <>
              {cell.status === 'running' && (
                <Button variant="run" size="default-with-icon" onClick={stopCell} tabIndex={1}>
                  <LoaderCircle size={16} className="animate-spin" /> Stop
                </Button>
              )}
              {cell.status === 'idle' && (
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button size="default-with-icon" onClick={runCell} tabIndex={1}>
                        <Play size={16} />
                        Run
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>
                      <Shortcut keys={['mod', 'enter']} /> to run cell
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              )}
            </>
          )}
        </div>
      </div>
      {['prompting', 'generating'].includes(cellMode) && (
        <div className="flex flex-col gap-1.5">
          <div className="flex items-start justify-between px-1">
            <div className="flex items-start flex-grow">
              <Sparkles size={16} className="m-2.5" />
              <TextareaAutosize
                className="flex w-full rounded-sm bg-transparent px-3 py-2 text-sm placeholder:text-muted-foreground focus-visible:outline-none resize-none"
                // eslint-disable-next-line jsx-a11y/no-autofocus -- needed for action flow, should not limit accessibility
                autoFocus
                placeholder="Ask the AI to edit this cell..."
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
              />
            </div>
            <div className="flex items-center gap-1">
              <AiGenerateTipsDialog>
                <Button size="icon" variant="icon">
                  <MessageCircleWarning size={16} />
                </Button>
              </AiGenerateTipsDialog>
              <Button
                size="icon"
                variant="icon"
                onClick={() => {
                  setCellMode('off');
                  setPrompt('');
                }}
              >
                <X size={16} />
              </Button>
            </div>
          </div>

          {!aiEnabled && (
            <div className="flex items-center justify-between bg-warning text-warning-foreground rounded-sm text-sm px-3 py-1 m-3">
              <p>AI provider not configured.</p>
              <button
                className="font-medium underline cursor-pointer"
                onClick={() => navigate('/settings')}
              >
                Settings
              </button>
            </div>
          )}
        </div>
      )}
    </>
  );
}

type CodeEditorProps = {
  cell: CodeCellType;
  extensions: Array<Extension>;
  codeTheme: Extension;
  updateCellOnServer?: (cell: CodeCellType, attrs: CodeCellUpdateAttrsType) => void;
};

function CodeEditor({ cell, extensions, codeTheme, updateCellOnServer }: CodeEditorProps) {
  const { updateCell: updateCellOnClient } = useCells();

  const updateCellOnServerOrNoop = useCallback<NonNullable<typeof updateCellOnServer>>(
    (cell, attrs) => {
      if (!updateCellOnServer) {
        return;
      }
      updateCellOnServer(cell, attrs);
    },
    [updateCellOnServer],
  );
  const updateCellOnServerDebounced = useDebouncedCallback(
    updateCellOnServerOrNoop,
    DEBOUNCE_DELAY,
  );

  return (
    <CodeMirror
      value={cell.source}
      theme={codeTheme}
      extensions={extensions}
      onChange={(source) => {
        updateCellOnClient({ ...cell, source });
        updateCellOnServerDebounced(cell, { source });
      }}
    />
  );
}

function DiffEditor({ original, modified }: { original: string; modified: string }) {
  const { codeTheme } = useTheme();

  return (
    <div className="flex flex-col">
      <CodeMirror
        value={modified}
        theme={codeTheme}
        extensions={[
          javascript({ typescript: true }),
          EditorView.editable.of(false),
          EditorState.readOnly.of(true),
          unifiedMergeView({
            original: original,
            mergeControls: false,
            highlightChanges: false,
          }),
        ]}
      />
    </div>
  );
}

function FilenameInput(props: {
  filename: string;
  className: string;
  onUpdate: (filename: string) => void;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
}) {
  const onUpdate = props.onUpdate;
  const onChange = props.onChange;

  const inputRef = useRef<HTMLInputElement | null>(null);

  const [filename, setFilename] = useState(props.filename);

  useEffect(() => {
    if (filename !== props.filename) {
      setFilename(props.filename);
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [props.filename]);

  function submit() {
    if (props.filename !== filename) {
      onUpdate(filename);
    }
  }

  function blurOnEnter(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === 'Enter') {
      inputRef.current?.blur();
    }
  }

  return (
    <Input
      required
      ref={inputRef}
      value={filename}
      onBlur={submit}
      onKeyDown={blurOnEnter}
      onChange={(e) => {
        setFilename(e.target.value);
        onChange(e);
      }}
      className={props.className}
    />
  );
}

================
File: components/src/components/cells/markdown.tsx
================
import { useEffect, useState } from 'react';
import { marked } from 'marked';
import mermaid from 'mermaid';
import Markdown from 'marked-react';
import CodeMirror, { keymap, Prec, EditorView } from '@uiw/react-codemirror';
import { markdown } from '@codemirror/lang-markdown';
import { CircleAlert, Trash2, Pencil } from 'lucide-react';
import { CellType, MarkdownCellType, MarkdownCellUpdateAttrsType } from '@srcbook/shared';
import { cn } from '../../lib/utils.js';
import { Button } from '../ui/button.js';
import DeleteCellWithConfirmation from '../delete-cell-dialog.js';
import useTheme from '../use-theme.js';

marked.use({ gfm: true });

const MERMAID_LIGHT_OVERRIDES = {
  background: '#FFFFFF', // bg-background // Other colors (eg line color) are derived from this
  primaryColor: '#FBFCFD', // bg-muted
  primaryBorderColor: '#D8DBDD', // bg-border
  primaryTextColor: '#38464F', // text-foreground
};

const MERMAID_DARK_OVERRIDES = {
  background: '#20282D', // bg-background // Other colors (eg line color) are derived from this
  primaryColor: '#293239', // bg-muted
  primaryBorderColor: '#38464F', // bg-border
  primaryTextColor: '#FFFFFF', // text-foreground
};

const markdownRenderer = {
  code(snippet: React.ReactNode, lang: string) {
    if (lang === 'mermaid') {
      return (
        <pre className="mermaid !bg-background" key={String(snippet)}>
          {snippet}
        </pre>
      );
    }

    return (
      <pre key={String(snippet)}>
        <code>{snippet}</code>
      </pre>
    );
  },
};

function getValidationError(text: string) {
  const tokens = marked.lexer(text);
  const hasH1 = tokens?.some((token) => token.type === 'heading' && token.depth === 1);
  const hasH6 = tokens?.some((token) => token.type === 'heading' && token.depth === 6);

  if (hasH1 || hasH6) {
    return 'Markdown cells cannot use h1 or h6 headings, these are reserved for srcbook.';
  }

  return null;
}

type MarkdownCellProps =
  | { readOnly: true; cell: MarkdownCellType }
  | {
      readOnly?: false;
      cell: MarkdownCellType;
      updateCellOnClient: (cell: MarkdownCellType) => void;
      updateCellOnServer: (cell: MarkdownCellType, attrs: MarkdownCellUpdateAttrsType) => void;
      onDeleteCell: (cell: CellType) => void;
    };

export default function MarkdownCell(props: MarkdownCellProps) {
  const { codeTheme, theme } = useTheme();
  const { readOnly, cell } = props;
  const defaultState = cell.text ? 'view' : 'edit';
  const [status, setStatus] = useState<'edit' | 'view'>(defaultState);
  const [text, setText] = useState(cell.text);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (status === 'edit') {
      setText(cell.text);
    }
  }, [status, cell.text]);

  // Initializes mermaid and updates it on theme change
  useEffect(() => {
    mermaid.initialize({
      startOnLoad: false,
      theme: 'base',
      fontFamily: 'Instrument Sans',
      darkMode: theme === 'dark',
      themeVariables: theme === 'dark' ? MERMAID_DARK_OVERRIDES : MERMAID_LIGHT_OVERRIDES,
    });
  }, [theme]);

  // Rerenders mermaid diagrams when the cell is in view mode
  useEffect(() => {
    if (status === 'view') {
      mermaid.run();
    }
  }, [status]);

  const keyMap = Prec.highest(
    keymap.of(
      !readOnly
        ? [
            {
              key: 'Mod-Enter',
              run: () => {
                onSave();
                return true;
              },
            },
            {
              key: 'Escape',
              run: () => {
                setStatus('view');
                return true;
              },
            },
          ]
        : [],
    ),
  );

  function onSave() {
    if (readOnly) {
      return;
    }
    const error = getValidationError(text);

    setError(error);

    if (error === null) {
      props.updateCellOnClient({ ...cell, text });
      props.updateCellOnServer(cell, { text });
      setStatus('view');
      return true;
    }
  }

  const deleteButton = !readOnly ? (
    <DeleteCellWithConfirmation onDeleteCell={() => props.onDeleteCell(cell)}>
      <Button variant="secondary" size="icon" className="border-transparent">
        <Trash2 size={16} />
      </Button>
    </DeleteCellWithConfirmation>
  ) : null;

  return (
    <div
      id={`cell-${cell.id}`}
      onDoubleClick={() => {
        if (readOnly) {
          return;
        }
        setStatus('edit');
      }}
      className={cn(
        'group/cell relative w-full rounded-md border border-transparent hover:border-border transition-all',
        status === 'edit' && 'ring-1 ring-ring border-ring hover:border-ring',
        error && 'ring-1 ring-sb-red-30 border-sb-red-30 hover:border-sb-red-30',
      )}
    >
      {status === 'view' ? (
        <div className="flex flex-col">
          <div className="p-1 w-full h-10 hidden group-hover/cell:flex items-center justify-between z-10">
            <div className="flex items-center gap-2">
              <h5 className="pl-2 text-sm font-mono font-bold">Markdown</h5>
              {deleteButton}
            </div>
            <div className="flex items-center gap-1">
              {!readOnly ? (
                <Button
                  variant="secondary"
                  size="icon"
                  className="border-transparent"
                  onClick={() => setStatus('edit')}
                >
                  <Pencil size={16} />
                </Button>
              ) : null}
            </div>
          </div>
          <div className="sb-prose p-3 group-hover/cell:pt-0">
            <Markdown renderer={markdownRenderer}>{cell.text}</Markdown>
          </div>
        </div>
      ) : (
        <>
          {error && (
            <div className="flex items-center gap-2 absolute bottom-1 right-1 px-2.5 py-2 text-sb-red-80 bg-sb-red-30 rounded-sm">
              <CircleAlert size={16} />
              <p className="text-xs">{error}</p>
            </div>
          )}
          <div className="flex flex-col">
            <div className="p-1 w-full flex items-center justify-between z-10">
              <div className="flex items-center gap-2">
                <h5 className="pl-2 text-sm font-mono font-bold">Markdown</h5>
                {deleteButton}
              </div>
              <div className="flex items-center gap-1">
                <Button variant="secondary" onClick={() => setStatus('view')}>
                  Cancel
                </Button>

                <Button onClick={onSave}>Save</Button>
              </div>
            </div>

            <div className="px-3">
              <CodeMirror
                theme={codeTheme}
                indentWithTab={false}
                value={text}
                basicSetup={{ lineNumbers: false, foldGutter: false }}
                extensions={[markdown(), keyMap, EditorView.lineWrapping]}
                onChange={setText}
              />
            </div>
          </div>
        </>
      )}
    </div>
  );
}

================
File: components/src/components/cells/title.tsx
================
import { TitleCellType, TitleCellUpdateAttrsType } from '@srcbook/shared';
import { EditableH1 } from '../ui/heading.js';

type BaseProps = {
  cell: TitleCellType;
};
type RegularProps = BaseProps & {
  readOnly?: false;
  updateCellOnClient: (cell: TitleCellType) => void;
  updateCellOnServer: (cell: TitleCellType, attrs: TitleCellUpdateAttrsType) => void;
};
type ReadOnlyProps = BaseProps & { readOnly: true };

export default function TitleCell(props: RegularProps | ReadOnlyProps) {
  function updateCell(text: string) {
    if (props.readOnly) {
      return;
    }
    props.updateCellOnClient({ ...props.cell, text });
    props.updateCellOnServer(props.cell, { text });
  }

  return (
    <div id={`cell-${props.cell.id}`} className="mb-4">
      {props.readOnly ? (
        <h1 className="title">{props.cell.text}</h1>
      ) : (
        <EditableH1 text={props.cell.text} className="title" onUpdated={updateCell} />
      )}
    </div>
  );
}

================
File: components/src/components/ui/button.tsx
================
import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '../../lib/utils.js';

const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-sm text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 active:translate-y-0.5',
  {
    variants: {
      variant: {
        default:
          'bg-primary border border-primary text-primary-foreground hover:bg-primary-hover disabled:opacity-100 disabled:bg-muted disabled:text-muted-foreground disabled:border-muted-foreground',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        run: 'bg-run text-run-foreground border border-run hover:bg-sb-yellow-30',
        ai: 'bg-ai-btn text-sb-core-0 border-ai-btn hover:bg-ai-btn/90',
        'ai-secondary':
          'bg-secondary text-ai-ring border border-ai-ring hover:bg-muted hover:text-ai-foreground',
        secondary:
          'bg-secondary text-secondary-foreground border border-border hover:bg-muted hover:text-secondary-hover',
        link: 'text-primary underline-offset-4 hover:underline',
        ghost: 'border border-transparent hover:bg-sb-core-20 dark:hover:bg-sb-core-110',
        icon: 'bg-transparent text-secondary-foreground hover:bg-muted',
      },
      size: {
        default: 'h-8 px-3 py-2',
        'default-with-icon': 'h-8 pl-[0.625rem] pr-3 py-2 gap-1.5',
        sm: 'h-6 rounded-sm px-3 text-xs',
        lg: 'rounded-md px-3 py-2',
        icon: 'h-8 w-8',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button';
    return (
      <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />
    );
  },
);
Button.displayName = 'Button';

export { Button, buttonVariants };

================
File: components/src/components/ui/card.tsx
================
import * as React from 'react';

import { cn } from '../../lib/utils.js';

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn('rounded-xl border bg-card text-card-foreground shadow', className)}
      {...props}
    />
  ),
);
Card.displayName = 'Card';

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('flex flex-col space-y-1.5 p-6', className)} {...props} />
  ),
);
CardHeader.displayName = 'CardHeader';

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    // eslint-disable-next-line jsx-a11y/heading-has-content
    <h3
      ref={ref}
      className={cn('font-semibold leading-none tracking-tight', className)}
      {...props}
    />
  ),
);
CardTitle.displayName = 'CardTitle';

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p ref={ref} className={cn('text-sm text-muted-foreground', className)} {...props} />
));
CardDescription.displayName = 'CardDescription';

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
  ),
);
CardContent.displayName = 'CardContent';

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn('flex items-center p-6 pt-0', className)} {...props} />
  ),
);
CardFooter.displayName = 'CardFooter';

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };

================
File: components/src/components/ui/collapsible.tsx
================
import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleTrigger, CollapsibleContent };

================
File: components/src/components/ui/command.tsx
================
import * as React from 'react';
import { type DialogProps } from '@radix-ui/react-dialog';
import { MagnifyingGlassIcon } from '@radix-ui/react-icons';
import { Command as CommandPrimitive } from 'cmdk';

import { cn } from '../../lib/utils.js';
import { Dialog, DialogContent } from './dialog.js';

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      'flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground',
      className,
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <MagnifyingGlassIcon className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        'flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn('max-h-[300px] overflow-y-auto overflow-x-hidden', className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty ref={ref} className="py-6 text-center text-sm" {...props} />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      'overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground',
      className,
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 h-px bg-border', className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50',
      className,
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest text-muted-foreground', className)}
      {...props}
    />
  );
};
CommandShortcut.displayName = 'CommandShortcut';

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
};

================
File: components/src/components/ui/context-menu.tsx
================
import * as React from 'react';
import * as ContextMenuPrimitive from '@radix-ui/react-context-menu';
import { CheckIcon, ChevronRightIcon, DotFilledIcon } from '@radix-ui/react-icons';

import { cn } from '../../lib/utils';

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground',
      inset && 'pl-8',
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className,
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-sm border bg-popover py-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className,
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-xs px-2 py-1.5 text-sm outline-none focus:bg-muted data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className,
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName = ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <DotFilledIcon className="h-4 w-4 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold text-foreground', inset && 'pl-8', className)}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-border', className)}
    {...props}
  />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn('ml-auto text-xs tracking-widest text-muted-foreground', className)}
      {...props}
    />
  );
};
ContextMenuShortcut.displayName = 'ContextMenuShortcut';

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
};

================
File: components/src/components/ui/dialog.tsx
================
import * as React from 'react';
import * as DialogPrimitive from '@radix-ui/react-dialog';
import { Cross2Icon } from '@radix-ui/react-icons';

import { cn } from '../../lib/utils.js';

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      'fixed inset-0 z-50 bg-sb-core-130/90 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> & { hideClose?: boolean }
>(({ className, children, hideClose, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        'focus-within:outline-none fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-xl duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-md',
        className,
      )}
      {...props}
    >
      {children}
      {!hideClose && (
        <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
          <Cross2Icon className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      )}
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('flex flex-col space-y-1.5 text-center sm:text-left', className)} {...props} />
);
DialogHeader.displayName = 'DialogHeader';

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
);
DialogFooter.displayName = 'DialogFooter';

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn('h5 leading-none tracking-tight', className)}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn('text-sm text-tertiary-foreground', className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
};

================
File: components/src/components/ui/dropdown-menu.tsx
================
'use client';

import * as React from 'react';
import * as DropdownMenuPrimitive from '@radix-ui/react-dropdown-menu';
import { Check, ChevronRight, Circle } from 'lucide-react';

import { cn } from '../../lib/utils.js';

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      'flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-primary data-[state=open]:bg-accent',
      inset && 'pl-8',
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName = DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        'z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-primary focus:text-primary-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      inset && 'pl-8',
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-primary focus:text-primary-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      'relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-primary focus:text-primary-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold', inset && 'pl-8', className)}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({ className, ...props }: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span className={cn('ml-auto text-xs tracking-widest opacity-60', className)} {...props} />
  );
};
DropdownMenuShortcut.displayName = 'DropdownMenuShortcut';

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};

================
File: components/src/components/ui/heading.tsx
================
import { useRef, useState } from 'react';

import { cn } from '../../lib/utils.js';
import { TitleCellUpdateAttrsSchema } from '@srcbook/shared';

const className =
  'flex w-full whitespace-normal rounded-md border border-transparent bg-transparent px-1 py-1 transition-colors hover:border-input hover:shadow-sm focus-visible:shadow-md focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50';

function isCharacterKey(e: React.KeyboardEvent<HTMLHeadingElement>) {
  return (
    e.key.length === 1 && // This checks if the pressed key is a single character
    !e.ctrlKey &&
    !e.metaKey &&
    !e.altKey
  );
}

export function EditableH1(props: {
  text: string;
  className?: string;
  onUpdated: (text: string) => void;
}) {
  const ref = useRef<HTMLHeadingElement>(null);
  const timeoutRef = useRef<number | null>(null);

  const [error, _setError] = useState<string | null>(null);

  function clearError() {
    _setError(null);
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
  }

  function setError(error: string) {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    _setError(error);
    timeoutRef.current = setTimeout(() => {
      _setError(null);
    }, 3000) as unknown as number;
  }

  return (
    <div>
      <h1
        // eslint-disable-next-line jsx-a11y/no-noninteractive-element-to-interactive-role -- messy fix should be reworked
        role="textbox"
        aria-multiline="true"
        tabIndex={0}
        className={cn(className, props.className)}
        ref={ref}
        contentEditable
        suppressContentEditableWarning={true}
        onBlur={(e) => {
          const result = TitleCellUpdateAttrsSchema.safeParse({ text: e.currentTarget.innerHTML });

          if (result.success) {
            props.onUpdated(result.data.text);
          } else {
            setError(result.error.errors[0]?.message ?? 'Unknown error');
            if (ref.current) {
              ref.current.innerText = props.text;
            }
          }
        }}
        onKeyDown={(e) => {
          if (!ref.current) {
            return;
          }

          if (isCharacterKey(e)) {
            const result = TitleCellUpdateAttrsSchema.safeParse({
              text: ref.current.innerText + e.key,
            });
            if (result.error) {
              setError(result.error.errors[0]?.message ?? 'Unknown error');
              e.preventDefault();
              return false;
            }
          }

          clearError();

          if (e.key === 'Enter') {
            ref.current.blur();
          } else if (e.key === 'Escape') {
            ref.current.innerText = props.text;
            ref.current.blur();
          }
        }}
      >
        {props.text}
      </h1>
      {error && <span className="text-error pt-3 text-sm font-medium">{error}</span>}
    </div>
  );
}

================
File: components/src/components/ui/input.tsx
================
import * as React from 'react';

import { cn } from '../../lib/utils.js';

const Input = React.forwardRef<HTMLInputElement, React.InputHTMLAttributes<HTMLInputElement>>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-8 w-full rounded-sm border border-input bg-transparent px-3 py-2 text-sm transition-colors hover:shadow-sm focus-visible:shadow-md file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50',
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = 'Input';

export { Input };

================
File: components/src/components/ui/navigation-menu.tsx
================
import * as React from 'react';
import * as NavigationMenuPrimitive from '@radix-ui/react-navigation-menu';
import { cva } from 'class-variance-authority';

import { cn } from '../../lib/utils.js';

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn('relative z-10 flex max-w-max flex-1 items-center justify-center', className)}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn('group flex flex-1 list-none items-center justify-center space-x-1', className)}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  'group inline-flex h-10 w-max items-center justify-center rounded-sm bg-background px-0.5 py-2 text-sm font-medium transition-colors hover:bg-muted hover:text-secondary-foreground focus:bg-muted focus:text-secondary-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-muted data-[state=open]:bg-muted',
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), 'group', className)}
    {...props}
  >
    {children}{' '}
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      'left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ',
      className,
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn('absolute left-0 top-full flex justify-center')}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        'origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]',
        className,
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName = NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      'top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in',
      className,
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName = NavigationMenuPrimitive.Indicator.displayName;

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
};

================
File: components/src/components/ui/popover.tsx
================
import * as React from 'react';
import * as PopoverPrimitive from '@radix-ui/react-popover';

import { cn } from '../../lib/utils.js';

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverAnchor = PopoverPrimitive.Anchor;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = 'center', sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        'z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        className,
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
));
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor };

================
File: components/src/components/ui/resizable.tsx
================
import { DragHandleDots2Icon } from '@radix-ui/react-icons';
import * as ResizablePrimitive from 'react-resizable-panels';

import { cn } from '../../lib/utils.js';

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn('flex h-full w-full data-[panel-group-direction=vertical]:flex-col', className)}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      'relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90',
      className,
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <DragHandleDots2Icon className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizablePanelGroup, ResizablePanel, ResizableHandle };

================
File: components/src/components/ui/scroll-area.tsx
================
'use client';

import * as React from 'react';
import * as ScrollAreaPrimitive from '@radix-ui/react-scroll-area';

import { cn } from '../../lib/utils.js';

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn('relative overflow-hidden', className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = 'vertical', ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      'flex touch-none select-none transition-colors',
      orientation === 'vertical' && 'h-full w-2.5 border-l border-l-transparent p-[1px]',
      orientation === 'horizontal' && 'h-2.5 flex-col border-t border-t-transparent p-[1px]',
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };

================
File: components/src/components/ui/select.tsx
================
import * as React from 'react';
import { CaretSortIcon, CheckIcon, ChevronDownIcon, ChevronUpIcon } from '@radix-ui/react-icons';
import * as SelectPrimitive from '@radix-ui/react-select';

import { cn } from '../../lib/utils.js';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-8 w-full items-center justify-between whitespace-nowrap rounded-sm border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <CaretSortIcon className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn('flex cursor-default items-center justify-center py-1', className)}
    {...props}
  >
    <ChevronUpIcon />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn('flex cursor-default items-center justify-center py-1', className)}
    {...props}
  >
    <ChevronDownIcon />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-sm border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]',
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('px-2 py-1.5 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-primary focus:text-primary-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};

================
File: components/src/components/ui/sheet.tsx
================
import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { Cross2Icon } from '@radix-ui/react-icons';
import { cva, type VariantProps } from 'class-variance-authority';

import { cn } from '../../lib/utils.js';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/40 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-[480px]',
        right:
          'inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-[480px]',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {
  portal?: boolean;
}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', portal = true, className, children, ...props }, ref) => {
  const inner = (
    <>
      <SheetOverlay className={cn({ absolute: !portal })} />
      <SheetPrimitive.Content
        ref={ref}
        className={cn(sheetVariants({ side }), { absolute: !portal }, className)}
        {...props}
      >
        <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
          <Cross2Icon className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
        {children}
      </SheetPrimitive.Content>
    </>
  );

  if (portal) {
    return <SheetPortal>{inner}</SheetPortal>;
  } else {
    return inner;
  }
});
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn('flex flex-col space-y-2 text-center sm:text-left', className)} {...props} />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn('flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2', className)}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};

================
File: components/src/components/ui/sonner.tsx
================
import { Toaster as Sonner } from 'sonner';

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  return (
    <Sonner
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            'group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border group-[.toaster]:border-border group-[.toaster]:shadow-lg rounded-sm',
          description: 'group-[.toast]:text-muted-foreground',
          actionButton: 'group-[.toast]:bg-primary group-[.toast]:text-primary-foreground',
          cancelButton: 'group-[.toast]:bg-muted group-[.toast]:text-muted-foreground',
          closeButton:
            'group-[.toast]:bg-background group-[.toast]:hover:bg-muted group-[.toast]:border group-[.toast]:border-border group-[.toast]:text-foreground group-[.toast]:hover:border-border',
        },
      }}
      {...props}
    />
  );
};

export { Toaster };

================
File: components/src/components/ui/switch.tsx
================
import * as React from 'react';
import * as SwitchPrimitives from '@radix-ui/react-switch';

import { cn } from '../../lib/utils.js';

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      'peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input',
      className,
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        'pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0',
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

================
File: components/src/components/ui/tabs.tsx
================
import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';

import { cn } from '../../lib/utils.js';

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      'inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground',
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      'inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow',
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      'mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

================
File: components/src/components/ui/textarea.tsx
================
import * as React from 'react';

import { cn } from '../../lib/utils.js';

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.TextareaHTMLAttributes<HTMLTextAreaElement>
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        'flex min-h-[60px] w-full rounded-sm border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50',
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = 'Textarea';

export { Textarea };

================
File: components/src/components/ui/tooltip.tsx
================
import * as React from 'react';
import * as TooltipPrimitive from '@radix-ui/react-tooltip';

import { cn } from '../../lib/utils.js';

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    side="bottom"
    className={cn(
      'z-50 overflow-hidden rounded-sm bg-muted px-1.5 py-1.5 text-xs font-medium border animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };

================
File: components/src/components/ui/underline-flat-tabs.tsx
================
import * as React from 'react';
import * as TabsPrimitive from '@radix-ui/react-tabs';

import { cn } from '../../lib/utils.js';

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn('inline-flex h-full items-center justify-center', className)}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      'px-3 py-2 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border-b data-[state=active]:border-transparent data-[state=active]:text-foreground data-[state=active]:border-foreground -mb-[1px]',
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      'mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2',
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

================
File: components/src/components/ai-generate-tips-dialog.tsx
================
import { useState } from 'react';
import { Dialog, DialogTrigger, DialogContent, DialogHeader, DialogTitle } from './ui/dialog.js';

export default function AiGenerateTipsDialog({ children }: { children: React.ReactNode }) {
  const [open, setOpen] = useState(false);
  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="w-[640px] max-w-[640px]">
        <DialogHeader>
          <DialogTitle>Prompt tips</DialogTitle>
          <div className="text-sm">
            <p>Here are a few tips to get the AI to work well for you.</p>
            <ul className="list-disc list-inside py-4 leading-5">
              <li>The AI knows already knows about all of the contents of this notebook.</li>
              <li>It also knows what cell you're updating.</li>
              <li>You can ask the code to add or improve comments or jsdoc.</li>
              <li>You can ask the AI to refactor or rewrite the whole thing.</li>
              <li>
                Try asking the AI to refactor, improve or modularize your code, simply by asking for
                it.
              </li>
            </ul>
          </div>
        </DialogHeader>
      </DialogContent>
    </Dialog>
  );
}

================
File: components/src/components/cell-output.tsx
================
import { useState } from 'react';
import { Ban, Maximize, Minimize, PanelBottomClose, PanelBottomOpen, Sparkles } from 'lucide-react';
import { CodeCellType, PackageJsonCellType, TsServerDiagnosticType } from '@srcbook/shared';
import { cn } from '../lib/utils.js';
import { Tabs, TabsList, TabsTrigger, TabsContent } from './ui/underline-flat-tabs.js';
import { useCells } from './use-cell.js';
import { OutputType, StdoutOutputType, StderrOutputType, CellModeType } from '../types';
import { Button } from './ui/button.js';

type Props = {
  cell: CodeCellType | PackageJsonCellType;
  show: boolean;
  setShow: (show: boolean) => void;
  fixDiagnostics: (diagnostics: string) => void;
  cellMode: CellModeType;
  setFullscreen: (fullscreen: boolean) => void;
  fullscreen: boolean;
  aiEnabled: boolean;
};

export function CellOutput(props: Props) {
  const { cell, show, setShow } = props;
  const { getOutput, clearOutput, getTsServerDiagnostics, getTsServerSuggestions } = useCells();

  const [activeTab, setActiveTab] = useState<'stdout' | 'stderr' | 'problems' | 'warnings'>(
    'stdout',
  );

  const fullscreen = props.fullscreen;
  const stdout = getOutput(cell.id, 'stdout') as StdoutOutputType[];
  const stderr = getOutput(cell.id, 'stderr') as StderrOutputType[];
  const diagnostics = getTsServerDiagnostics(cell.id);
  const suggestions = getTsServerSuggestions(cell.id);

  return (
    <div className={cn('font-mono text-sm', fullscreen && !show && 'border-b')}>
      <Tabs
        value={activeTab}
        onValueChange={(value) =>
          setActiveTab(value as 'stdout' | 'stderr' | 'problems' | 'warnings')
        }
        defaultValue="stdout"
      >
        <div
          className={cn(
            'border-t px-3 flex items-center justify-between bg-muted text-tertiary-foreground rounded-b-md',
            show && 'border-b rounded-none',
            fullscreen && 'sticky top-0 border-t',
          )}
        >
          <TabsList className={cn('h-full', !show && '')}>
            <TabsTrigger
              onClick={() => setShow(true)}
              value="stdout"
              className={cn(
                !show &&
                  'border-transparent data-[state=active]:border-transparent data-[state=active]:text-tertiary-foreground mb-0',
              )}
            >
              stdout
            </TabsTrigger>
            <TabsTrigger
              onClick={() => setShow(true)}
              value="stderr"
              className={cn(
                !show &&
                  'border-transparent data-[state=active]:border-transparent data-[state=active]:text-tertiary-foreground mb-0',
              )}
            >
              {stderr.length > 0 ? (
                <>
                  stderr <span className="text-sb-red-30">({stderr.length})</span>
                </>
              ) : (
                'stderr'
              )}
            </TabsTrigger>
            {cell.type === 'code' && cell.language === 'typescript' && (
              <TabsTrigger
                onClick={() => setShow(true)}
                value="problems"
                className={cn(
                  !show &&
                    'border-transparent data-[state=active]:border-transparent data-[state=active]:text-tertiary-foreground mb-0',
                )}
              >
                {diagnostics.length > 0 ? (
                  <>
                    problems <span className="text-sb-red-30">({diagnostics.length})</span>
                  </>
                ) : (
                  'problems'
                )}
              </TabsTrigger>
            )}
            {cell.type === 'code' && cell.language === 'typescript' && (
              <TabsTrigger
                onClick={() => setShow(true)}
                value="warnings"
                className={cn(
                  !show &&
                    'border-transparent data-[state=active]:border-transparent data-[state=active]:text-tertiary-foreground mb-0',
                )}
              >
                {suggestions.length > 0 ? (
                  <>
                    warnings <span className="text-sb-yellow-50">({suggestions.length})</span>
                  </>
                ) : (
                  'warnings'
                )}
              </TabsTrigger>
            )}
          </TabsList>
          <div className="flex items-center gap-6">
            <button
              className="hover:text-secondary-hover disabled:pointer-events-none disabled:opacity-50"
              onClick={() => props.setFullscreen(!fullscreen)}
            >
              {fullscreen ? <Minimize size={16} /> : <Maximize size={16} />}
            </button>
            <button
              className="hover:text-secondary-hover disabled:pointer-events-none disabled:opacity-50"
              disabled={activeTab === 'problems' || activeTab === 'warnings'}
              onClick={() =>
                clearOutput(
                  cell.id,
                  activeTab === 'problems' || activeTab === 'warnings' ? undefined : activeTab,
                )
              }
            >
              <Ban size={16} />
            </button>
            <button className="hover:text-secondary-hover" onClick={() => setShow(!show)}>
              {show ? <PanelBottomOpen size={20} /> : <PanelBottomClose size={20} />}
            </button>
          </div>
        </div>
        {show && (
          <div
            className={cn(
              'p-2 flex flex-col-reverse overflow-auto whitespace-pre-wrap text-[13px]',
              !fullscreen && 'max-h-96',
            )}
          >
            <TabsContent className="mt-0" value="stdout">
              <Stdout stdout={stdout} />
            </TabsContent>
            <TabsContent value="stderr" className="mt-0">
              <Stderr stderr={stderr} />
            </TabsContent>
            {cell.type === 'code' && cell.language === 'typescript' && (
              <TabsContent value="problems" className="mt-0">
                <TsServerDiagnostics
                  diagnostics={diagnostics}
                  fixDiagnostics={props.fixDiagnostics}
                  cellMode={props.cellMode}
                  aiEnabled={props.aiEnabled}
                />
              </TabsContent>
            )}
            {cell.type === 'code' && cell.language === 'typescript' && (
              <TabsContent value="warnings" className="mt-0">
                <TsServerSuggestions
                  suggestions={suggestions}
                  fixSuggestions={props.fixDiagnostics} // fixDiagnostics works for both diagnostics and suggestions
                  cellMode={props.cellMode}
                  aiEnabled={props.aiEnabled}
                />
              </TabsContent>
            )}
          </div>
        )}
      </Tabs>
    </div>
  );
}

function formatOutput(output: OutputType[], sep = '') {
  return output.map(({ data }) => data).join(sep);
}

function Stdout({ stdout }: { stdout: StdoutOutputType[] }) {
  return stdout.length === 0 ? (
    <div className="italic text-center text-muted-foreground">No output</div>
  ) : (
    formatOutput(stdout)
  );
}

function Stderr({ stderr }: { stderr: StderrOutputType[] }) {
  return (
    <div className={stderr.length > 0 ? 'text-sb-red-30' : ''}>
      {stderr.length === 0 ? (
        <div className="italic text-center text-muted-foreground">No errors or warnings</div>
      ) : (
        formatOutput(stderr)
      )}
    </div>
  );
}

function formatDiagnostic(diag: TsServerDiagnosticType) {
  return `[Ln ${diag.start.line}, Col ${diag.start.offset}] ${diag.category} ts(${diag.code}): ${diag.text}`;
}

function TsServerDiagnostics({
  diagnostics,
  fixDiagnostics,
  cellMode,
  aiEnabled,
}: {
  diagnostics: TsServerDiagnosticType[];
  fixDiagnostics: (diagnostics: string) => void;
  cellMode: CellModeType;
  aiEnabled: boolean;
}) {
  const formattedDiagnostics = diagnostics.map(formatDiagnostic).join('\n');
  return diagnostics.length === 0 ? (
    <div className="italic text-center text-muted-foreground">No problems</div>
  ) : (
    <div className="flex flex-col w-full">
      <p>{formattedDiagnostics}</p>
      {aiEnabled && cellMode !== 'fixing' && (
        <Button
          variant="ai"
          className="self-start flex items-center gap-2 px-2.5 py-2 font-sans h-7 mt-3"
          onClick={() => fixDiagnostics(formattedDiagnostics)}
          disabled={cellMode === 'generating'}
        >
          <Sparkles size={16} />
          <p>Fix with AI</p>
        </Button>
      )}
    </div>
  );
}

function TsServerSuggestions({
  suggestions,
  fixSuggestions,
  cellMode,
  aiEnabled,
}: {
  suggestions: TsServerDiagnosticType[];
  fixSuggestions: (suggestions: string) => void;
  cellMode: CellModeType;
  aiEnabled: boolean;
}) {
  const formattedSuggestions = suggestions.map(formatDiagnostic).join('\n');
  return suggestions.length === 0 ? (
    <div className="italic text-center text-muted-foreground">No warnings or suggestions</div>
  ) : (
    <div className="flex flex-col w-full">
      <p>{formattedSuggestions}</p>
      {aiEnabled && cellMode !== 'fixing' && (
        <Button
          variant="ai"
          className="self-start flex items-center gap-2 px-2.5 py-2 font-sans h-7 mt-3"
          onClick={() => fixSuggestions(formattedSuggestions)}
          disabled={cellMode === 'generating'}
        >
          <Sparkles size={16} />
          <p>Fix with AI</p>
        </Button>
      )}
    </div>
  );
}

================
File: components/src/components/delete-cell-dialog.tsx
================
import { useState } from 'react';
import { Button } from './ui/button.js';
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from './ui/dialog.js';

export default function DeleteCellWithConfirmationModal({
  onDeleteCell,
  children,
}: {
  onDeleteCell: () => void;
  children: React.ReactNode;
}) {
  const [open, setOpen] = useState(false);
  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Delete this cell</DialogTitle>
          <DialogDescription>
            We currently don't support history, are you sure you want to delete it?
          </DialogDescription>
          <div className="flex w-full justify-end items-center gap-2 pt-4 bg-background">
            <Button
              variant="secondary"
              onClick={() => {
                setOpen(false);
              }}
            >
              Cancel
            </Button>
            <Button variant="destructive" onClick={() => onDeleteCell()}>
              Delete
            </Button>
          </div>
        </DialogHeader>
      </DialogContent>
    </Dialog>
  );
}

================
File: components/src/components/keyboard-shortcut.tsx
================
import React from 'react';

type Platform = 'mac' | 'windows' | 'linux' | 'other';
type KeyType = 'mod' | 'alt';

const getPlatform = () => {
  const platform = navigator.platform.toLowerCase();
  const userAgent = navigator.userAgent.toLowerCase();

  if (platform.includes('mac') || userAgent.includes('mac')) {
    return 'mac';
  } else if (platform.includes('win') || userAgent.includes('win')) {
    return 'windows';
  } else if (platform.includes('linux') || userAgent.includes('linux')) {
    return 'linux';
  } else {
    return 'other';
  }
};

const keyMappings: Record<KeyType, Record<Platform, string>> = {
  mod: {
    mac: '⌘',
    windows: 'Ctrl',
    linux: 'Ctrl',
    other: 'Ctrl',
  },
  alt: {
    mac: '⌥',
    windows: 'Alt',
    linux: 'Alt',
    other: 'Alt',
  },
};

const getPlatformSpecificKey = (keyType: KeyType): string => {
  const platform = getPlatform();
  return keyMappings[keyType][platform];
};

export default function Shortcut({ keys }: { keys: string[] }) {
  // Replace keys that are in the keyMappings with the platform specific key
  keys = keys.map((key) => {
    if (key === 'mod') {
      return getPlatformSpecificKey('mod');
    } else if (key === 'alt') {
      return getPlatformSpecificKey('alt');
    } else {
      return key;
    }
  });
  return (
    <>
      {keys.map((key) => {
        return (
          <React.Fragment key={key}>
            <span className="font-mono bg-background text-foreground border py-[1px] px-1.5 rounded-sm drop-shadow-key mx-0.5">
              {key}
            </span>
          </React.Fragment>
        );
      })}
    </>
  );
}

================
File: components/src/components/logos.tsx
================
type PropsType = {
  size?: string | number;
  className?: string;
};

export function PrettierLogo(props: PropsType) {
  return (
    <svg
      fill="currentColor"
      width={props.size ?? '24'}
      height={props.size ?? '24'}
      viewBox="0 0 24 24"
      className={props.className}
      xmlns="http://www.w3.org/2000/svg"
    >
      <path d="M8.571 23.429A.571.571 0 0 1 8 24H2.286a.571.571 0 0 1 0-1.143H8c.316 0 .571.256.571.572zM8 20.57H6.857a.571.571 0 0 0 0 1.143H8a.571.571 0 0 0 0-1.143zm-5.714 1.143H4.57a.571.571 0 0 0 0-1.143H2.286a.571.571 0 0 0 0 1.143zM8 18.286H2.286a.571.571 0 0 0 0 1.143H8a.571.571 0 0 0 0-1.143zM16 16H5.714a.571.571 0 0 0 0 1.143H16A.571.571 0 0 0 16 16zM2.286 17.143h1.143a.571.571 0 0 0 0-1.143H2.286a.571.571 0 0 0 0 1.143zm17.143-3.429H16a.571.571 0 0 0 0 1.143h3.429a.571.571 0 0 0 0-1.143zM9.143 14.857h4.571a.571.571 0 0 0 0-1.143H9.143a.571.571 0 0 0 0 1.143zm-6.857 0h4.571a.571.571 0 0 0 0-1.143H2.286a.571.571 0 0 0 0 1.143zM20.57 11.43H11.43a.571.571 0 0 0 0 1.142h9.142a.571.571 0 0 0 0-1.142zM9.714 12a.571.571 0 0 0-.571-.571H5.714a.571.571 0 0 0 0 1.142h3.429A.571.571 0 0 0 9.714 12zm-7.428.571h1.143a.571.571 0 0 0 0-1.142H2.286a.571.571 0 0 0 0 1.142zm19.428-3.428H16a.571.571 0 0 0 0 1.143h5.714a.571.571 0 0 0 0-1.143zM2.286 10.286H8a.571.571 0 0 0 0-1.143H2.286a.571.571 0 0 0 0 1.143zm13.143-2.857c0 .315.255.571.571.571h5.714a.571.571 0 0 0 0-1.143H16a.571.571 0 0 0-.571.572zm-8.572-.572a.571.571 0 0 0 0 1.143H8a.571.571 0 0 0 0-1.143H6.857zM2.286 8H4.57a.571.571 0 0 0 0-1.143H2.286a.571.571 0 0 0 0 1.143zm16.571-2.857c0 .315.256.571.572.571h1.142a.571.571 0 0 0 0-1.143H19.43a.571.571 0 0 0-.572.572zm-1.143 0a.571.571 0 0 0-.571-.572H12.57a.571.571 0 0 0 0 1.143h4.572a.571.571 0 0 0 .571-.571zm-15.428.571h8a.571.571 0 0 0 0-1.143h-8a.571.571 0 0 0 0 1.143zm5.143-2.857c0 .316.255.572.571.572h11.429a.571.571 0 0 0 0-1.143H8a.571.571 0 0 0-.571.571zm-5.143.572h3.428a.571.571 0 0 0 0-1.143H2.286a.571.571 0 0 0 0 1.143zm0-2.286H16A.571.571 0 0 0 16 0H2.286a.571.571 0 0 0 0 1.143z" />
    </svg>
  );
}

================
File: components/src/components/use-cell.tsx
================
import {
  createContext,
  useCallback,
  useContext,
  ReactNode,
  useRef,
  useReducer,
  useEffect,
} from 'react';
import {
  CellType,
  CodeCellType,
  CodeLanguageType,
  MarkdownCellType,
  TsServerDiagnosticType,
  TsServerSuggestionType,
  getDefaultExtensionForLanguage,
} from '@srcbook/shared';
import { GenerateAICellType, OutputType } from '../types';

import { randomid } from '@srcbook/shared';

type ClientCellType = CellType | GenerateAICellType;

/**
 * Utility function to generate a unique filename for a code cell,
 * given the list of existing filenames.
 */
function generateUniqueFilename(existingFilenames: string[], language: CodeLanguageType): string {
  const baseName = 'untitled';
  const extension = getDefaultExtensionForLanguage(language);

  let filename = `${baseName}${extension}`;
  let counter = 1;

  while (existingFilenames.includes(filename)) {
    filename = `${baseName}${counter}${extension}`;
    counter++;
  }

  return filename;
}

function buildGenerateAiCell(): GenerateAICellType {
  return {
    id: randomid(),
    type: 'generate-ai',
  };
}

function buildCodeCell(
  cells: ClientCellType[],
  language: CodeLanguageType,
  attrs: Partial<CodeCellType> = {},
): CodeCellType {
  const filenames = cells.filter((c) => c.type === 'code').map((c) => (c as CodeCellType).filename);
  const uniqueFilename = generateUniqueFilename(filenames, language);

  return {
    source: '',
    filename: uniqueFilename,
    status: 'idle',
    ...attrs,
    id: randomid(),
    type: 'code',
    language,
  };
}

function buildMarkdownCell(attrs: Partial<MarkdownCellType> = {}): MarkdownCellType {
  return {
    text: '',
    ...attrs,
    id: randomid(),
    type: 'markdown',
  };
}

type OutputStateType = Record<string, OutputType[]>;
type TsServerStateType = Record<string, TsServerDiagnosticType[]>;

interface CellsContextType {
  cells: ClientCellType[];
  setCells: (cells: ClientCellType[]) => void;
  updateCell: (cell: ClientCellType) => void;
  removeCell: (cell: ClientCellType) => void;
  insertCellAt: (cell: ClientCellType, idx: number) => void;
  createCodeCell: (
    idx: number,
    language: CodeLanguageType,
    attrs?: Partial<CodeCellType>,
  ) => CodeCellType;
  createMarkdownCell: (idx: number, attrs?: Partial<MarkdownCellType>) => MarkdownCellType;
  createGenerateAiCell: (idx: number) => GenerateAICellType;
  hasOutput: (id: string, type?: 'stdout' | 'stderr') => boolean;
  getOutput: (id: string, type?: 'stdout' | 'stderr') => Array<OutputType>;
  setOutput: (id: string, output: OutputType | OutputType[]) => void;
  clearOutput: (id: string, type?: 'stdout' | 'stderr') => void;
  getTsServerDiagnostics: (id: string) => TsServerDiagnosticType[];
  setTsServerDiagnostics: (id: string, diagnostics: TsServerDiagnosticType[]) => void;
  getTsServerSuggestions: (id: string) => TsServerSuggestionType[];
  setTsServerSuggestions: (id: string, suggestions: TsServerSuggestionType[]) => void;
}

const CellsContext = createContext<CellsContextType | undefined>(undefined);

export const CellsProvider: React.FC<{ cells: ClientCellType[]; children: ReactNode }> = ({
  cells,
  children,
}) => {
  // Because we use refs for our state, we need a way to trigger
  // component re-renders when the ref state changes.
  //
  // https://legacy.reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate
  //
  const [, forceComponentRerender] = useReducer((x) => x + 1, 0);

  // Use ref to help avoid stale state bugs in closures.
  const cellsRef = useRef<ClientCellType[]>(cells);
  useEffect(() => {
    cellsRef.current = cells;
    forceComponentRerender();
  }, [cells]);

  // Use ref to help avoid stale state bugs in closures.
  const outputRef = useRef<OutputStateType>({});

  // Use ref to help avoid stale state bugs in closures.
  const tsServerDiagnosticsRef = useRef<TsServerStateType>({});

  // Use ref to help avoid stale state bugs in closures.
  const tsServerSuggestionsRef = useRef<TsServerStateType>({});

  const stableSetCells = useCallback((cells: ClientCellType[]) => {
    cellsRef.current = cells;
    forceComponentRerender();
  }, []);

  const stableSetOutput = useCallback((output: OutputStateType) => {
    outputRef.current = output;
    forceComponentRerender();
  }, []);

  const stableSetTsServerDiagnostics = useCallback((diagnostics: TsServerStateType) => {
    tsServerDiagnosticsRef.current = diagnostics;
    forceComponentRerender();
  }, []);

  const stableSetTsServerSuggestions = useCallback((suggestions: TsServerStateType) => {
    tsServerSuggestionsRef.current = suggestions;
    forceComponentRerender();
  }, []);

  const updateCell = useCallback(
    (cell: ClientCellType) => {
      stableSetCells(cellsRef.current.map((c) => (c.id === cell.id ? cell : c)));
    },
    [stableSetCells],
  );

  const removeCell = useCallback(
    (cell: ClientCellType) => {
      stableSetCells(cellsRef.current.filter((c) => c.id !== cell.id));
    },
    [stableSetCells],
  );

  const insertCellAt = useCallback(
    (cell: ClientCellType, idx: number) => {
      const copy = [...cellsRef.current];
      copy.splice(idx, 0, cell);
      stableSetCells(copy);
    },
    [stableSetCells],
  );

  const createCodeCell = useCallback(
    (idx: number, language: CodeLanguageType, attrs?: Partial<CodeCellType>) => {
      const cell = buildCodeCell(cellsRef.current, language, attrs);
      insertCellAt(cell, idx);
      return cell;
    },
    [insertCellAt],
  );

  const createGenerateAiCell = useCallback(
    (idx: number) => {
      const cell = buildGenerateAiCell();
      insertCellAt(cell, idx);
      return cell;
    },
    [insertCellAt],
  );

  const createMarkdownCell = useCallback(
    (idx: number, attrs?: Partial<MarkdownCellType>) => {
      const cell = buildMarkdownCell(attrs);
      insertCellAt(cell, idx);
      return cell;
    },
    [insertCellAt],
  );

  const hasOutput = useCallback((id: string, type?: 'stdout' | 'stderr') => {
    const output = outputRef.current[id] || [];
    const length = type ? output.filter((o) => o.type === type).length : output.length;
    return length > 0;
  }, []);

  const getOutput = useCallback((id: string, type?: 'stdout' | 'stderr') => {
    const output = outputRef.current[id] || [];
    return type ? output.filter((o) => o.type === type) : output;
  }, []);

  const setOutput = useCallback(
    (id: string, output: OutputType | OutputType[]) => {
      output = Array.isArray(output) ? output : [output];
      stableSetOutput({
        ...outputRef.current,
        [id]: (outputRef.current[id] || []).concat(output),
      });
    },
    [stableSetOutput],
  );

  const clearOutput = useCallback(
    (id: string, type?: 'stdout' | 'stderr') => {
      const output = outputRef.current[id] || [];
      const updated = type !== undefined ? output.filter((o) => o.type !== type) : [];
      stableSetOutput({ ...outputRef.current, [id]: updated });
    },
    [stableSetOutput],
  );

  const getTsServerDiagnostics = useCallback((id: string) => {
    return tsServerDiagnosticsRef.current[id] || [];
  }, []);

  const getTsServerSuggestions = useCallback((id: string) => {
    return tsServerSuggestionsRef.current[id] || [];
  }, []);

  const setTsServerDiagnostics = useCallback(
    (id: string, diagnostics: TsServerDiagnosticType[]) => {
      stableSetTsServerDiagnostics({ ...tsServerDiagnosticsRef.current, [id]: diagnostics });
    },
    [stableSetTsServerDiagnostics],
  );

  const setTsServerSuggestions = useCallback(
    (id: string, suggestions: TsServerSuggestionType[]) => {
      stableSetTsServerSuggestions({ ...tsServerSuggestionsRef.current, [id]: suggestions });
    },
    [stableSetTsServerSuggestions],
  );

  return (
    <CellsContext.Provider
      value={{
        cells: cellsRef.current,
        setCells: stableSetCells,
        updateCell,
        removeCell,
        insertCellAt,
        createCodeCell,
        createMarkdownCell,
        createGenerateAiCell,
        hasOutput,
        getOutput,
        setOutput,
        clearOutput,
        getTsServerDiagnostics,
        getTsServerSuggestions,
        setTsServerDiagnostics,
        setTsServerSuggestions,
      }}
    >
      {children}
    </CellsContext.Provider>
  );
};

export const useCells = (): CellsContextType => {
  const context = useContext(CellsContext);
  if (context === undefined) {
    throw new Error('useCells must be used within a CellsProvider');
  }
  return context;
};

================
File: components/src/components/use-theme.tsx
================
import { useState } from 'react';
import { srcbookLight, srcbookDark } from '../lib/code-theme.js';

export type ThemeType = 'light' | 'dark';
export type CodeThemeType = typeof srcbookLight | typeof srcbookDark;

export function getTheme(): ThemeType {
  const theme = localStorage.getItem('sb:theme');

  if (theme === 'light' || theme === 'dark') {
    return theme;
  }

  return 'dark';
}

function persistTheme(theme: ThemeType) {
  localStorage.setItem('sb:theme', theme);
}

function updateClass(theme: ThemeType) {
  const html = document.querySelector('html')!;

  if (theme === 'light') {
    html.classList.remove('dark');
  } else {
    html.classList.add('dark');
  }
}

export default function useTheme() {
  const [theme, _setTheme] = useState<ThemeType>(getTheme());

  function setTheme(theme: ThemeType) {
    updateClass(theme);
    persistTheme(theme);
    _setTheme(theme);
  }

  function toggleTheme() {
    setTheme(theme === 'dark' ? 'light' : 'dark');
  }

  return {
    theme,
    codeTheme: getTheme() === 'dark' ? srcbookDark : srcbookLight,
    toggleTheme,
    setTheme,
  };
}

================
File: components/src/lib/code-theme.ts
================
import { highlightCode, tags as t, tagHighlighter } from '@lezer/highlight';
import { parser as lezerParser } from '@lezer/javascript';
import { createTheme, CreateThemeOptions } from '@uiw/codemirror-themes';

const DEFAULT_LIGHT_SETTINGS: CreateThemeOptions['settings'] = {
  background: 'var(--background)',
  foreground: 'var(--foreground)',
  caret: 'var(--foreground)',
  selection: '#BBDFFF',
  selectionMatch: '#BBDFFF',
  gutterBackground: 'var(--background)',
  gutterForeground: 'hsl(var(--muted-foreground))',
  gutterActiveForeground: 'hsl(var(--foreground))',
  gutterBorder: 'transparent',
  lineHighlight: 'transparent',
};

export const DEFAULT_DARK_SETTINGS: CreateThemeOptions['settings'] = {
  background: 'var(--background)',
  foreground: 'var(--foreground)',
  caret: 'var(--foreground)',
  selection: '#003d73',
  selectionMatch: '#003d73',
  gutterBackground: 'var(--background)',
  gutterForeground: 'hsl(var(--muted-foreground))',
  lineHighlight: 'transparent',
  gutterBorder: 'transparent',
};

export const LIGHT_TAGS = [
  { tag: [t.standard(t.tagName), t.tagName], class: 'text-[#116329]' },
  { tag: [t.comment, t.bracket], class: 'text-[#6a737d]' },
  { tag: [t.className, t.propertyName], class: 'text-[#6f42c1]' },
  { tag: [t.variableName, t.attributeName, t.number, t.operator], class: 'text-[#005cc5]' },
  { tag: [t.keyword, t.typeName, t.typeOperator, t.typeName], class: 'text-[#d73a49]' },
  { tag: [t.string, t.meta, t.regexp], class: 'text-[#032f62]' },
  { tag: [t.name, t.quote], class: 'text-[#22863a]' },
  { tag: [t.heading, t.strong], class: 'text-[#24292e] font-bold' },
  { tag: [t.emphasis], class: 'text-[#24292e] italic' },
  { tag: [t.deleted], class: 'text-[#b31d28] bg-[#ffeef0]' },
  { tag: [t.atom, t.bool, t.special(t.variableName)], class: 'text-[#e36209]' },
  { tag: [t.url, t.escape, t.regexp, t.link], class: 'text-[#032f62]' },
  { tag: t.link, class: 'underline' },
  { tag: t.strikethrough, class: 'line-through' },
  { tag: t.invalid, class: 'text-[#cb2431]' },
];
export const DARK_TAGS = [
  { tag: [t.standard(t.tagName), t.tagName], class: 'text-[#7ee787]' },
  { tag: [t.comment, t.bracket], class: 'text-[#8b949e]' },
  { tag: [t.className, t.propertyName], class: 'text-[#d2a8ff]' },
  { tag: [t.variableName, t.attributeName, t.number, t.operator], class: 'text-[#79c0ff]' },
  { tag: [t.keyword, t.typeName, t.typeOperator, t.typeName], class: 'text-[#ff7b72]' },
  { tag: [t.string, t.meta, t.regexp], class: 'text-[#a5d6ff]' },
  { tag: [t.name, t.quote], class: 'text-[#7ee787]' },
  { tag: [t.heading, t.strong], class: 'text-[#d2a8ff] font-bold' },
  { tag: [t.emphasis], class: 'text-[#d2a8ff] italic' },
  { tag: [t.deleted], class: 'text-[#ffdcd7] bg-[#ffeef0]' },
  { tag: [t.atom, t.bool, t.special(t.variableName)], class: 'text-[#ffab70]' },
  { tag: t.link, class: 'underline' },
  { tag: t.strikethrough, class: 'line-through' },
  { tag: t.invalid, class: 'text-[#f97583]' },
];

export const srcbookLight = createTheme({
  theme: 'light',
  settings: DEFAULT_LIGHT_SETTINGS,
  styles: LIGHT_TAGS,
});

export const srcbookDark = createTheme({
  theme: 'dark',
  settings: DEFAULT_DARK_SETTINGS,
  styles: DARK_TAGS,
});

function getTagHighlighter(theme: 'light' | 'dark') {
  return tagHighlighter(theme === 'light' ? LIGHT_TAGS : DARK_TAGS);
}

/**
 * Formats source code by applying syntax highlighting.
 * The result is a DOM element containing the styled tokens.
 */
export function formatCode(
  source: string,
  theme: 'light' | 'dark',
  classes: string = 'whitespace-pre-wrap',
): HTMLElement {
  const parser = lezerParser.configure({ dialect: 'ts' });
  const tree = parser.parse(source);
  const highlighter = getTagHighlighter(theme);

  const root = document.createElement('div');

  root.className = classes;

  function putText(code: string, classes: string) {
    if (classes.length === 0) {
      root.append(document.createTextNode(code));
    } else {
      const element = document.createElement('span');
      element.innerText = code;
      element.className = classes;
      root.append(element);
    }
  }

  function putBreak() {
    root.append(document.createElement('br'));
  }

  highlightCode(source, tree, highlighter, putText, putBreak);

  return root;
}

================
File: components/src/lib/utils.ts
================
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

================
File: components/src/ui/heading.tsx
================
import { useRef, useState } from 'react';

import { cn } from '../lib/utils.js';
import { TitleCellUpdateAttrsSchema } from '@srcbook/shared';

const className =
  'flex w-full whitespace-normal rounded-md border border-transparent bg-transparent px-1 py-1 transition-colors hover:border-input hover:shadow-sm focus-visible:shadow-md focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50';

function isCharacterKey(e: React.KeyboardEvent<HTMLHeadingElement>) {
  return (
    e.key.length === 1 && // This checks if the pressed key is a single character
    !e.ctrlKey &&
    !e.metaKey &&
    !e.altKey
  );
}

export function EditableH1(props: {
  text: string;
  className?: string;
  onUpdated: (text: string) => void;
}) {
  const ref = useRef<HTMLHeadingElement>(null);
  const timeoutRef = useRef<number | null>(null);

  const [error, _setError] = useState<string | null>(null);

  function clearError() {
    _setError(null);
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
  }

  function setError(error: string) {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    _setError(error);
    timeoutRef.current = setTimeout(() => {
      _setError(null);
    }, 3000) as unknown as number;
  }

  return (
    <div>
      <h1
        // eslint-disable-next-line jsx-a11y/no-noninteractive-element-to-interactive-role -- messy fix should be reworked
        role="textbox"
        aria-multiline="true"
        tabIndex={0}
        className={cn(className, props.className)}
        ref={ref}
        contentEditable
        suppressContentEditableWarning={true}
        onBlur={(e) => {
          const result = TitleCellUpdateAttrsSchema.safeParse({ text: e.currentTarget.innerHTML });

          if (result.success) {
            props.onUpdated(result.data.text);
          } else {
            setError(result.error.errors[0]?.message ?? 'Unknown error');
            if (ref.current) {
              ref.current.innerText = props.text;
            }
          }
        }}
        onKeyDown={(e) => {
          if (!ref.current) {
            return;
          }

          if (isCharacterKey(e)) {
            const result = TitleCellUpdateAttrsSchema.safeParse({
              text: ref.current.innerText + e.key,
            });
            if (result.error) {
              setError(result.error.errors[0]?.message ?? 'Unknown error');
              e.preventDefault();
              return false;
            }
          }

          clearError();

          if (e.key === 'Enter') {
            ref.current.blur();
          } else if (e.key === 'Escape') {
            ref.current.innerText = props.text;
            ref.current.blur();
          }
        }}
      >
        {props.text}
      </h1>
      {error && <span className="text-error pt-3 text-sm font-medium">{error}</span>}
    </div>
  );
}

================
File: components/src/index.tsx
================
import TitleCell from './components/cells/title.js';
import MarkdownCell from './components/cells/markdown.js';
import CodeCell from './components/cells/code.js';
export { TitleCell, MarkdownCell, CodeCell };

export * from './components/ui/button.js';
export * from './components/ui/card.js';
export * from './components/ui/collapsible.js';
export * from './components/ui/command.js';
export * from './components/ui/dialog.js';
export * from './components/ui/dropdown-menu';
export * from './components/ui/heading.js';
export * from './components/ui/input.js';
export * from './components/ui/navigation-menu.js';
export * from './components/ui/popover.js';
export * from './components/ui/resizable.js';
export * from './components/ui/scroll-area.js';
export * from './components/ui/select.js';
export * from './components/ui/sheet.js';
export * from './components/ui/sonner.js';
export * from './components/ui/switch.js';
export * from './components/ui/tabs.js';
export * from './components/ui/textarea.js';
export * from './components/ui/tooltip.js';
export {
  Tabs as UnderlineTabs,
  TabsList as UnderlingTabsList,
  TabsTrigger as UnderlineTabsTrigger,
  TabsContent as UnderlineTabsContent,
} from './components/ui/underline-flat-tabs.js';

export * from './lib/utils.js';

================
File: components/src/types.ts
================
import { CellType, CodeLanguageType } from '@srcbook/shared';

export type GenerateAICellType = {
  id: string;
  type: 'generate-ai';
};

export type StdoutOutputType = { type: 'stdout'; data: string };
export type StderrOutputType = { type: 'stderr'; data: string };
export type OutputType = StdoutOutputType | StderrOutputType;

export type SessionType = {
  id: string;
  cells: CellType[];
  language: CodeLanguageType;
  'tsconfig.json'?: string;
  openedAt: number;
};

export type CellModeType =
  | 'off'
  | 'generating'
  | 'reviewing'
  | 'prompting'
  | 'fixing'
  | 'formatting';

================
File: components/.eslintrc.cjs
================
/** @type {import("eslint").Linter.Config} */
module.exports = {
  root: true,
  extends: [require.resolve('@srcbook/configs/eslint/react.js')],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: './tsconfig.lint.json',
    tsconfigRootDir: __dirname,
  },
  globals: {
    Bun: false,
  },
};

================
File: components/.npmignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

*.gitignored.*

================
File: components/CHANGELOG.md
================
# @srcbook/components

## 0.0.7

### Patch Changes

- Updated dependencies [a236470]
  - @srcbook/shared@0.0.13

## 0.0.6

### Patch Changes

- 2e774d4: Support streaming of the responses!
- Updated dependencies [727bab7]
- Updated dependencies [2e774d4]
  - @srcbook/shared@0.0.12

## 0.0.5

### Patch Changes

- Updated dependencies [b49bdf4]
- Updated dependencies [bbbd5d6]
  - @srcbook/shared@0.0.11

## 0.0.4

### Patch Changes

- ccd8d01: Introduce app builder
- Updated dependencies [ccd8d01]
- Updated dependencies [73cd6e8]
  - @srcbook/shared@0.0.10

## 0.0.3

### Patch Changes

- 459b18d: Deploy all packages
- Updated dependencies [459b18d]
  - @srcbook/shared@0.0.9

## 0.0.2

### Patch Changes

- 24c841e: Update websocket client to pass context and connection
- Updated dependencies [24c841e]
  - @srcbook/shared@0.0.8

================
File: components/package.json
================
{
  "name": "@srcbook/components",
  "version": "0.0.7",
  "type": "module",
  "main": "./dist/index.js",
  "scripts": {
    "prebuild": "rm -rf ./dist",
    "build": "tsc",
    "dev": "tsc --watch --project .",
    "lint": "eslint . --max-warnings 0",
    "check-types": "tsc",
    "prepublishOnly": "npm run build"
  },
  "dependencies": {
    "@codemirror/autocomplete": "^6.18.1",
    "@codemirror/lang-javascript": "^6.2.2",
    "@codemirror/lang-markdown": "^6.2.5",
    "@codemirror/lint": "^6.8.1",
    "@codemirror/merge": "^6.7.0",
    "@codemirror/state": "^6.4.1",
    "@lezer/highlight": "^1.2.1",
    "@lezer/javascript": "^1.4.17",
    "@radix-ui/react-collapsible": "^1.1.0",
    "@radix-ui/react-context-menu": "^2.2.2",
    "@radix-ui/react-dialog": "^1.1.1",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-icons": "^1.3.0",
    "@radix-ui/react-navigation-menu": "^1.2.0",
    "@radix-ui/react-popover": "^1.1.1",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-select": "^2.1.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.0",
    "@radix-ui/react-tabs": "^1.1.0",
    "@radix-ui/react-tooltip": "^1.1.2",
    "@srcbook/shared": "workspace:^",
    "@uiw/codemirror-themes": "^4.23.2",
    "@uiw/react-codemirror": "^4.23.2",
    "class-variance-authority": "^0.7.0",
    "cmdk": "^1.0.0",
    "marked": "catalog:",
    "marked-react": "^2.0.0",
    "mermaid": "^11.2.0",
    "react-resizable-panels": "^2.1.2"
  },
  "peerDependencies": {
    "@codemirror/autocomplete": "*",
    "@types/react": "*",
    "@uiw/react-codemirror": "*",
    "clsx": "*",
    "codemirror": "*",
    "lucide-react": "*",
    "react": "*",
    "react-hotkeys-hook": "*",
    "react-router-dom": "*",
    "react-textarea-autosize": "*",
    "sonner": "*",
    "tailwind-merge": "*",
    "use-debounce": "*"
  }
}

================
File: components/tsconfig.json
================
{
  "extends": "@srcbook/configs/ts/base.json",
  "compilerOptions": {
    "noEmit": false,
    "allowImportingTsExtensions": false,
    "outDir": "dist",
    "jsx": "react-jsx",
    "baseUrl": "."
  },
  "include": ["src/index.tsx", "src/**/*.ts", "src/**/*.tsx"],
  "exclude": ["node_modules", "dist"]
}

================
File: components/tsconfig.lint.json
================
{
  "include": ["index.tsx", "src"],
  "exclude": ["node_modules", "dist"]
}

================
File: configs/eslint/library.js
================
const { resolve } = require('node:path');

const project = resolve(process.cwd(), 'tsconfig.json');

/** @type {import("eslint").Linter.Config} */
module.exports = {
  extends: ['prettier', 'turbo'],
  globals: {
    React: true,
    JSX: true,
  },
  env: {
    node: true,
  },
  settings: {
    'import/resolver': {
      typescript: {
        project,
      },
    },
  },
  ignorePatterns: [
    // Ignore dotfiles
    '.*.js',
    'node_modules/',
    'dist/',
    'public/',
  ],
  overrides: [
    {
      files: ['*.js?(x)', '*.ts?(x)', '*.mts'],
    },
  ],
};

================
File: configs/eslint/react.js
================
const { resolve } = require('node:path');

const project = resolve(process.cwd(), 'tsconfig.json');

/** @type {import("eslint").Linter.Config} */
module.exports = {
  extends: [
    'prettier',
    'turbo',
    'plugin:jsx-a11y/recommended',
    // legacy rules to be reworked
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
  ],
  plugins: [
    'jsx-a11y',
    // legacy plugins to be reworked
    'react-refresh',
    'prettier',
    'jest',
  ],
  rules: {
    // legacy rules to be reworked
    '@typescript-eslint/no-unused-vars': [
      'warn',
      {
        argsIgnorePattern: '^_',
        varsIgnorePattern: '^_',
        caughtErrorsIgnorePattern: '^_',
      },
    ],
  },
  globals: {
    React: true,
    JSX: true,
  },
  env: {
    browser: true,
    // legacy env to be reworked
    es2020: true,
    'jest/globals': true,
  },
  settings: {
    'import/resolver': {
      typescript: {
        project,
      },
    },
  },
  ignorePatterns: [
    // Ignore dotfiles
    '.*.js',
    'node_modules/',
    'dist/',
  ],
  overrides: [
    {
      files: ['*.js?(x)', '*.ts?(x)'],
    },
  ],
};

================
File: configs/ts/base.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "Default",
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "esModuleInterop": true,
    "incremental": false,
    "isolatedModules": true,
    "useDefineForClassFields": true,
    "lib": ["es2022", "DOM", "DOM.Iterable"],
    "module": "esnext",
    "moduleDetection": "force",
    "moduleResolution": "bundler",
    "noUncheckedIndexedAccess": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "strict": true,
    "target": "ES2022",
    "noEmit": true,
    "allowImportingTsExtensions": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  }
}

================
File: configs/ts/react-library.json
================
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "display": "React Library",
  "extends": "./base.json",
  "compilerOptions": {
    "jsx": "react-jsx"
  }
}

================
File: configs/package.json
================
{
  "name": "@srcbook/configs",
  "version": "0.0.0",
  "private": true,
  "files": [
    "./eslint/library.js"
  ],
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^8.5.0",
    "@typescript-eslint/parser": "^8.5.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-config-turbo": "^2.1.1",
    "eslint-plugin-jest": "^28.8.3",
    "eslint-plugin-jsx-a11y": "^6.10.0",
    "eslint-plugin-prettier": "^5.2.1",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "^0.4.11"
  }
}

================
File: shared/src/schemas/apps.mts
================
import z from 'zod';

export const FileSchema = z.object({
  path: z.string(),
  name: z.string(),
  source: z.string(),
  binary: z.boolean(),
});

================
File: shared/src/schemas/cells.mts
================
import z from 'zod';

export const TitleCellSchema = z.object({
  id: z.string(),
  type: z.literal('title'),
  text: z.string(),
});

export const MarkdownCellSchema = z.object({
  id: z.string(),
  type: z.literal('markdown'),
  text: z.string(),
});

export const PackageJsonCellSchema = z.object({
  id: z.string(),
  type: z.literal('package.json'),
  source: z.string(),
  filename: z.literal('package.json'),
  status: z.enum(['idle', 'running', 'failed']),
});

export const CodeCellSchema = z.object({
  id: z.string(),
  type: z.literal('code'),
  source: z.string(),
  language: z.enum(['javascript', 'typescript']),
  filename: z.string(),
  status: z.enum(['idle', 'running']),
});

// Placeholder cells are used when instructing AI where to insert generated cell(s).
export const PlaceholderCellSchema = z.object({
  id: z.string(),
  type: z.literal('placeholder'),
  text: z.string(),
});

export const CellSchema = z.union([
  TitleCellSchema,
  MarkdownCellSchema,
  PackageJsonCellSchema,
  CodeCellSchema,
]);

export const CellWithPlaceholderSchema = z.union([
  TitleCellSchema,
  MarkdownCellSchema,
  PackageJsonCellSchema,
  CodeCellSchema,
  PlaceholderCellSchema,
]);

// Used to parse metadata from a srcbook header in .src.md.
//
// i.e. <!-- srcbook:{"language": "javascript"} -->
//
export const SrcbookMetadataSchema = z.object({
  language: z.enum(['javascript', 'typescript']),
  'tsconfig.json': z.optional(z.string()),
});

///////////////////////////////////////////
// ATTRIBUTES ALLOWED IN UPDATE REQUESTS //
///////////////////////////////////////////

export const TitleCellUpdateAttrsSchema = z.object({
  text: z.string().max(44, 'Title must be 44 characters or fewer'),
});

export const MarkdownCellUpdateAttrsSchema = z.object({
  text: z.string(),
});

export const PackageJsonCellUpdateAttrsSchema = z.object({
  source: z.string(),
});

// filename not allowed here because renaming
// a file has a separate websocket message.
export const CodeCellUpdateAttrsSchema = z.object({
  source: z.string(),
});

export const CellUpdateAttrsSchema = z.union([
  TitleCellUpdateAttrsSchema,
  MarkdownCellUpdateAttrsSchema,
  PackageJsonCellUpdateAttrsSchema,
  CodeCellUpdateAttrsSchema,
]);

================
File: shared/src/schemas/tsserver.mts
================
import z from 'zod';

export const TsServerLocationSchema = z.object({
  line: z.number(),
  offset: z.number(),
});

export const TsServerDiagnosticSchema = z.object({
  code: z.number(),
  category: z.string(),
  text: z.string(),
  start: TsServerLocationSchema,
  end: TsServerLocationSchema,
});

export const TsServerSuggestionSchema = z.object({
  code: z.number(),
  category: z.string(),
  text: z.string(),
  start: TsServerLocationSchema,
  end: TsServerLocationSchema,
});

export const TsServerQuickInfoRequestSchema = z.object({
  location: TsServerLocationSchema,
});

export const TsServerJSDocSchema = z
  .union([
    z.string(),
    z.array(
      z.object({
        text: z.string(),
        kind: z.string(),
      }),
    ),
  ])
  .optional();

export const TsServerJsDocTagsSchema = z.array(
  z.object({
    name: z.string(),
    text: TsServerJSDocSchema,
  }),
);

export const TsServerQuickInfoResponseSchema = z.object({
  kind: z.string(),
  kindModifiers: z.string(),
  start: TsServerLocationSchema,
  end: TsServerLocationSchema,
  displayString: z.string(),
  documentation: TsServerJSDocSchema,
  tags: TsServerJsDocTagsSchema,
});

export const TsServerCompletionEntriesSchema = z.nullable(
  z.object({
    entries: z.array(
      z.object({
        name: z.string(),
        kind: z.string(),
        kindModifiers: z.string(),
      }),
    ),
  }),
);

export const TsServerDefinitionLocationSchema = z.nullable(
  z.object({
    file: z.string(),
    start: TsServerLocationSchema,
    end: TsServerLocationSchema,
    contextStart: TsServerLocationSchema.optional(),
    contextEnd: TsServerLocationSchema.optional(),
  }),
);

================
File: shared/src/schemas/websockets.mts
================
import z from 'zod';
import { CellSchema, MarkdownCellSchema, CodeCellSchema, CellUpdateAttrsSchema } from './cells.mjs';
import {
  TsServerDefinitionLocationSchema,
  TsServerDiagnosticSchema,
  TsServerQuickInfoRequestSchema,
  TsServerQuickInfoResponseSchema,
  TsServerCompletionEntriesSchema,
} from './tsserver.mjs';
import { FileSchema } from './apps.mjs';

// A _message_ over websockets
export const WebSocketMessageSchema = z.tuple([
  z.string(), // The _topic_, eg: "sessions:123"
  z.string(), // The _event_, eg: "cell:updated"
  z.record(z.string(), z.any()), // The _payload_, eg: "{cell: {<cell properties>}}"
]);

export const CellExecPayloadSchema = z.object({
  cellId: z.string(),
});

export const CellStopPayloadSchema = z.object({
  cellId: z.string(),
});

export const CellCreatePayloadSchema = z.object({
  index: z.number(),
  cell: z.union([MarkdownCellSchema, CodeCellSchema]),
});

export const CellUpdatePayloadSchema = z.object({
  cellId: z.string(),
  updates: CellUpdateAttrsSchema,
});

export const CellFormatPayloadSchema = z.object({
  cellId: z.string(),
});

export const AiGenerateCellPayloadSchema = z.object({
  cellId: z.string(),
  prompt: z.string(),
});

export const AiFixDiagnosticsPayloadSchema = z.object({
  cellId: z.string(),
  diagnostics: z.string(),
});

export const CellRenamePayloadSchema = z.object({
  cellId: z.string(),
  filename: z.string(),
});

export const CellDeletePayloadSchema = z.object({
  cellId: z.string(),
});

export const CellErrorPayloadSchema = z.object({
  cellId: z.string(),
  errors: z.array(
    z.object({
      message: z.string(),
      attribute: z.string().optional(),
    }),
  ),
});

export const CellUpdatedPayloadSchema = z.object({
  cell: CellSchema,
});

export const CellFormattedPayloadSchema = z.object({
  cellId: z.string(),
  cell: CellSchema,
});
export const AiGeneratedCellPayloadSchema = z.object({
  cellId: z.string(),
  output: z.string(),
});

export const CellOutputPayloadSchema = z.object({
  cellId: z.string(),
  output: z.object({
    type: z.enum(['stdout', 'stderr']),
    data: z.string(),
  }),
});

export const DepsValidatePayloadSchema = z.object({});

export const DepsValidateResponsePayloadSchema = z.object({
  packages: z.array(z.string()).optional(),
});

export const TsServerStartPayloadSchema = z.object({});

export const TsServerStopPayloadSchema = z.object({});

export const TsServerCellDiagnosticsPayloadSchema = z.object({
  cellId: z.string(),
  diagnostics: z.array(TsServerDiagnosticSchema),
});

export const TsServerCellSuggestionsPayloadSchema = z.object({
  cellId: z.string(),
  diagnostics: z.array(TsServerDiagnosticSchema),
});

export const TsServerQuickInfoRequestPayloadSchema = z.object({
  cellId: z.string(),
  request: TsServerQuickInfoRequestSchema,
});

export const TsServerQuickInfoResponsePayloadSchema = z.object({
  response: TsServerQuickInfoResponseSchema,
});

export const TsServerDefinitionLocationRequestPayloadSchema = z.object({
  cellId: z.string(),
  request: TsServerQuickInfoRequestSchema,
});

export const TsServerDefinitionLocationResponsePayloadSchema = z.object({
  response: TsServerDefinitionLocationSchema,
});

export const TsServerCompletionEntriesPayloadSchema = z.object({
  response: TsServerCompletionEntriesSchema,
});

export const TsConfigUpdatePayloadSchema = z.object({
  source: z.string(),
});

export const TsConfigUpdatedPayloadSchema = z.object({
  source: z.string(),
});

//////////
// APPS //
//////////

export const FilePayloadSchema = z.object({
  file: FileSchema,
});

export const FileCreatedPayloadSchema = z.object({
  file: FileSchema,
});

// Used both from client > server and server > client
export const FileUpdatedPayloadSchema = z.object({
  file: FileSchema,
});

export const FileRenamedPayloadSchema = z.object({
  oldPath: z.string(),
  newPath: z.string(),
});

export const FileDeletedPayloadSchema = z.object({
  path: z.string(),
});

export const PreviewStatusPayloadSchema = z.union([
  z.object({ url: z.string().nullable(), status: z.enum(['booting', 'running']) }),
  z.object({
    url: z.string().nullable(),
    status: z.literal('stopped'),
    code: z.number().int().nullable(),
  }),
]);

export const PreviewStartPayloadSchema = z.object({});
export const PreviewStopPayloadSchema = z.object({});

export const PreviewLogPayloadSchema = z.object({
  log: z.union([
    z.object({ type: z.literal('stdout'), data: z.string() }),
    z.object({ type: z.literal('stderr'), data: z.string() }),
  ]),
});

export const DepsInstallLogPayloadSchema = z.object({
  log: z.union([
    z.object({ type: z.literal('stdout'), data: z.string() }),
    z.object({ type: z.literal('stderr'), data: z.string() }),
  ]),
});

export const DepsInstallStatusPayloadSchema = z.union([
  z.object({ status: z.literal('installing') }),
  z.object({
    status: z.enum(['complete', 'failed']),
    code: z.number().int(),
  }),
]);

export const DepsClearPayloadSchema = z.object({});
export const DepsStatusPayloadSchema = z.object({});
export const DepsStatusResponsePayloadSchema = z.object({
  nodeModulesExists: z.boolean(),
});

///////////////////////
// APPS & NOTEBOOKS //
///////////////////////
export const DepsInstallPayloadSchema = z.object({
  packages: z.array(z.string()).optional(),
});

================
File: shared/src/types/apps.mts
================
import z from 'zod';

import { FileSchema } from '../schemas/apps.mjs';

export type AppType = {
  id: string;
  name: string;
  createdAt: number;
  updatedAt: number;
};

export type DirEntryType = {
  type: 'directory';
  // The full path relative to app root, e.g. src/assets
  path: string;
  // The path dirname relative to app root, e.g. src
  dirname: string;
  // The path basename relative to app root, e.g. assets
  basename: string;
  // null if not loaded
  children: FsEntryTreeType | null;
};

export type FileEntryType = {
  type: 'file';
  // The full path relative to app root, e.g. src/components/input.tsx
  path: string;
  // The path dirname relative to app root, e.g. src/components
  dirname: string;
  // The path basename relative to app root, e.g. input.tsx
  basename: string;
};

export type FsEntryTreeType = Array<FileEntryType | DirEntryType>;

export type FileType = z.infer<typeof FileSchema>;

================
File: shared/src/types/cells.mts
================
import z from 'zod';

import {
  TitleCellSchema,
  MarkdownCellSchema,
  PackageJsonCellSchema,
  CodeCellSchema,
  PlaceholderCellSchema,
  CellSchema,
  CellWithPlaceholderSchema,
  TitleCellUpdateAttrsSchema,
  MarkdownCellUpdateAttrsSchema,
  PackageJsonCellUpdateAttrsSchema,
  CodeCellUpdateAttrsSchema,
  CellUpdateAttrsSchema,
  SrcbookMetadataSchema,
} from '../schemas/cells.mjs';

export type TitleCellType = z.infer<typeof TitleCellSchema>;
export type MarkdownCellType = z.infer<typeof MarkdownCellSchema>;
export type PackageJsonCellType = z.infer<typeof PackageJsonCellSchema>;
export type CodeCellType = z.infer<typeof CodeCellSchema>;
export type PlaceholderCellType = z.infer<typeof PlaceholderCellSchema>;

export type CellType = z.infer<typeof CellSchema>;
export type CellWithPlaceholderType = z.infer<typeof CellWithPlaceholderSchema>;

export type TitleCellUpdateAttrsType = z.infer<typeof TitleCellUpdateAttrsSchema>;
export type MarkdownCellUpdateAttrsType = z.infer<typeof MarkdownCellUpdateAttrsSchema>;
export type PackageJsonCellUpdateAttrsType = z.infer<typeof PackageJsonCellUpdateAttrsSchema>;
export type CodeCellUpdateAttrsType = z.infer<typeof CodeCellUpdateAttrsSchema>;
export type CellUpdateAttrsType = z.infer<typeof CellUpdateAttrsSchema>;

export type CellErrorType = {
  message: string;
  attribute?: string;
};

export type CodeLanguageType = 'javascript' | 'typescript';

export type SrcbookMetadataType = z.infer<typeof SrcbookMetadataSchema>;

================
File: shared/src/types/feedback.mts
================
export type AppGenerationFeedbackType = {
  planId: string;
  feedback: any;
};

================
File: shared/src/types/history.mts
================
export type FileDiffType = {
  modified: string;
  original: string | null;
  basename: string;
  dirname: string;
  path: string;
  additions: number;
  deletions: number;
  type: 'edit' | 'create' | 'delete';
};

export type UserMessageType = {
  type: 'user';
  message: string;
  planId: string;
};

export type CommandMessageType = {
  type: 'command';
  planId: string;
  command: 'npm install';
  packages: string[];
  description: string;
};

export type DiffMessageType = {
  type: 'diff';
  planId: string;
  version: string;
  diff: FileDiffType[];
};

export type PlanMessageType = {
  type: 'plan';
  planId: string;
  content: string;
};

export type MessageType = UserMessageType | DiffMessageType | CommandMessageType | PlanMessageType;

export type HistoryType = Array<MessageType>;

//////////////////////////////////////////
// When streaming file objects from LLM //
//////////////////////////////////////////

export type DescriptionChunkType = {
  type: 'description';
  planId: string;
  data: { content: string };
};

export type FileActionChunkType = {
  type: 'file';
  description: string;
  modified: string;
  original: string | null;
  basename: string;
  dirname: string;
  path: string;
};

export type CommandActionChunkType = {
  type: 'command';
  description: string;
  command: 'npm install';
  packages: string[];
};

export type ActionChunkType = {
  type: 'action';
  planId: string;
  data: FileActionChunkType | CommandActionChunkType;
};

================
File: shared/src/types/secrets.mts
================
export type SecretWithAssociatedSessions = {
  name: string;
  value: string;
  associatedWithSessionIds: Array<string>;
};

================
File: shared/src/types/tsserver.mts
================
import z from 'zod';

import {
  TsServerLocationSchema,
  TsServerDiagnosticSchema,
  TsServerSuggestionSchema,
  TsServerQuickInfoRequestSchema,
  TsServerJSDocSchema,
  TsServerJsDocTagsSchema,
  TsServerQuickInfoResponseSchema,
  TsServerDefinitionLocationSchema,
} from '../schemas/tsserver.mjs';

export type TsServerLocationType = z.infer<typeof TsServerLocationSchema>;
export type TsServerDiagnosticType = z.infer<typeof TsServerDiagnosticSchema>;
export type TsServerSuggestionType = z.infer<typeof TsServerSuggestionSchema>;
export type TsServerQuickInfoRequestType = z.infer<typeof TsServerQuickInfoRequestSchema>;
export type TsServerJSDocType = z.infer<typeof TsServerJSDocSchema>;
export type TsServerJsDocTagsType = z.infer<typeof TsServerJsDocTagsSchema>;
export type TsServerQuickInfoResponseType = z.infer<typeof TsServerQuickInfoResponseSchema>;
export type TsServerDefinitionLocationSchemaType = z.infer<typeof TsServerDefinitionLocationSchema>;

================
File: shared/src/types/websockets.mts
================
import z from 'zod';

import {
  CellExecPayloadSchema,
  CellStopPayloadSchema,
  CellCreatePayloadSchema,
  CellUpdatePayloadSchema,
  CellUpdatedPayloadSchema,
  CellFormatPayloadSchema,
  CellRenamePayloadSchema,
  CellDeletePayloadSchema,
  AiGenerateCellPayloadSchema,
  AiGeneratedCellPayloadSchema,
  CellOutputPayloadSchema,
  DepsInstallPayloadSchema,
  DepsValidateResponsePayloadSchema,
  DepsValidatePayloadSchema,
  CellErrorPayloadSchema,
  TsServerStartPayloadSchema,
  TsServerStopPayloadSchema,
  TsServerCellDiagnosticsPayloadSchema,
  TsConfigUpdatePayloadSchema,
  TsConfigUpdatedPayloadSchema,
  AiFixDiagnosticsPayloadSchema,
  TsServerCellSuggestionsPayloadSchema,
  TsServerQuickInfoRequestPayloadSchema,
  TsServerQuickInfoResponsePayloadSchema,
  CellFormattedPayloadSchema,
  TsServerDefinitionLocationRequestPayloadSchema,
  TsServerDefinitionLocationResponsePayloadSchema,
  TsServerCompletionEntriesPayloadSchema,
  FilePayloadSchema,
  FileCreatedPayloadSchema,
  FileUpdatedPayloadSchema,
  FileRenamedPayloadSchema,
  FileDeletedPayloadSchema,
  PreviewStatusPayloadSchema,
  PreviewStopPayloadSchema,
  PreviewStartPayloadSchema,
  DepsInstallLogPayloadSchema,
  DepsInstallStatusPayloadSchema,
  DepsClearPayloadSchema,
  DepsStatusPayloadSchema,
  DepsStatusResponsePayloadSchema,
  PreviewLogPayloadSchema,
} from '../schemas/websockets.mjs';

export type CellExecPayloadType = z.infer<typeof CellExecPayloadSchema>;
export type CellStopPayloadType = z.infer<typeof CellStopPayloadSchema>;
export type CellCreatePayloadType = z.infer<typeof CellCreatePayloadSchema>;
export type CellUpdatePayloadType = z.infer<typeof CellUpdatePayloadSchema>;
export type CellFormatPayloadType = z.infer<typeof CellFormatPayloadSchema>;
export type CellUpdatedPayloadType = z.infer<typeof CellUpdatedPayloadSchema>;
export type CellRenamePayloadType = z.infer<typeof CellRenamePayloadSchema>;
export type CellDeletePayloadType = z.infer<typeof CellDeletePayloadSchema>;
export type CellOutputPayloadType = z.infer<typeof CellOutputPayloadSchema>;
export type AiGenerateCellPayloadType = z.infer<typeof AiGenerateCellPayloadSchema>;
export type AiGeneratedCellPayloadType = z.infer<typeof AiGeneratedCellPayloadSchema>;
export type AiFixDiagnosticsPayloadType = z.infer<typeof AiFixDiagnosticsPayloadSchema>;

export type DepsInstallPayloadType = z.infer<typeof DepsInstallPayloadSchema>;
export type DepsClearPayloadType = z.infer<typeof DepsClearPayloadSchema>;
export type DepsStatusPayloadType = z.infer<typeof DepsStatusPayloadSchema>;
export type DepsStatusResponsePayloadType = z.infer<typeof DepsStatusResponsePayloadSchema>;
export type DepsValidateResponsePayloadType = z.infer<typeof DepsValidateResponsePayloadSchema>;
export type DepsValidatePayloadType = z.infer<typeof DepsValidatePayloadSchema>;

export type CellErrorPayloadType = z.infer<typeof CellErrorPayloadSchema>;
export type CellFormattedPayloadType = z.infer<typeof CellFormattedPayloadSchema>;

export type TsServerStartPayloadType = z.infer<typeof TsServerStartPayloadSchema>;
export type TsServerStopPayloadType = z.infer<typeof TsServerStopPayloadSchema>;
export type TsServerCellDiagnosticsPayloadType = z.infer<
  typeof TsServerCellDiagnosticsPayloadSchema
>;
export type TsServerCellSuggestionsPayloadType = z.infer<
  typeof TsServerCellSuggestionsPayloadSchema
>;

export type TsConfigUpdatePayloadType = z.infer<typeof TsConfigUpdatePayloadSchema>;
export type TsConfigUpdatedPayloadType = z.infer<typeof TsConfigUpdatedPayloadSchema>;

export type TsServerQuickInfoRequestPayloadType = z.infer<
  typeof TsServerQuickInfoRequestPayloadSchema
>;
export type TsServerQuickInfoResponsePayloadType = z.infer<
  typeof TsServerQuickInfoResponsePayloadSchema
>;

export type TsServerDefinitionLocationRequestPayloadType = z.infer<
  typeof TsServerDefinitionLocationRequestPayloadSchema
>;
export type TsServerDefinitionLocationResponsePayloadType = z.infer<
  typeof TsServerDefinitionLocationResponsePayloadSchema
>;

export type TsServerCompletionEntriesPayloadType = z.infer<
  typeof TsServerCompletionEntriesPayloadSchema
>;

//////////
// APPS //
//////////

export type FilePayloadType = z.infer<typeof FilePayloadSchema>;
export type FileCreatedPayloadType = z.infer<typeof FileCreatedPayloadSchema>;
export type FileUpdatedPayloadType = z.infer<typeof FileUpdatedPayloadSchema>;
export type FileRenamedPayloadType = z.infer<typeof FileRenamedPayloadSchema>;
export type FileDeletedPayloadType = z.infer<typeof FileDeletedPayloadSchema>;
export type PreviewStatusPayloadType = z.infer<typeof PreviewStatusPayloadSchema>;
export type PreviewStartPayloadType = z.infer<typeof PreviewStartPayloadSchema>;
export type PreviewStopPayloadType = z.infer<typeof PreviewStopPayloadSchema>;
export type PreviewLogPayloadType = z.infer<typeof PreviewLogPayloadSchema>;
export type DepsInstallLogPayloadType = z.infer<typeof DepsInstallLogPayloadSchema>;
export type DepsInstallStatusPayloadType = z.infer<typeof DepsInstallStatusPayloadSchema>;

================
File: shared/src/ai.mts
================
export const AiProvider = {
  OpenAI: 'openai',
  Anthropic: 'anthropic',
  XAI: 'Xai',
  Gemini: 'Gemini',
  Custom: 'custom',
} as const;

export type AiProviderType = (typeof AiProvider)[keyof typeof AiProvider];

export const defaultModels: Record<AiProviderType, string> = {
  [AiProvider.OpenAI]: 'chatgpt-4o-latest',
  [AiProvider.Anthropic]: 'claude-3-5-sonnet-latest',
  [AiProvider.Custom]: 'mistral-nemo',
  [AiProvider.XAI]: 'grok-beta',
  [AiProvider.Gemini]: 'gemini-1.5-pro-latest',
} as const;

export function isValidProvider(provider: string): provider is AiProviderType {
  return Object.values(AiProvider).includes(provider as AiProviderType);
}

export function getDefaultModel(provider: AiProviderType): string {
  return defaultModels[provider];
}

================
File: shared/src/utils.mts
================
import { base32hexnopad } from '@scure/base';
import type { CodeLanguageType } from './types/cells.mjs';
import * as crypto from 'crypto';

export function isBrowser(): boolean {
  return typeof window !== 'undefined';
}

export function randomid(byteSize = 16) {
  const bytes = isBrowser()
    ? globalThis.crypto.getRandomValues(new Uint8Array(byteSize))
    : crypto.getRandomValues(new Uint8Array(byteSize));
  return base32hexnopad.encode(bytes).toLowerCase();
}

export function validFilename(filename: string) {
  return /^[a-zA-Z0-9_-]+\.(js|cjs|mjs|ts|cts|mts)$/.test(filename);
}

export function isJavaScriptFile(filename: string) {
  return /\.(js|cjs|mjs)$/.test(filename);
}

export function isTypeScriptFile(filename: string) {
  return /\.(ts|cts|mts)$/.test(filename);
}

export function languageFromFilename(filename: string): CodeLanguageType {
  if (isJavaScriptFile(filename)) {
    return 'javascript';
  } else if (isTypeScriptFile(filename)) {
    return 'typescript';
  } else {
    throw new Error(
      `Language is not one of 'javascript' or 'typescript' based on filename '${filename}'`,
    );
  }
}

export function extensionsForLanguage(language: CodeLanguageType) {
  switch (language) {
    case 'javascript':
      return ['js', 'cjs', 'mjs'];
    case 'typescript':
      return ['ts', 'cts', 'mts'];
    default:
      throw new Error(`Unrecognized language ${language}`);
  }
}

export function getDefaultExtensionForLanguage(language: CodeLanguageType) {
  switch (language) {
    case 'javascript':
      return '.js';
    case 'typescript':
      return '.ts';
    default:
      throw new Error(`Unrecognized language ${language}`);
  }
}

/**
 * Convert a ReadableStream<T> to an AsyncIterable<T>.
 *
 * ReadableStreams implement this natively in recent node versions. Unfortunately, older
 * node versions, most browsers, and the TypeScript type system do not support it yet.
 *
 * Example:
 *
 *     for await (const chunk of StreamToIterable(stream)) {
 *       // Do stuff with chunk
 *     }
 *
 * @param stream A ReadableStream.
 * @returns An AsyncIterable over the stream contents.
 */
export function StreamToIterable<T>(stream: ReadableStream<T>): AsyncIterable<T> {
  // @ts-ignore
  return stream[Symbol.asyncIterator] ? stream[Symbol.asyncIterator]() : createIterable(stream);
}

async function* createIterable<T>(stream: ReadableStream<T>): AsyncIterable<T> {
  const reader = stream.getReader();

  try {
    while (true) {
      const { done, value } = await reader.read();

      if (done) {
        return;
      }

      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}

================
File: shared/.eslintrc.cjs
================
/** @type {import("eslint").Linter.Config} */
module.exports = {
  root: true,
  extends: [require.resolve('@srcbook/configs/eslint/library.js')],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: './tsconfig.lint.json',
    tsconfigRootDir: __dirname,
  },
  globals: {
    Bun: false,
  },
};

================
File: shared/.npmignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

*.gitignored.*

================
File: shared/CHANGELOG.md
================
# @srcbook/shared

## 0.0.13

### Patch Changes

- a236470: Add gemini support

## 0.0.12

### Patch Changes

- 727bab7: Support X ai models
- 2e774d4: Support streaming of the responses!

## 0.0.11

### Patch Changes

- b49bdf4: The backend now notifies the frontend of file changes -> files update visually in realtime
- bbbd5d6: Add versions! powered by git. Ability to revert to an older version

## 0.0.10

### Patch Changes

- ccd8d01: Introduce app builder
- 73cd6e8: support backend hmr

## 0.0.9

### Patch Changes

- 459b18d: Deploy all packages

## 0.0.8

### Patch Changes

- 24c841e: Update websocket client to pass context and connection

## 0.0.7

### Patch Changes

- 691f81f: 480bf57: Adds autocomplete support!

## 0.0.6

### Patch Changes

- 0eb51dd: Added support for goto def with Alt(Option) + Click

## 0.0.5

### Patch Changes

- 8c99a0d: Fix broken NPM package

## 0.0.4

### Patch Changes

- 9f0a632: Secrets must now be enabled per Srcbook

## 0.0.3

### Patch Changes

- 545699e: Add Prettier Support to Code Notebook
- 833264c: Underlying dependency bumps for maintenence

## 0.0.2

### Patch Changes

- 735deb8: Resolve prod ERR_MODULE_NOT_FOUND prod issue

## 0.0.1

### Patch Changes

- 4e04909: hover tooltips, tooling improvements, new contributors effyzhang 1egoman!

================
File: shared/index.mts
================
export * from './src/schemas/apps.mjs';
export * from './src/schemas/cells.mjs';
export * from './src/schemas/tsserver.mjs';
export * from './src/schemas/websockets.mjs';
export * from './src/types/apps.mjs';
export * from './src/types/cells.mjs';
export * from './src/types/tsserver.mjs';
export * from './src/types/history.mjs';
export * from './src/types/websockets.mjs';
export * from './src/types/secrets.mjs';
export * from './src/types/feedback.mjs';
export * from './src/utils.mjs';
export * from './src/ai.mjs';

================
File: shared/package.json
================
{
  "name": "@srcbook/shared",
  "version": "0.0.13",
  "type": "module",
  "main": "./dist/index.mjs",
  "scripts": {
    "prebuild": "rimraf ./dist",
    "build": "tsc",
    "dev": "tsc --incremental --watch --project .",
    "lint": "eslint . --max-warnings 0",
    "check-types": "tsc",
    "prepublishOnly": "npm run build"
  },
  "dependencies": {
    "@ai-sdk/google": "1.0.1",
    "@scure/base": "^1.1.8",
    "zod": "catalog:"
  },
  "devDependencies": {
    "rimraf": "^6.0.1"
  }
}

================
File: shared/tsconfig.json
================
{
  "extends": "@srcbook/configs/ts/base.json",
  "compilerOptions": {
    "noEmit": false,
    "allowImportingTsExtensions": false,
    "outDir": "dist"
  },
  "include": ["index.mts", "src/**/*.mts"],
  "exclude": ["node_modules", "dist"]
}

================
File: shared/tsconfig.lint.json
================
{
  "include": ["index.mts", "src/**/*.mts"],
  "exclude": ["node_modules", "dist"]
}

================
File: web/src/clients/http/apps.ts
================
import type {
  ActionChunkType,
  AppGenerationFeedbackType,
  AppType,
  DescriptionChunkType,
  DirEntryType,
  FileEntryType,
  FileType,
} from '@srcbook/shared';
import SRCBOOK_CONFIG from '@/config';
import type { HistoryType, MessageType } from '@srcbook/shared';
import { StreamToIterable } from '@srcbook/shared';

const API_BASE_URL = `${SRCBOOK_CONFIG.api.origin}/api`;

export async function createApp(request: {
  name: string;
  prompt?: string;
}): Promise<{ data: AppType }> {
  const response = await fetch(API_BASE_URL + '/apps', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function deleteApp(id: string): Promise<void> {
  const response = await fetch(API_BASE_URL + '/apps/' + id, {
    method: 'DELETE',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }
}

export async function loadApps(sort: 'asc' | 'desc'): Promise<{ data: AppType[] }> {
  const response = await fetch(API_BASE_URL + '/apps?sort=' + sort, {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function loadApp(id: string): Promise<{ data: AppType }> {
  const response = await fetch(API_BASE_URL + '/apps/' + id, {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function updateApp(id: string, attrs: { name: string }): Promise<{ data: AppType }> {
  const response = await fetch(API_BASE_URL + '/apps/' + id, {
    method: 'PUT',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(attrs),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function loadDirectory(id: string, path: string): Promise<{ data: DirEntryType }> {
  const queryParams = new URLSearchParams({ path });

  const response = await fetch(API_BASE_URL + `/apps/${id}/directories?${queryParams}`, {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function createDirectory(
  id: string,
  dirname: string,
  basename: string,
): Promise<{ data: DirEntryType }> {
  const response = await fetch(API_BASE_URL + `/apps/${id}/directories`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ dirname, basename }),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function deleteDirectory(
  id: string,
  path: string,
): Promise<{ data: { deleted: true } }> {
  const queryParams = new URLSearchParams({ path });

  const response = await fetch(API_BASE_URL + `/apps/${id}/directories?${queryParams}`, {
    method: 'DELETE',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function renameDirectory(
  id: string,
  path: string,
  name: string,
): Promise<{ data: DirEntryType }> {
  const queryParams = new URLSearchParams({ path, name });

  const response = await fetch(API_BASE_URL + `/apps/${id}/directories/rename?${queryParams}`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function loadFile(id: string, path: string): Promise<{ data: FileType }> {
  const queryParams = new URLSearchParams({ path });

  const response = await fetch(API_BASE_URL + `/apps/${id}/files?${queryParams}`, {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function createFile(
  id: string,
  dirname: string,
  basename: string,
  source: string,
): Promise<{ data: FileEntryType }> {
  const response = await fetch(API_BASE_URL + `/apps/${id}/files`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ dirname, basename, source }),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function deleteFile(id: string, path: string): Promise<{ data: { deleted: true } }> {
  const queryParams = new URLSearchParams({ path });

  const response = await fetch(API_BASE_URL + `/apps/${id}/files?${queryParams}`, {
    method: 'DELETE',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function renameFile(
  id: string,
  path: string,
  name: string,
): Promise<{ data: FileEntryType }> {
  const queryParams = new URLSearchParams({ path, name });

  const response = await fetch(API_BASE_URL + `/apps/${id}/files/rename?${queryParams}`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function aiEditApp(
  id: string,
  query: string,
  planId: string,
): Promise<AsyncIterable<DescriptionChunkType | ActionChunkType>> {
  const response = await fetch(API_BASE_URL + `/apps/${id}/edit`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ query, planId }),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  const JSONDecoder = new TransformStream<string, DescriptionChunkType | ActionChunkType>({
    transform(chunk, controller) {
      const lines = chunk.split('\n');
      for (const line of lines) {
        if (line.trim() !== '') {
          const parsed = JSON.parse(line);
          controller.enqueue(parsed);
        }
      }
    },
  });

  return StreamToIterable(
    response.body!.pipeThrough(new TextDecoderStream()).pipeThrough(JSONDecoder),
  );
}

export async function loadHistory(id: string): Promise<{ data: HistoryType }> {
  const response = await fetch(API_BASE_URL + `/apps/${id}/history`, {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function appendToHistory(id: string, messages: MessageType | MessageType[]) {
  const response = await fetch(API_BASE_URL + `/apps/${id}/history`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ messages }),
  });
  return response.json();
}

export async function aiGenerationFeedback(id: string, feedback: AppGenerationFeedbackType) {
  const response = await fetch(API_BASE_URL + `/apps/${id}/feedback`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(feedback),
  });
  return response.json();
}

export async function exportApp(id: string, name: string): Promise<Blob> {
  const response = await fetch(API_BASE_URL + `/apps/${id}/export`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ name }),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Export failed');
  }

  return response.blob();
}

type VersionResponse = {
  sha: string;
};

export async function getCurrentVersion(id: string): Promise<VersionResponse> {
  const response = await fetch(API_BASE_URL + `/apps/${id}/commit`, {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });
  return response.json();
}

export async function commitVersion(id: string, message: string): Promise<VersionResponse> {
  const response = await fetch(API_BASE_URL + `/apps/${id}/commit`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ message }),
  });

  return response.json();
}

export async function checkoutVersion(
  id: string,
  sha: string,
): Promise<{ success: true; sha: string }> {
  const response = await fetch(API_BASE_URL + `/apps/${id}/checkout/${sha}`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
  });
  return response.json();
}

================
File: web/src/clients/websocket/channel.ts
================
/* eslint-disable @typescript-eslint/no-explicit-any */

import z from 'zod';
import WebSocketClient from '@/clients/websocket/client';
import { randomid } from '@srcbook/shared';

export default class Channel<
  I extends Record<string, z.ZodSchema<any>>,
  O extends Record<string, z.ZodSchema<any>>,
> {
  readonly topic: string;

  readonly events: {
    incoming: I;
    outgoing: O;
  };

  private subscribed: boolean;

  private subscriptionId: string | null;

  private readonly queue: Array<
    {
      [K in keyof O & string]: {
        event: K;
        payload: z.TypeOf<O[K]>;
      };
    }[keyof O & string]
  >;

  private readonly client: WebSocketClient;

  private readonly callbacks: Record<string, Array<(payload: Record<string, any>) => void>>;

  private readonly receive: <K extends keyof I & string>(event: K, payload: z.TypeOf<I[K]>) => void;

  constructor(client: WebSocketClient, topic: string, events: { incoming: I; outgoing: O }) {
    this.topic = topic;
    this.queue = [];
    this.client = client;
    this.events = events;
    this.callbacks = {};
    this.subscribed = false;
    this.subscriptionId = null;

    this.receive = <K extends keyof I & string>(event: K, payload: z.TypeOf<I[K]>) => {
      if (event === 'subscribed') {
        this.receiveSubscribedEvent(payload);
        return;
      }

      // Ignore events until we are subscribed.
      if (!this.subscribed) {
        return;
      }

      const schema = this.events.incoming[event];

      if (schema === undefined) {
        throw new Error(`Channel received unknown event '${event}' for topic '${this.topic}'`);
      }

      const result = schema.safeParse(payload);

      if (!result.success) {
        throw new Error(
          `Channel received invalid payload for '${event}' and topic '${this.topic}':\n\n${JSON.stringify(payload)}\n\n`,
        );
      }

      for (const callback of this.callbacks[event] || []) {
        callback(result.data);
      }
    };
  }

  subscribe() {
    if (this.subscribed) {
      return;
    }

    this.subscriptionId = randomid();
    this.client.push(this.topic, 'subscribe', { id: this.subscriptionId });
    this.client.on(this.topic, this.receive);
  }

  unsubscribe() {
    this.subscribed = false;
    this.subscriptionId = null;
    this.client.push(this.topic, 'unsubscribe', {});
    this.client.off(this.topic, this.receive);
  }

  on<K extends keyof I & string>(event: K, callback: (payload: z.TypeOf<I[K]>) => void): void {
    this.callbacks[event] = this.callbacks[event] || [];
    this.callbacks[event]?.push(callback);
  }

  off<K extends keyof I & string>(event: K, callback: (payload: z.TypeOf<I[K]>) => void): void {
    const callbacks = (this.callbacks[event] || []).filter((cb) => cb !== callback);

    if (callbacks.length === 0) {
      delete this.callbacks[event];
    } else {
      this.callbacks[event] = callbacks;
    }
  }

  push<K extends keyof O & string>(event: K, payload: z.TypeOf<O[K]>): void {
    // Queue outgoing events until we are subscribed.
    if (!this.subscribed) {
      this.queue.push({ event, payload });
      return;
    }

    const schema = this.events.outgoing[event];

    if (schema === undefined) {
      throw new Error(`Cannot push unknown event '${event}' for topic '${this.topic}'`);
    }

    this.client.push(this.topic, event, schema.parse(payload));
  }

  private receiveSubscribedEvent(payload: { id: string }) {
    // This shouldn't normally happen, but could if multiple channels for the
    // same topic were used or if duplicate events sent (cough cough, useEffect).
    if (this.subscriptionId !== payload.id) {
      return;
    }

    this.subscribed = true;
    this.subscriptionId = null;
    this.flush();
  }

  private flush() {
    while (this.queue.length > 0) {
      const message = this.queue.shift()!;
      this.push(message.event, message.payload);
    }
  }
}

================
File: web/src/clients/websocket/client.ts
================
/* eslint-disable @typescript-eslint/no-explicit-any */

import { WebSocketMessageSchema } from '@srcbook/shared';

// A connection that is closed on purpose for "normal" reasons.
// https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1
const EXPECTED_CLOSURE_CODE = 1000;

// If we lose a connection unexpectedly, retry with a backoff strategy.
const RETRY_IN_MS = [10, 250, 1000, 2500];
const DEFAULT_RETRY_IN_MS = 5000;

export default class WebSocketClient {
  private url: string;

  private socket: WebSocket | null = null;

  private queue: { topic: string; event: string; payload: Record<string, any> }[] = [];

  private callbacks: Record<string, Array<(event: string, payload: Record<string, any>) => void>> =
    {};

  private currentRetry = 0;

  constructor(url: string) {
    this.url = url;
    this.connect();
  }

  get open() {
    return this.socket !== null && this.socket.readyState === WebSocket.OPEN;
  }

  on(topic: string, callback: (event: string, payload: Record<string, any>) => void) {
    this.callbacks[topic] = this.callbacks[topic] || [];
    this.callbacks[topic]?.push(callback);
  }

  off(topic: string, callback: (event: string, payload: Record<string, any>) => void) {
    const callbacks = (this.callbacks[topic] || []).filter((cb) => cb !== callback);

    if (callbacks.length === 0) {
      delete this.callbacks[topic];
    } else {
      this.callbacks[topic] = callbacks;
    }
  }

  push(topic: string, event: string, payload: Record<string, any>) {
    if (this.open) {
      this.send(topic, event, payload);
    } else {
      this.queue.push({ topic, event, payload });
    }
  }

  private flush() {
    while (this.queue.length > 0) {
      const message = this.queue.shift()!;
      this.send(message.topic, message.event, message.payload);
    }
  }

  private send(topic: string, event: string, payload: Record<string, any>) {
    const message = JSON.stringify([topic, event, payload]);

    if (this.socket && this.open) {
      this.socket.send(message);
    } else {
      console.error(
        `Attempting to send a message to a socket with readyState '${this.humanReadyState()}'. This is a bug in WebSocketClient.\n\nMessage:\n${message}`,
      );
    }
  }

  private humanReadyState() {
    switch (this.socket?.readyState) {
      case WebSocket.CONNECTING:
        return 'CONNECTING';
      case WebSocket.OPEN:
        return 'OPEN';
      case WebSocket.CLOSING:
        return 'CLOSING';
      case WebSocket.CLOSED:
        return 'CLOSED';
      default:
        // This should never happen.
        return 'UNKNOWN';
    }
  }

  private handleIncomingMessage(eventData: string) {
    const parsed = JSON.parse(eventData);
    const [topic, event, payload] = WebSocketMessageSchema.parse(parsed);
    for (const callback of this.callbacks[topic] || []) {
      callback(event, payload);
    }
  }

  private retryInMs() {
    return RETRY_IN_MS[this.currentRetry - 1] || DEFAULT_RETRY_IN_MS;
  }

  private onOpen = () => {
    this.currentRetry = 0;
    this.flush();
  };

  private onMessage = (event: MessageEvent<any>) => {
    if (event.type === 'message') {
      this.handleIncomingMessage(event.data);
    } else {
      console.warn(`Received unknown WebSocket event '${event.type}'`);
    }
  };

  private onClose = (event: CloseEvent) => {
    this.teardown();

    // If we lost the connection for unexpected reasons, retry.
    if (event.code !== EXPECTED_CLOSURE_CODE) {
      this.currentRetry += 1;
      setTimeout(this.connect, this.retryInMs());
    }
  };

  private onError = () => {
    // NO-OP for now
  };

  private connect = () => {
    this.socket = new WebSocket(this.url);
    this.socket.addEventListener('open', this.onOpen);
    this.socket.addEventListener('message', this.onMessage);
    this.socket.addEventListener('close', this.onClose);
    this.socket.addEventListener('error', this.onError);
  };

  private teardown() {
    if (this.socket) {
      this.socket.removeEventListener('open', this.onOpen);
      this.socket.removeEventListener('message', this.onMessage);
      this.socket.removeEventListener('close', this.onClose);
      this.socket.removeEventListener('error', this.onError);
    }

    this.socket = null;
  }
}

================
File: web/src/clients/websocket/index.ts
================
import {
  CellOutputPayloadSchema,
  CellCreatePayloadSchema,
  AiGenerateCellPayloadSchema,
  AiGeneratedCellPayloadSchema,
  CellUpdatedPayloadSchema,
  CellFormattedPayloadSchema,
  CellFormatPayloadSchema,
  DepsValidateResponsePayloadSchema,
  CellExecPayloadSchema,
  CellStopPayloadSchema,
  DepsInstallPayloadSchema,
  DepsValidatePayloadSchema,
  CellUpdatePayloadSchema,
  CellErrorPayloadSchema,
  TsServerStartPayloadSchema,
  TsServerStopPayloadSchema,
  CellDeletePayloadSchema,
  TsServerCellDiagnosticsPayloadSchema,
  CellRenamePayloadSchema,
  TsConfigUpdatePayloadSchema,
  TsConfigUpdatedPayloadSchema,
  AiFixDiagnosticsPayloadSchema,
  TsServerCellSuggestionsPayloadSchema,
  TsServerQuickInfoRequestPayloadSchema,
  TsServerQuickInfoResponsePayloadSchema,
  TsServerDefinitionLocationResponsePayloadSchema,
  TsServerDefinitionLocationRequestPayloadSchema,
  TsServerCompletionEntriesPayloadSchema,
  FileCreatedPayloadSchema,
  FileUpdatedPayloadSchema,
  FileRenamedPayloadSchema,
  FileDeletedPayloadSchema,
  FilePayloadSchema,
  PreviewStatusPayloadSchema,
  PreviewStartPayloadSchema,
  PreviewStopPayloadSchema,
  DepsInstallLogPayloadSchema,
  DepsInstallStatusPayloadSchema,
  DepsClearPayloadSchema,
  DepsStatusResponsePayloadSchema,
  DepsStatusPayloadSchema,
  PreviewLogPayloadSchema,
} from '@srcbook/shared';
import Channel from '@/clients/websocket/channel';
import WebSocketClient from '@/clients/websocket/client';
import SRCBOOK_CONFIG from '@/config';

// Establish websocket connection immediately.
const client = new WebSocketClient(`ws://${SRCBOOK_CONFIG.api.host}/websocket`);

export default client;
const IncomingSessionEvents = {
  'cell:output': CellOutputPayloadSchema,
  'cell:error': CellErrorPayloadSchema,
  'cell:updated': CellUpdatedPayloadSchema,
  'cell:formatted': CellFormattedPayloadSchema,
  'deps:validate:response': DepsValidateResponsePayloadSchema,
  'tsserver:cell:diagnostics': TsServerCellDiagnosticsPayloadSchema,
  'tsserver:cell:suggestions': TsServerCellSuggestionsPayloadSchema,
  'tsserver:cell:quickinfo:response': TsServerQuickInfoResponsePayloadSchema,
  'ai:generated': AiGeneratedCellPayloadSchema,
  'tsconfig.json:updated': TsConfigUpdatedPayloadSchema,
  'tsserver:cell:definition_location:response': TsServerDefinitionLocationResponsePayloadSchema,
  'tsserver:cell:completions:response': TsServerCompletionEntriesPayloadSchema,
};

const OutgoingSessionEvents = {
  'cell:exec': CellExecPayloadSchema,
  'cell:stop': CellStopPayloadSchema,
  'cell:create': CellCreatePayloadSchema,
  'cell:update': CellUpdatePayloadSchema,
  'cell:rename': CellRenamePayloadSchema,
  'cell:delete': CellDeletePayloadSchema,
  'cell:format': CellFormatPayloadSchema,
  'ai:generate': AiGenerateCellPayloadSchema,
  'ai:fix_diagnostics': AiFixDiagnosticsPayloadSchema,
  'deps:install': DepsInstallPayloadSchema,
  'deps:validate': DepsValidatePayloadSchema,
  'tsserver:start': TsServerStartPayloadSchema,
  'tsserver:stop': TsServerStopPayloadSchema,
  'tsserver:cell:quickinfo:request': TsServerQuickInfoRequestPayloadSchema,
  'tsconfig.json:update': TsConfigUpdatePayloadSchema,
  'tsserver:cell:definition_location:request': TsServerDefinitionLocationRequestPayloadSchema,
  'tsserver:cell:completions:request': TsServerQuickInfoRequestPayloadSchema,
};

export class SessionChannel extends Channel<
  typeof IncomingSessionEvents,
  typeof OutgoingSessionEvents
> {
  static create(sessionId: string) {
    return new SessionChannel(client, `session:${sessionId}`, {
      incoming: IncomingSessionEvents,
      outgoing: OutgoingSessionEvents,
    });
  }
}

const IncomingAppEvents = {
  file: FilePayloadSchema,
  'file:updated': FileUpdatedPayloadSchema,
  'preview:status': PreviewStatusPayloadSchema,
  'preview:log': PreviewLogPayloadSchema,
  'deps:install:log': DepsInstallLogPayloadSchema,
  'deps:install:status': DepsInstallStatusPayloadSchema,
  'deps:status:response': DepsStatusResponsePayloadSchema,
};

const OutgoingAppEvents = {
  'file:created': FileCreatedPayloadSchema,
  'file:updated': FileUpdatedPayloadSchema,
  'file:renamed': FileRenamedPayloadSchema,
  'file:deleted': FileDeletedPayloadSchema,
  'preview:start': PreviewStartPayloadSchema,
  'preview:stop': PreviewStopPayloadSchema,
  'deps:install': DepsInstallPayloadSchema,
  'deps:clear': DepsClearPayloadSchema,
  'deps:status': DepsStatusPayloadSchema,
};

export class AppChannel extends Channel<typeof IncomingAppEvents, typeof OutgoingAppEvents> {
  appId: string;

  static create(appId: string) {
    return new AppChannel(appId);
  }

  constructor(appId: string) {
    super(client, `app:${appId}`, {
      incoming: IncomingAppEvents,
      outgoing: OutgoingAppEvents,
    });
    this.appId = appId;
  }
}

================
File: web/src/components/apps/lib/diff.ts
================
import * as Diff from 'diff';

export function diffFiles(
  original: string,
  modified: string,
): { additions: number; deletions: number } {
  const changes: Diff.Change[] = Diff.diffLines(original, modified);

  let additions: number = 0;
  let deletions: number = 0;

  changes.forEach((part: Diff.Change) => {
    if (part.added) {
      additions += part.count ?? 0;
    } else if (part.removed) {
      deletions += part.count ?? 0;
    }
  });

  return { additions, deletions };
}

type AddedType = 1;
type RemovedType = -1;
type UnChangedType = 0;
type ChangeType = AddedType | RemovedType | UnChangedType;

export function calculateSquares(
  additions: number,
  deletions: number,
  maxSquares: number = 5,
): ChangeType[] {
  const totalChanges = additions + deletions;

  if (totalChanges === 0) {
    return Array(maxSquares).fill(0);
  }

  if (totalChanges <= maxSquares) {
    return createSquares(additions, deletions, maxSquares);
  }

  // Calculate the proportion of added and removed lines
  const addedProportion = additions / totalChanges;

  // Calculate the number of squares for added, ensuring at least 1 if there are any additions
  let addedSquares = Math.round(addedProportion * maxSquares);
  addedSquares = additions > 0 ? Math.max(1, addedSquares) : 0;

  // Calculate removed squares, ensuring at least 1 if there are any removals
  let deletedSquares = maxSquares - addedSquares;
  deletedSquares = deletions > 0 ? Math.max(1, deletedSquares) : 0;

  // Final adjustment to ensure we don't exceed maxSquares
  if (addedSquares + deletedSquares > maxSquares) {
    if (additions > deletions) {
      deletedSquares = maxSquares - addedSquares;
    } else {
      addedSquares = maxSquares - deletedSquares;
    }
  }

  return createSquares(addedSquares, deletedSquares, maxSquares);
}

function createSquares(added: number, deleted: number, max: number): ChangeType[] {
  if (added + deleted > max) {
    console.error(`Expected max ${max} squares but got ${added + deleted}`);
  }

  const result: ChangeType[] = [];

  for (let i = 0; i < added; i++) {
    result.push(1);
  }

  for (let i = 0; i < deleted; i++) {
    result.push(-1);
  }

  // If there's remaining space, fill with 'unchanged'
  for (let i = 0, len = max - result.length; i < len; i++) {
    result.push(0);
  }

  return result;
}

================
File: web/src/components/apps/lib/file-tree.ts
================
import type { DirEntryType, FileEntryType, FsEntryTreeType } from '@srcbook/shared';

/**
 * Sorts a file tree (in place) by name. Folders come first, then files.
 */
export function sortTree(tree: DirEntryType): DirEntryType {
  tree.children?.sort((a, b) => {
    if (a.type === 'directory') sortTree(a);
    if (b.type === 'directory') sortTree(b);
    if (a.type === 'directory' && b.type === 'file') return -1;
    if (a.type === 'file' && b.type === 'directory') return 1;
    return a.basename.localeCompare(b.basename);
  });

  return tree;
}

/**
 * Update a directory node in the file tree.
 *
 * This function is complex due to the merging of children. We do it to maintain
 * nested state of a given tree. Consider the following file tree that the user
 * has open in their file tree viewer:
 *
 *     /src
 *     │
 *     ├── components
 *     │   ├── ui
 *     │   │   └── table
 *     │   │       ├── index.tsx
 *     │   │       └── show.tsx
 *     │   │
 *     │   └── use-files.tsx
 *     │
 *     └── index.tsx
 *
 * If the user closes and then reopens the "components" folder, the reopening of
 * the "components" folder will make a call to load its children. However, calls
 * to load children only load the immediate children, not all nested children.
 * This means that the call will not load the "ui" folder's children.
 *
 * Now, given that the user had previously opened the "ui" folder and we have the
 * results of that folder loaded in our state, we don't want to throw away those
 * values. So we merge the children of the new node and any nested children of
 * the old node.
 *
 * This supports behavior where a user may open many nested folders and then close
 * and later reopen a ancestor folder. We want the tree to look the same when the
 * reopen occurs with only the immediate children updated.
 */
export function updateDirNode(tree: DirEntryType, node: DirEntryType): DirEntryType {
  return sortTree(doUpdateDirNode(tree, node));
}

function doUpdateDirNode(tree: DirEntryType, node: DirEntryType): DirEntryType {
  if (tree.path === node.path) {
    if (node.children === null) {
      return { ...node, children: tree.children };
    } else {
      return { ...node, children: merge(tree.children, node.children) };
    }
  }

  if (tree.children) {
    return {
      ...tree,
      children: tree.children.map((entry) => {
        if (entry.type === 'directory') {
          return doUpdateDirNode(entry, node);
        } else {
          return entry;
        }
      }),
    };
  }

  return tree;
}

function merge(oldChildren: FsEntryTreeType | null, newChildren: FsEntryTreeType): FsEntryTreeType {
  if (!oldChildren) {
    return newChildren;
  }

  return newChildren.map((newChild) => {
    const oldChild = oldChildren.find((old) => old.path === newChild.path);

    if (oldChild && oldChild.type === 'directory' && newChild.type === 'directory') {
      return {
        ...newChild,
        children:
          newChild.children === null
            ? oldChild.children
            : merge(oldChild.children, newChild.children),
      };
    }

    return newChild;
  });
}

export function renameDirNode(
  tree: DirEntryType,
  oldNode: DirEntryType,
  newNode: DirEntryType,
): DirEntryType {
  return sortTree(doRenameDirNode(tree, oldNode, newNode));
}

function doRenameDirNode(
  tree: DirEntryType,
  oldNode: DirEntryType,
  newNode: DirEntryType,
): DirEntryType {
  const children =
    tree.children === null
      ? null
      : tree.children.map((entry) => {
          if (entry.type === 'directory') {
            return doRenameDirNode(entry, oldNode, newNode);
          } else {
            if (entry.path.startsWith(oldNode.path)) {
              return { ...entry, path: entry.path.replace(oldNode.path, newNode.path) };
            } else {
              return entry;
            }
          }
        });

  if (tree.path === oldNode.path) {
    return { ...newNode, children };
  } else if (tree.path.startsWith(oldNode.path)) {
    const path = tree.path.replace(oldNode.path, newNode.path);
    return { ...tree, path, children };
  } else {
    return { ...tree, children };
  }
}

export function updateFileNode(
  tree: DirEntryType,
  oldNode: FileEntryType,
  newNode: FileEntryType,
): DirEntryType {
  return sortTree(doUpdateFileNode(tree, oldNode, newNode));
}

function doUpdateFileNode(
  tree: DirEntryType,
  oldNode: FileEntryType,
  newNode: FileEntryType,
): DirEntryType {
  if (tree.children === null) {
    return tree;
  }

  const children = [];

  for (const entry of tree.children) {
    if (entry.path === oldNode.path) {
      children.push(newNode);
    } else {
      if (entry.type === 'directory') {
        children.push(doUpdateFileNode(entry, oldNode, newNode));
      } else {
        children.push(entry);
      }
    }
  }

  return { ...tree, children };
}

/**
 * Delete a node from the file tree.
 *
 * This doesn't affect sort order, so no need to call sortTree.
 */
export function deleteNode(tree: DirEntryType, path: string): DirEntryType {
  if (tree.children === null) {
    return tree;
  }

  const children: FsEntryTreeType = [];

  for (const entry of tree.children) {
    if (entry.path === path) {
      continue;
    }

    if (entry.type === 'directory') {
      children.push(deleteNode(entry, path));
    } else {
      children.push(entry);
    }
  }

  return { ...tree, children };
}

/**
 * Create a new node in the file tree.
 */
export function createNode(tree: DirEntryType, node: DirEntryType | FileEntryType): DirEntryType {
  return sortTree(doCreateNode(tree, node));
}

function doCreateNode(tree: DirEntryType, node: DirEntryType | FileEntryType): DirEntryType {
  if (tree.children === null) {
    return tree;
  }

  // To avoid duplicate entries in the tree, ensure that we 'upsert' here.
  if (tree.path === node.dirname) {
    const idx = tree.children.findIndex((entry) => entry.path === node.path);
    const children = [...tree.children];

    if (idx === -1) {
      children.push(node);
    } else {
      children.splice(idx, 1, node);
    }

    return { ...tree, children };
  }

  const children = tree.children.map((entry) => {
    if (entry.type === 'directory') {
      return doCreateNode(entry, node);
    } else {
      return entry;
    }
  });

  return { ...tree, children };
}

================
File: web/src/components/apps/lib/path.ts
================
// This file and client side code assumes posix paths. It is incomplete and handles basic
// functionality. That should be ok as we expect a subset of behavior and assume simple paths.

export function extname(path: string) {
  const idx = path.lastIndexOf('.');
  return idx === -1 ? '' : path.slice(idx);
}

================
File: web/src/components/apps/panels/explorer.tsx
================
import { useEffect, useRef, useState } from 'react';
import { FileIcon, ChevronRightIcon } from 'lucide-react';
import { useFiles } from '../use-files';
import type { DirEntryType, FileEntryType } from '@srcbook/shared';
import { cn } from '@srcbook/components';
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuTrigger,
} from '@srcbook/components/src/components/ui/context-menu';
import { useVersion } from '../use-version';

export default function ExplorerPanel() {
  const { fileTree } = useFiles();
  const { currentVersion } = useVersion();
  const [editingEntry, setEditingEntry] = useState<FileEntryType | DirEntryType | null>(null);
  const [newEntry, setNewEntry] = useState<FileEntryType | DirEntryType | null>(null);

  return (
    <div className="flex flex-col justify-between min-h-full">
      <ContextMenu>
        <ContextMenuTrigger>
          <ul className="w-full h-full text-sm font-medium text-tertiary-foreground overflow-auto">
            <FileTree
              depth={1}
              tree={fileTree}
              newEntry={newEntry}
              setNewEntry={setNewEntry}
              editingEntry={editingEntry}
              setEditingEntry={setEditingEntry}
            />
          </ul>
        </ContextMenuTrigger>
        <ContextMenuContent>
          <ContextMenuItem
            onClick={() =>
              setNewEntry({ type: 'file', path: 'untitled', dirname: '.', basename: 'untitled' })
            }
          >
            New file...
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() =>
              setNewEntry({
                type: 'directory',
                path: 'untitled',
                dirname: '.',
                basename: 'untitled',
                children: null,
              })
            }
          >
            New folder...
          </ContextMenuItem>
        </ContextMenuContent>
      </ContextMenu>

      {currentVersion && (
        <p className="font-mono text-tertiary-foreground rounded px-1.5 py-0.5 bg-muted text-xs w-fit m-1">
          version: {currentVersion.sha.slice(0, 7)}
        </p>
      )}
    </div>
  );
}

function FileTree(props: {
  depth: number;
  tree: DirEntryType;
  newEntry: FileEntryType | DirEntryType | null;
  setNewEntry: (entry: FileEntryType | DirEntryType | null) => void;
  editingEntry: FileEntryType | DirEntryType | null;
  setEditingEntry: (entry: FileEntryType | DirEntryType | null) => void;
}) {
  const { depth, tree, newEntry, setNewEntry, editingEntry, setEditingEntry } = props;

  const {
    openFile,
    createFile,
    deleteFile,
    renameFile,
    openedFile,
    toggleFolder,
    isFolderOpen,
    openFolder,
    createFolder,
    deleteFolder,
    renameFolder,
  } = useFiles();

  if (tree.children === null) {
    return null;
  }

  const dirEntries = [];
  const fileEntries = [];

  for (const entry of tree.children) {
    if (entry.type === 'directory') {
      dirEntries.push(entry);
    } else {
      fileEntries.push(entry);
    }
  }

  const elements = [];

  if (newEntry !== null && newEntry.type === 'directory' && newEntry.dirname === tree.path) {
    elements.push(
      <li key={newEntry.path}>
        <EditNameNode
          depth={depth}
          name={newEntry.basename}
          onSubmit={(name) => {
            createFolder(tree.path, name);
            setNewEntry(null);
          }}
          onCancel={() => setNewEntry(null)}
        />
      </li>,
    );
  }

  for (const entry of dirEntries) {
    const opened = isFolderOpen(entry);

    if (editingEntry?.path === entry.path) {
      elements.push(
        <li key={entry.path}>
          <EditNameNode
            depth={depth}
            name={entry.basename}
            onSubmit={(name) => {
              renameFolder(entry, name);
              setEditingEntry(null);
            }}
            onCancel={() => setEditingEntry(null)}
          />
        </li>,
      );
    } else {
      elements.push(
        <li key={entry.path}>
          <FolderNode
            depth={depth}
            label={entry.basename}
            opened={opened}
            onClick={() => toggleFolder(entry)}
            onDelete={() => deleteFolder(entry)}
            onRename={() => setEditingEntry(entry)}
            onNewFile={() => {
              if (!isFolderOpen(entry)) {
                openFolder(entry);
              }
              setNewEntry({
                type: 'file',
                path: entry.path + '/untitled',
                dirname: entry.path,
                basename: 'untitled',
              });
            }}
            onNewfolder={() => {
              if (!isFolderOpen(entry)) {
                openFolder(entry);
              }
              setNewEntry({
                type: 'directory',
                path: entry.path + '/untitled',
                dirname: entry.path,
                basename: 'untitled',
                children: null,
              });
            }}
          />
        </li>,
      );
    }

    if (opened) {
      elements.push(
        <FileTree
          key={entry.path + '-tree'}
          depth={depth + 1}
          tree={entry}
          newEntry={newEntry}
          setNewEntry={setNewEntry}
          editingEntry={editingEntry}
          setEditingEntry={setEditingEntry}
        />,
      );
    }
  }

  if (newEntry !== null && newEntry.type === 'file' && newEntry.dirname === tree.path) {
    elements.push(
      <li key={newEntry.path}>
        <EditNameNode
          depth={depth}
          name={newEntry.basename}
          onSubmit={async (name) => {
            const diskEntry = await createFile(tree.path, name);
            openFile(diskEntry);
            setNewEntry(null);
          }}
          onCancel={() => setNewEntry(null)}
        />
      </li>,
    );
  }

  for (const entry of fileEntries) {
    if (entry.path === editingEntry?.path) {
      elements.push(
        <li key={entry.path}>
          <EditNameNode
            depth={depth}
            name={entry.basename}
            onSubmit={(name) => {
              renameFile(entry, name);
              setEditingEntry(null);
            }}
            onCancel={() => setEditingEntry(null)}
          />
        </li>,
      );
    } else {
      elements.push(
        <li key={entry.path}>
          <FileNode
            depth={depth}
            label={entry.basename}
            active={openedFile?.path === entry.path}
            onClick={() => openFile(entry)}
            onDelete={() => deleteFile(entry)}
            onRename={() => setEditingEntry(entry)}
          />
        </li>,
      );
    }
  }

  return elements;
}

function FileNode(props: {
  depth: number;
  label: string;
  active: boolean;
  onClick: () => void;
  onDelete: () => void;
  onRename: () => void;
}) {
  return (
    <ContextMenu>
      <ContextMenuTrigger>
        <Node {...props} icon={<FileIcon size={12} />} />
      </ContextMenuTrigger>
      <ContextMenuContent>
        <ContextMenuItem onClick={props.onRename}>Rename</ContextMenuItem>
        <ContextMenuItem onClick={props.onDelete}>Delete</ContextMenuItem>
      </ContextMenuContent>
    </ContextMenu>
  );
}

function FolderNode(props: {
  depth: number;
  label: string;
  opened: boolean;
  onClick: () => void;
  onDelete: () => void;
  onRename: () => void;
  onNewFile: () => void;
  onNewfolder: () => void;
}) {
  return (
    <ContextMenu>
      <ContextMenuTrigger>
        <Node
          {...props}
          icon={
            <ChevronRightIcon
              size={12}
              className={cn(
                'transition-transform duration-100',
                props.opened && 'transform rotate-90',
              )}
            />
          }
        />
      </ContextMenuTrigger>
      <ContextMenuContent
        onCloseAutoFocus={(e) => {
          // This is an important line of code. It is needed to prevent focus
          // from returning to other elements when this menu is closed. Without this,
          // when a user clicks "New [file|folder]" or "Rename", the input box will
          // render and sometimes immediately dismiss because this returns focus to
          // the button element the user right clicked on, causing the input's onBlur
          // to trigger.
          e.preventDefault();
        }}
      >
        <ContextMenuItem onClick={props.onNewFile}>New file...</ContextMenuItem>
        <ContextMenuItem onClick={props.onNewfolder}>New folder...</ContextMenuItem>
        <ContextMenuItem onClick={props.onRename}>Rename</ContextMenuItem>
        <ContextMenuItem onClick={props.onDelete}>Delete</ContextMenuItem>
      </ContextMenuContent>
    </ContextMenu>
  );
}

function EditNameNode(props: {
  depth: number;
  name: string;
  onSubmit: (name: string) => void;
  onCancel: () => void;
}) {
  const ref = useRef<HTMLInputElement>(null);

  useEffect(() => {
    function focusAndSelect() {
      const input = ref.current;

      if (input) {
        input.focus();
        const idx = input.value.lastIndexOf('.');
        input.setSelectionRange(0, idx === -1 ? input.value.length : idx);
      }
    }

    // This setTimeout is intentional. We need to draw focus to this
    // input after the current event loop clears out because other elements
    // are getting focused in some situations immediately after this renders.
    setTimeout(focusAndSelect, 0);
  }, []);

  return (
    <input
      ref={ref}
      defaultValue={props.name}
      className={cn(
        'flex h-8 w-full rounded-sm border border-ring bg-transparent px-3 py-2 text-sm transition-colors',
        'placeholder:text-muted-foreground focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50',
        '[&::selection]:bg-accent [&::selection]:text-accent-foreground',
      )}
      style={{ paddingLeft: `${props.depth * 12}px` }}
      onBlur={props.onCancel}
      onKeyDown={(e) => {
        if (e.key === 'Enter' && ref.current) {
          e.preventDefault();
          e.stopPropagation();
          props.onSubmit(ref.current.value);
        } else if (e.key === 'Escape') {
          ref.current?.blur();
        }
      }}
    />
  );
}

function Node(props: {
  depth: number;
  label: string;
  icon: React.ReactNode;
  active?: boolean;
  onClick: () => void;
}) {
  const { depth, label, icon, active, onClick } = props;

  return (
    <button
      onClick={onClick}
      className={cn(
        'py-1 px-2 leading-5 w-full flex items-center gap-1.5 cursor-pointer rounded-sm hover:bg-sb-core-20 dark:hover:bg-sb-core-110',
        active && 'text-foreground',
      )}
      style={{ paddingLeft: `${depth * 12}px` }}
      title={label}
    >
      {icon} <span className="truncate font-light">{label}</span>
    </button>
  );
}

================
File: web/src/components/apps/panels/settings.tsx
================
import { Button } from '@srcbook/components/src/components/ui/button';
import { usePackageJson } from '../use-package-json';
import { PackagePlus } from 'lucide-react';
import Shortcut from '@srcbook/components/src/components/keyboard-shortcut';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@srcbook/components/src/components/ui/tooltip';

export default function PackagesPanel() {
  const { setShowInstallModal, npmInstall, clearNodeModules, nodeModulesExists, status } =
    usePackageJson();

  return (
    <div className="flex flex-col gap-6 px-5 w-[360px]">
      <div className="flex flex-col gap-2">
        <p className="text-sm text-tertiary-foreground">
          To add packages, you can simply ask the AI in chat, or use the button below.
        </p>

        <div>
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button onClick={() => setShowInstallModal(true)} className="gap-1">
                  <PackagePlus size={16} />
                  Add a package
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                Install packages <Shortcut keys={['mod', 'i']} />
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      </div>

      <div className="flex flex-col gap-2">
        <p className="text-sm text-tertiary-foreground">
          If you suspect your node_modules are corrupted, you can clear them and reinstall all
          packages.
        </p>
        <div>
          <Button onClick={() => clearNodeModules()} disabled={nodeModulesExists !== true}>
            Clear all packages
          </Button>
        </div>
      </div>

      <div className="flex flex-col gap-2">
        <p className="text-sm text-tertiary-foreground">
          Re-run <code className="code">npm install</code>. This will run against the package.json
          from the project root.
        </p>
        <div>
          <Button onClick={() => npmInstall()} disabled={status === 'installing'}>
            Re-install all packages
          </Button>
        </div>
      </div>
    </div>
  );
}

================
File: web/src/components/apps/AiFeedbackModal.tsx
================
import * as React from 'react';
import {
  Button,
  Dialog,
  DialogContent,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components';
import TextareaAutosize from 'react-textarea-autosize';

interface AiFeedbackModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (feedback: string) => void;
}

export function AiFeedbackModal({ isOpen, onClose, onSubmit }: AiFeedbackModalProps) {
  const [feedback, setFeedback] = React.useState('');

  const handleSubmit = () => {
    onSubmit(feedback);
    setFeedback('');
    onClose();
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      handleSubmit();
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Provide Feedback</DialogTitle>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <TextareaAutosize
            placeholder="Tell us more about what went wrong..."
            className="flex w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring"
            value={feedback}
            onChange={(e) => setFeedback(e.target.value)}
            onKeyDown={handleKeyDown}
            minRows={3}
            maxRows={10}
          />
        </div>
        <DialogFooter>
          <Button variant="ghost" onClick={onClose}>
            Cancel
          </Button>
          <Button onClick={handleSubmit}>Submit Feedback</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/apps/bottom-drawer.tsx
================
import { BanIcon, XIcon } from 'lucide-react';
import { useHotkeys } from 'react-hotkeys-hook';

import { Button } from '@srcbook/components/src/components/ui/button';
import { cn } from '@/lib/utils.ts';
import { useLogs } from './use-logs';
import { useEffect, useRef } from 'react';

const DRAWER_HEIGHT = 320;

export default function BottomDrawer() {
  const { logs, clearLogs, open, togglePane, closePane } = useLogs();

  useHotkeys('mod+shift+y', () => {
    togglePane();
  });

  const scrollWrapperRef = useRef<HTMLDivElement | null>(null);

  // Scroll to the bottom of the logs panel when the user opens the panel fresh
  useEffect(() => {
    if (!scrollWrapperRef.current) {
      return;
    }
    scrollWrapperRef.current.scrollTop = scrollWrapperRef.current.scrollHeight;
  }, [open]);

  // Determine if the user has scrolled all the way to the bottom of the div
  const scrollPinnedToBottomRef = useRef(false);
  useEffect(() => {
    if (!scrollWrapperRef.current) {
      return;
    }
    const element = scrollWrapperRef.current;

    const onScroll = () => {
      scrollPinnedToBottomRef.current =
        element.scrollTop === element.scrollHeight - element.clientHeight;
    };

    element.addEventListener('scroll', onScroll);
    return () => element.removeEventListener('scroll', onScroll);
  }, []);

  // If the user has scrolled all the way to the bottom, then keep the bottom scroll pinned as new
  // logs come in.
  useEffect(() => {
    if (!scrollWrapperRef.current) {
      return;
    }

    if (scrollPinnedToBottomRef.current) {
      scrollWrapperRef.current.scrollTop = scrollWrapperRef.current.scrollHeight;
    }
  }, [logs]);

  return (
    <div
      className={cn(
        'flex flex-col w-full overflow-hidden transition-all duration-200 ease-in-out',
        open ? 'flex-grow' : 'flex-shrink-0 h-8',
      )}
      style={{
        maxHeight: open ? `${DRAWER_HEIGHT}px` : '2rem',
        minHeight: open ? `${DRAWER_HEIGHT}px` : '2rem',
      }}
    >
      <div className="flex-shrink-0 flex items-center justify-between border-t border-b h-8 px-1 w-full bg-muted">
        <button
          onClick={() => togglePane()}
          className="px-2 text-sm font-medium h-6 select-none focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring"
        >
          Logs
        </button>

        <div className="flex items-center gap-1">
          {open && logs.length > 0 && (
            <Button
              size="sm"
              variant="icon"
              onClick={clearLogs}
              className="active:translate-y-0 w-6 px-0"
            >
              <BanIcon size={14} />
            </Button>
          )}
          {open && (
            <Button
              size="sm"
              variant="icon"
              onClick={() => closePane()}
              className="active:translate-y-0 w-6 px-0"
            >
              <XIcon size={16} />
            </Button>
          )}
        </div>
      </div>

      {open && (
        <div className="flex-grow overflow-auto p-2" ref={scrollWrapperRef}>
          <table className="w-full border-collapse text-xs">
            <tbody>
              {logs.map((log, index) => (
                <tr key={index}>
                  <td className="align-top select-none pointer-events-none whitespace-nowrap w-0 pr-4">
                    <span className="font-mono text-tertiary-foreground/80">
                      {log.timestamp.toISOString()}
                    </span>
                  </td>
                  <td className="align-top select-none pointer-events-none whitespace-nowrap w-0 pr-4">
                    <span className="font-mono text-tertiary-foreground">{log.source}</span>
                  </td>
                  <td className="align-top">
                    <pre
                      className={cn('font-mono cursor-text whitespace-pre-wrap', {
                        'text-red-300': log.type === 'stderr',
                        'text-secondary-foreground': log.type === 'info',
                      })}
                    >
                      {log.message}
                    </pre>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
          {logs.length === 0 && (
            <div className="w-full h-full flex items-center justify-center">
              <span className="text-tertiary-foreground">No logs</span>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

================
File: web/src/components/apps/create-modal.tsx
================
import { useState, KeyboardEvent } from 'react';
import { cn } from '@/lib/utils';
import { Input } from '@srcbook/components/src/components/ui/input';
import { Button } from '@srcbook/components/src/components/ui/button';
import { useNavigate } from 'react-router-dom';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components/src/components/ui/dialog';

import { HelpCircle, Sparkles, Loader2 } from 'lucide-react';
import { Textarea } from '@srcbook/components/src/components/ui/textarea';
import {
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
  Tooltip,
} from '@srcbook/components/src/components/ui/tooltip';
import { useSettings } from '../use-settings';

type PropsType = {
  onClose: () => void;
  onCreate: (name: string, prompt?: string) => Promise<void>;
};

export default function CreateAppModal({ onClose, onCreate }: PropsType) {
  const [name, setName] = useState('');
  const [prompt, setPrompt] = useState('');

  const { aiEnabled } = useSettings();
  const navigate = useNavigate();

  const [submitting, setSubmitting] = useState(false);

  const validPrompt = prompt.trim() !== '';

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    e.stopPropagation();

    if (submitting || !validPrompt) {
      return;
    }

    setSubmitting(true);

    try {
      await onCreate(name, prompt.trim() === '' ? undefined : prompt);
    } finally {
      setSubmitting(false);
    }
  }

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
      onSubmit(e);
    }
  };

  return (
    <Dialog
      open
      onOpenChange={(open) => {
        if (open === false) {
          onClose();
        }
      }}
    >
      <DialogContent className={cn('flex flex-col transition-height w-[800px]')}>
        <DialogHeader>
          <DialogTitle>Create application</DialogTitle>
          <DialogDescription className="text-sm">
            Create a web app powered by React, Vite and Tailwind.
          </DialogDescription>

          {!aiEnabled && (
            <div className="flex items-center justify-between bg-warning text-warning-foreground rounded-sm text-sm px-3 py-1 mt-4">
              <p>AI provider not configured.</p>
              <button
                className="font-medium underline cursor-pointer"
                onClick={() => navigate('/settings')}
              >
                Settings
              </button>
            </div>
          )}
        </DialogHeader>
        <form name="app" onSubmit={onSubmit} className="flex flex-col gap-6">
          <div className="space-y-1">
            <label htmlFor="name" className="text-sm font-medium">
              App name
            </label>
            <Input
              name="app[name]"
              value={name}
              /* eslint-disable-next-line jsx-a11y/no-autofocus */
              autoFocus
              autoComplete="off"
              onChange={(e) => setName(e.currentTarget.value)}
              placeholder="Spotify Light"
            />
          </div>

          <div className="space-y-1">
            <div className="flex justify-between items-center">
              <label htmlFor="name" className="text-sm font-medium flex items-center gap-1.5">
                What are you building? <Sparkles size={14} />
              </label>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <HelpCircle size={16} className="text-tertiary-foreground" />
                  </TooltipTrigger>
                  <TooltipContent className="text-sm" side="left">
                    Use AI to scaffold your app
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
            <Textarea
              name="app[prompt]"
              value={prompt}
              onChange={(e) => setPrompt(e.currentTarget.value)}
              onKeyDown={handleKeyDown}
              className="h-20"
              placeholder="A Spotify-like app, showcasing a user's favorite playlists and most listened to songs."
            ></Textarea>
          </div>

          <DialogFooter>
            <Button type="button" variant="secondary" onClick={onClose}>
              Cancel
            </Button>

            <Button disabled={!aiEnabled || submitting || !validPrompt} type="submit">
              {submitting ? (
                <div className="flex items-center gap-2">
                  <Loader2 className="h-4 w-4 animate-spin" /> Generating...
                </div>
              ) : (
                'Create'
              )}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/apps/diff-modal.tsx
================
import { cn } from '@/lib/utils';
import { Button } from '@srcbook/components';
import {
  Dialog,
  DialogContent,
  DialogTitle,
  DialogDescription,
} from '@srcbook/components/src/components/ui/dialog';
import { Undo2Icon } from 'lucide-react';
import type { FileDiffType } from '@srcbook/shared';
import { DiffSquares, DiffStats } from './diff-stats';
import { DiffEditor } from './editor';

type PropsType = {
  onUndoAll: () => void;
  onClose: () => void;
  files: FileDiffType[];
};

export default function DiffModal({ files, onClose, onUndoAll }: PropsType) {
  return (
    <Dialog
      open
      onOpenChange={(open) => {
        if (open === false) {
          onClose();
        }
      }}
    >
      <DialogContent
        className={cn('w-[95vw] h-[95vh] max-w-none p-0 gap-0 flex flex-col')}
        hideClose
      >
        {/* Got browser console warnings without this */}
        <DialogDescription className="sr-only">View diff of files changed</DialogDescription>
        <DiffModalHeader numFiles={files.length} onClose={onClose} onUndoAll={onUndoAll} />
        <div className="flex-1 overflow-y-auto p-6 flex flex-col gap-6">
          {files.map((file) => (
            <FileDiff key={file.path} file={file} />
          ))}
        </div>
      </DialogContent>
    </Dialog>
  );
}

function DiffModalHeader({
  numFiles,
  onClose,
  onUndoAll,
}: {
  numFiles: number;
  onClose: () => void;
  onUndoAll: () => void;
}) {
  return (
    <div className="h-12 px-4 flex items-center justify-between border-b border-border">
      <div>
        <DialogTitle className="font-semibold">{`${numFiles} ${numFiles === 1 ? 'file' : 'files'} changed`}</DialogTitle>
      </div>
      <div className="flex items-center space-x-3">
        <Button variant="secondary" className="flex items-center space-x-1.5" onClick={onUndoAll}>
          <Undo2Icon size={16} />
          <span>Undo all</span>
        </Button>
        <Button onClick={onClose}>Done</Button>
      </div>
    </div>
  );
}

function FileDiff({ file }: { file: FileDiffType }) {
  return (
    <div className="border rounded-md">
      <div className="h-10 px-3 flex items-center border-b border-border">
        <div className="font-mono text-sm flex items-center gap-3">
          <h4 className="text-secondary-foreground">{file.path}</h4>
          <DiffStats additions={file.additions} deletions={file.deletions} />
          <DiffSquares additions={file.additions} deletions={file.deletions} />
        </div>
      </div>
      <div className="flex flex-col">
        <DiffEditor
          path={file.path}
          modified={file.modified}
          original={file.original}
          collapseUnchanged={{
            margin: 3,
            minSize: 4,
          }}
        />
      </div>
    </div>
  );
}

================
File: web/src/components/apps/diff-stats.tsx
================
import { cn } from '@/lib/utils';
import { calculateSquares } from './lib/diff';

export function DiffStats(props: { additions: number; deletions: number; className?: string }) {
  return (
    <div className={cn('flex items-center gap-2', props.className)}>
      <span className="text-green-500">+{props.additions}</span>
      <span className="text-red-400">-{props.deletions}</span>
    </div>
  );
}

export function DiffSquares(props: { additions: number; deletions: number; className?: string }) {
  const squares = calculateSquares(props.additions, props.deletions);

  return (
    <div className={cn('flex items-center gap-0.5', props.className)}>
      {squares.map((square, index) => (
        <span
          key={index}
          className={cn('w-3 h-3 rounded-sm', {
            'bg-border': square === 0,
            'bg-red-400': square === -1,
            'bg-green-500': square === 1,
          })}
        />
      ))}
    </div>
  );
}

================
File: web/src/components/apps/editor.tsx
================
import CodeMirror from '@uiw/react-codemirror';
import { css } from '@codemirror/lang-css';
import { html } from '@codemirror/lang-html';
import { json } from '@codemirror/lang-json';
import { javascript } from '@codemirror/lang-javascript';
import { markdown } from '@codemirror/lang-markdown';
import useTheme from '@srcbook/components/src/components/use-theme';
import { extname } from './lib/path';
import { EditorView } from 'codemirror';
import { EditorState } from '@codemirror/state';
import { unifiedMergeView } from '@codemirror/merge';

export function CodeEditor({
  path,
  source,
  onChange,
}: {
  path: string;
  source: string;
  onChange: (updatedSource: string) => void;
}) {
  const { codeTheme } = useTheme();

  const languageExtension = getCodeMirrorLanguageExtension(path);
  const extensions = languageExtension ? [languageExtension] : [];

  return (
    <CodeMirror
      key={path}
      value={source}
      theme={codeTheme}
      extensions={extensions}
      onChange={onChange}
    />
  );
}

export function DiffEditor({
  path,
  modified,
  original,
  collapseUnchanged,
}: {
  path: string;
  modified: string;
  original: string | null;
  collapseUnchanged?: {
    minSize: number;
    margin: number;
  };
}) {
  const { codeTheme } = useTheme();

  const extensions = [
    EditorView.editable.of(false),
    EditorState.readOnly.of(true),
    unifiedMergeView({
      original: original ?? '',
      mergeControls: false,
      highlightChanges: false,
      collapseUnchanged: collapseUnchanged,
    }),
  ];

  const languageExtension = getCodeMirrorLanguageExtension(path);

  if (languageExtension) {
    extensions.unshift(languageExtension);
  }

  return <CodeMirror value={modified} theme={codeTheme} extensions={extensions} />;
}

function getCodeMirrorLanguageExtension(path: string) {
  switch (extname(path)) {
    case '.json':
      return json();
    case '.css':
      return css();
    case '.html':
      return html();
    case '.md':
    case '.markdown':
      return markdown();
    case '.js':
    case '.cjs':
    case '.mjs':
    case '.jsx':
    case '.ts':
    case '.cts':
    case '.mts':
    case '.tsx':
      return javascript({ typescript: true, jsx: true });
  }
}

================
File: web/src/components/apps/header.tsx
================
import {
  ShareIcon,
  PlayIcon,
  StopCircleIcon,
  PlayCircleIcon,
  Code2Icon,
  Loader2Icon,
  CircleAlertIcon,
  PanelBottomOpenIcon,
  PanelBottomCloseIcon,
  ExternalLinkIcon,
} from 'lucide-react';
import { Link } from 'react-router-dom';
import { SrcbookLogo } from '@/components/logos';

import { Button } from '@srcbook/components/src/components/ui/button';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@srcbook/components/src/components/ui/tooltip';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@srcbook/components/src/components/ui/dialog';
import { cn } from '@/lib/utils';
import { usePackageJson } from './use-package-json';
import { useApp } from './use-app';
import { Input } from '@srcbook/components';
import { useState } from 'react';
import { usePreview } from './use-preview';
import { exportApp } from '@/clients/http/apps';
import { toast } from 'sonner';
import { useLogs } from './use-logs';

export type HeaderTab = 'code' | 'preview';

type PropsType = {
  className?: string;
  tab: HeaderTab;
  onChangeTab: (newTab: HeaderTab) => void;
};

export default function EditorHeader(props: PropsType) {
  const { app, updateApp } = useApp();
  const { url, start: startPreview, stop: stopPreview, status: previewStatus } = usePreview();
  const { status: npmInstallStatus, nodeModulesExists } = usePackageJson();
  const [isExporting, setIsExporting] = useState(false);
  const { open, togglePane, panelIcon } = useLogs();

  const [nameChangeDialogOpen, setNameChangeDialogOpen] = useState(false);

  const handleExport = async () => {
    try {
      setIsExporting(true);
      const blob = await exportApp(app.id, app.name);
      const url = window.URL.createObjectURL(blob);

      // Create a temporary anchor element to trigger the download
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = `${app.name}.zip`;

      // Append to the document, trigger click, and remove
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);

      toast.success('App exported successfully!');
      setIsExporting(false);
    } catch (error) {
      console.error('Export failed:', error);
      toast.error('Failed to export app. Please try again.');
    }
  };

  return (
    <>
      {nameChangeDialogOpen && (
        <UpdateAppNameDialog
          name={app.name}
          onUpdate={(name) => {
            updateApp({ name });
            setNameChangeDialogOpen(false);
          }}
          onClose={() => {
            setNameChangeDialogOpen(false);
          }}
        />
      )}

      {npmInstallStatus === 'installing' ? (
        <div className="fixed top-0 left-0 right-0 z-[51] h-0.5 pointer-events-none">
          <div className="h-full w-full bg-white animate-indeterminate" />
        </div>
      ) : null}

      <header
        className={cn(
          'w-full flex items-center justify-between bg-background z-50 text-sm border-b border-b-border relative',
          props.className,
        )}
      >
        <Link to="/" className="px-4" title="Home">
          <SrcbookLogo size={20} />
        </Link>
        <nav className="flex items-center justify-between px-2 flex-1">
          <div className="flex items-center gap-2">
            <button
              className="px-2 text-sm font-medium"
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                setNameChangeDialogOpen(true);
              }}
            >
              {app.name}
            </button>
          </div>

          <div className="absolute left-1/2 -translate-x-1/2 flex bg-inline-code h-7 rounded-sm">
            <button
              className={cn(
                'flex gap-2 justify-center items-center w-24 text-foreground rounded-sm font-medium',
                {
                  'bg-background border border-border': props.tab === 'code',
                },
              )}
              onClick={() => props.onChangeTab('code')}
            >
              <Code2Icon size={14} />
              Code
            </button>
            <button
              className={cn(
                'flex gap-2 justify-center items-center w-24 text-foreground rounded-sm font-medium',
                {
                  'bg-background border border-border': props.tab === 'preview',
                },
              )}
              onClick={() => props.onChangeTab('preview')}
            >
              <PlayIcon size={14} />
              Preview
            </button>
          </div>

          <div className="flex items-center gap-2">
            {props.tab === 'preview' && previewStatus === 'stopped' ? (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      variant="icon"
                      size="icon"
                      onClick={startPreview}
                      className="active:translate-y-0"
                      disabled={nodeModulesExists !== true}
                    >
                      <PlayCircleIcon size={18} />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Start dev server</TooltipContent>
                </Tooltip>
              </TooltipProvider>
            ) : null}
            {props.tab === 'preview' && previewStatus !== 'stopped' ? (
              <>
                {url && (
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <Button
                          variant="icon"
                          size="icon"
                          onClick={() => window.open(url as string, '_blank')}
                          className="active:translate-y-0"
                          disabled={previewStatus !== 'running'}
                        >
                          <ExternalLinkIcon size={18} />
                        </Button>
                      </TooltipTrigger>
                      <TooltipContent>Open in new tab</TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                )}

                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button
                        variant="icon"
                        size="icon"
                        onClick={() => {
                          stopPreview();
                          props.onChangeTab('code');
                        }}
                        className="active:translate-y-0"
                        disabled={previewStatus !== 'running'}
                      >
                        <StopCircleIcon size={18} />
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent>Stop dev server</TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </>
            ) : null}

            <div
              className={cn('w-[1px] h-6 bg-border mx-2', { invisible: props.tab !== 'preview' })}
            />

            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="icon"
                    size="icon"
                    onClick={togglePane}
                    className="active:translate-y-0"
                  >
                    {panelIcon === 'default' && !open ? <PanelBottomOpenIcon size={18} /> : null}
                    {panelIcon === 'default' && open ? <PanelBottomCloseIcon size={18} /> : null}
                    {panelIcon === 'error' ? (
                      <CircleAlertIcon size={18} className="text-red-600" />
                    ) : null}
                  </Button>
                </TooltipTrigger>
                <TooltipContent>Open logs</TooltipContent>
              </Tooltip>
            </TooltipProvider>
            <TooltipProvider>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="icon"
                    size="icon"
                    onClick={handleExport}
                    className="active:translate-y-0"
                  >
                    {isExporting ? (
                      <Loader2Icon size={18} className="animate-spin" />
                    ) : (
                      <ShareIcon size={18} />
                    )}
                  </Button>
                </TooltipTrigger>
                <TooltipContent>Export app</TooltipContent>
              </Tooltip>
            </TooltipProvider>
          </div>
        </nav>
      </header>
    </>
  );
}

function UpdateAppNameDialog(props: {
  name: string;
  onClose: () => void;
  onUpdate: (name: string) => void;
}) {
  const [name, setName] = useState(props.name);

  return (
    <Dialog
      defaultOpen={true}
      onOpenChange={(open) => {
        if (!open) {
          props.onClose();
        }
      }}
    >
      <DialogContent hideClose>
        <DialogHeader>
          <DialogTitle>Rename app</DialogTitle>
          <DialogDescription className="sr-only">Rename this app</DialogDescription>
          <div className="pt-2">
            <Input value={name} onChange={(e) => setName(e.currentTarget.value)} />
          </div>
          <div className="flex w-full justify-end items-center gap-2 pt-4 bg-background">
            <Button variant="secondary" onClick={props.onClose}>
              Cancel
            </Button>
            <Button onClick={() => props.onUpdate(name)} disabled={name.trim() === ''}>
              Save
            </Button>
          </div>
        </DialogHeader>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/apps/local-storage.ts
================
import { FileType } from '@srcbook/shared';

export function getLastOpenedFile(appId: string) {
  const value = window.localStorage.getItem(`apps:${appId}:last_opened_file`);

  if (typeof value === 'string') {
    return JSON.parse(value);
  }

  return null;
}

export function setLastOpenedFile(appId: string, file: FileType) {
  return window.localStorage.setItem(`apps:${appId}:last_opened_file`, JSON.stringify(file));
}

================
File: web/src/components/apps/markdown.tsx
================
import MarkdownReact from 'marked-react';
import { cn } from '@srcbook/components';

export default function Markdown(props: { source: string; className?: string }) {
  return (
    <div className={cn('sb-prose-chat px-2', props.className)}>
      <MarkdownReact gfm>{props.source}</MarkdownReact>
    </div>
  );
}

================
File: web/src/components/apps/package-install-toast.tsx
================
import { useEffect, useState } from 'react';
import { CircleAlertIcon, InfoIcon, Loader2Icon } from 'lucide-react';

import { usePackageJson } from './use-package-json';
import { useLogs } from './use-logs';
import { Button } from '@srcbook/components/src/components/ui/button';
import { cn } from '@/lib/utils';

const ToastWrapper: React.FC<{
  showToast: boolean;
  className?: string;
  children: React.ReactNode;
}> = ({ className, showToast, children }) => (
  <div
    className={cn(
      'absolute bottom-4 left-4 z-20 p-3 bg-muted border',
      'rounded-md transition-all duration-150 ease-in-out text-sm',
      {
        'opacity-0 -bottom-8': !showToast,
      },
      className,
    )}
  >
    {children}
  </div>
);

const PackageInstallToast: React.FunctionComponent = () => {
  const { togglePane } = useLogs();
  const { status, npmInstall, nodeModulesExists } = usePackageJson();
  const [showToast, setShowToast] = useState(false);

  useEffect(() => {
    if (nodeModulesExists === false && (status === 'idle' || status === 'complete')) {
      setShowToast(true);
    } else if (nodeModulesExists === true) {
      setShowToast(false);
    }
  }, [nodeModulesExists, status]);

  switch (status) {
    case 'installing':
      return (
        <ToastWrapper showToast={showToast} className="flex items-center gap-9">
          <div className="flex items-center gap-3">
            <Loader2Icon size={18} className="animate-spin" />
            <span className="select-none">Installing Packages...</span>
          </div>

          <Button
            variant="ghost"
            className="active:translate-y-0"
            onClick={() => setShowToast(false)}
          >
            Close
          </Button>
        </ToastWrapper>
      );

    case 'failed':
      return (
        <ToastWrapper showToast={showToast} className="flex items-center gap-9">
          <div className="flex items-center gap-3">
            <CircleAlertIcon size={18} />
            <span className="font-medium select-none">Packages failed to install</span>
          </div>

          <div className="flex items-center gap-3">
            <Button
              variant="ghost"
              className="active:translate-y-0"
              onClick={() => setShowToast(false)}
            >
              Close
            </Button>
            <Button
              className="active:translate-y-0"
              onClick={() => {
                togglePane();
                setShowToast(false);
              }}
            >
              More info
            </Button>
          </div>
        </ToastWrapper>
      );

    case 'idle':
    case 'complete':
      return (
        <ToastWrapper showToast={showToast} className="flex items-center gap-9">
          <div className="flex items-center gap-3">
            <InfoIcon size={18} />
            <span className="select-none">Packages need to be installed</span>
          </div>

          <Button
            className="active:translate-y-0"
            onClick={() => npmInstall().then(() => setShowToast(false))}
          >
            Install
          </Button>
        </ToastWrapper>
      );
  }
};

export default PackageInstallToast;

================
File: web/src/components/apps/sidebar.tsx
================
import { useState } from 'react';
import useTheme from '@srcbook/components/src/components/use-theme';

import {
  ChevronsLeftIcon,
  FlagIcon,
  FolderTreeIcon,
  KeyboardIcon,
  MoonIcon,
  PackageIcon,
  SunIcon,
} from 'lucide-react';
import { Button } from '@srcbook/components/src/components/ui/button';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@srcbook/components/src/components/ui/tooltip';
import KeyboardShortcutsDialog from '../keyboard-shortcuts-dialog';
import FeedbackDialog from '../feedback-dialog';
import { cn } from '@/lib/utils';
import ExplorerPanel from './panels/explorer';
import PackagesPanel from './panels/settings';
import { usePackageJson } from './use-package-json';

export type PanelType = 'explorer' | 'packages';

function getTitleForPanel(panel: PanelType | null): string | null {
  switch (panel) {
    case 'explorer':
      return 'Files';
    case 'packages':
      return 'Manage Packages';
    default:
      return null;
  }
}

type SidebarProps = {
  initialPanel: PanelType | null;
};

export default function Sidebar({ initialPanel }: SidebarProps) {
  const { theme, toggleTheme } = useTheme();

  const { status } = usePackageJson();
  const [panel, _setPanel] = useState<PanelType | null>(initialPanel);
  const [showShortcuts, setShowShortcuts] = useState(false);
  const [showFeedback, setShowFeedback] = useState(false);

  function setPanel(nextPanel: PanelType) {
    _setPanel(nextPanel === panel ? null : nextPanel);
  }

  return (
    <>
      <KeyboardShortcutsDialog open={showShortcuts} onOpenChange={setShowShortcuts} />
      <FeedbackDialog open={showFeedback} onOpenChange={setShowFeedback} />

      <div className="flex h-full border-r border-border">
        <div className="flex flex-col items-center justify-between w-12 h-full py-3 bg-muted z-10">
          <div className="flex flex-col items-center w-full gap-2">
            <NavItemWithTooltip tooltipContent="Explorer" onClick={() => setPanel('explorer')}>
              <FolderTreeIcon
                size={18}
                className={cn(
                  'transition-colors',
                  panel === 'explorer'
                    ? 'text-secondary-foreground'
                    : 'text-tertiary-foreground hover:text-secondary-foreground',
                )}
              />
            </NavItemWithTooltip>
            <NavItemWithTooltip tooltipContent="Packages" onClick={() => setPanel('packages')}>
              <PackageIcon
                size={18}
                className={cn(
                  'transition-colors',
                  panel === 'packages'
                    ? 'text-secondary-foreground'
                    : 'text-tertiary-foreground hover:text-secondary-foreground',
                  status === 'installing' && 'text-run',
                  status === 'failed' && 'text-error',
                )}
              />
            </NavItemWithTooltip>
          </div>
          <div className="flex flex-col items-center w-full gap-2">
            <NavItemWithTooltip
              tooltipContent={theme === 'light' ? 'Dark mode' : 'Light mode'}
              onClick={toggleTheme}
            >
              {theme === 'light' ? (
                <MoonIcon
                  size={18}
                  className="text-tertiary-foreground hover:text-secondary-foreground transition-colors"
                />
              ) : (
                <SunIcon
                  size={18}
                  className="text-tertiary-foreground hover:text-secondary-foreground transition-colors"
                />
              )}
            </NavItemWithTooltip>
            <NavItemWithTooltip
              tooltipContent="Keyboard shortcuts"
              onClick={() => setShowShortcuts(true)}
            >
              <KeyboardIcon
                size={18}
                className="text-tertiary-foreground hover:text-secondary-foreground transition-colors"
              />
            </NavItemWithTooltip>
            <NavItemWithTooltip
              tooltipContent="Leave feedback"
              onClick={() => setShowFeedback(true)}
            >
              <FlagIcon
                size={18}
                className="text-tertiary-foreground hover:text-secondary-foreground transition-colors"
              />
            </NavItemWithTooltip>
          </div>
        </div>
        <Panel
          open={panel !== null}
          title={getTitleForPanel(panel)}
          onClose={() => {
            if (panel !== null) {
              setPanel(panel);
            }
          }}
        >
          {panel === 'explorer' && <ExplorerPanel />}
          {panel === 'packages' && <PackagesPanel />}
        </Panel>
      </div>
    </>
  );
}

function NavItemWithTooltip(props: {
  children: React.ReactNode;
  tooltipContent: string;
  onClick: () => void;
}) {
  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            variant="icon"
            size="icon"
            className="active:translate-y-0"
            onClick={props.onClick}
          >
            {props.children}
          </Button>
        </TooltipTrigger>
        <TooltipContent side="right">{props.tooltipContent}</TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}

function Panel(props: {
  open: boolean;
  title: string | null;
  onClose: () => void;
  children: React.ReactNode;
}) {
  if (!props.open) {
    return null;
  }

  return (
    <div className="h-full flex flex-col bg-muted animate-in slide-in-from-left duration-75">
      <div className="flex items-center justify-between h-14 px-3 border-l">
        <h4 className="px-2 text-sm font-medium leading-none">{props.title}</h4>
        <button
          className="p-2 text-tertiary-foreground hover:text-foreground hover:bg-sb-core-20 dark:hover:bg-sb-core-110 rounded-sm"
          onClick={props.onClose}
        >
          <ChevronsLeftIcon size={14} />
        </button>
      </div>
      <div className="min-w-[200px] border-l pr-1.5 flex-1 overflow-auto">{props.children}</div>
    </div>
  );
}

================
File: web/src/components/apps/types.ts
================
import { CommandMessageType } from '@srcbook/shared';

export type FileType = {
  type: 'file';
  modified: string;
  original: string | null;
  path: string;
  basename: string;
  dirname: string;
  description: string;
};

// TODO this should likely all be shared types eventually.
export type PlanItemType = FileType | CommandMessageType;

export type PlanType = {
  id: string;
  query: string;
  description: string;
  actions: Array<PlanItemType>;
};

================
File: web/src/components/apps/use-app.tsx
================
import { createContext, useContext, useEffect, useRef, useState } from 'react';
import type { AppType } from '@srcbook/shared';
import { updateApp as doUpdateApp } from '@/clients/http/apps';
import { AppChannel } from '@/clients/websocket';

export interface AppContextValue {
  app: AppType;
  channel: AppChannel;
  updateApp: (attrs: { name: string }) => void;
}

const AppContext = createContext<AppContextValue | undefined>(undefined);

type ProviderPropsType = {
  app: AppType;
  children: React.ReactNode;
};

export function AppProvider({ app: initialApp, children }: ProviderPropsType) {
  const [app, setApp] = useState(initialApp);

  const channelRef = useRef(AppChannel.create(app.id));

  useEffect(() => {
    // If the app ID has changed, create a new channel for the new app.
    if (channelRef.current.appId !== app.id) {
      channelRef.current.unsubscribe();
      channelRef.current = AppChannel.create(app.id);
    }

    // Subscribe to the channel
    channelRef.current.subscribe();

    // Unsubscribe when the component is unmounted
    return () => channelRef.current.unsubscribe();
  }, [app.id]);

  async function updateApp(attrs: { name: string }) {
    const { data: updatedApp } = await doUpdateApp(app.id, attrs);
    setApp(updatedApp);
  }

  return (
    <AppContext.Provider value={{ app, updateApp, channel: channelRef.current }}>
      {children}
    </AppContext.Provider>
  );
}

export function useApp(): AppContextValue {
  return useContext(AppContext) as AppContextValue;
}

================
File: web/src/components/apps/use-files.tsx
================
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useReducer,
  useRef,
  useState,
} from 'react';

import type {
  FileType,
  DirEntryType,
  FileEntryType,
  FileUpdatedPayloadType,
} from '@srcbook/shared';
import { AppChannel } from '@/clients/websocket';
import {
  createFile as doCreateFile,
  deleteFile as doDeleteFile,
  renameFile as doRenameFile,
  createDirectory,
  deleteDirectory,
  renameDirectory,
  loadDirectory,
} from '@/clients/http/apps';
import {
  createNode,
  deleteNode,
  renameDirNode,
  sortTree,
  updateDirNode,
  updateFileNode,
} from './lib/file-tree';
import { useApp } from './use-app';
import { useNavigate } from 'react-router-dom';
import { setLastOpenedFile } from './local-storage';

export interface FilesContextValue {
  fileTree: DirEntryType;
  openedFile: FileType | null;
  openFile: (entry: FileEntryType) => void;
  createFile: (dirname: string, basename: string, source?: string) => Promise<FileEntryType>;
  updateFile: (modified: FileType) => void;
  renameFile: (entry: FileEntryType, name: string) => Promise<void>;
  deleteFile: (entry: FileEntryType) => Promise<void>;
  createFolder: (dirname: string, basename: string) => Promise<void>;
  renameFolder: (entry: DirEntryType, name: string) => Promise<void>;
  deleteFolder: (entry: DirEntryType) => Promise<void>;
  openFolder: (entry: DirEntryType) => Promise<void>;
  closeFolder: (entry: DirEntryType) => void;
  toggleFolder: (entry: DirEntryType) => void;
  isFolderOpen: (entry: DirEntryType) => boolean;
}

const FilesContext = createContext<FilesContextValue | undefined>(undefined);

type ProviderPropsType = {
  channel: AppChannel;
  children: React.ReactNode;
  initialOpenedFile: FileType | null;
  rootDirEntries: DirEntryType;
};

export function FilesProvider({
  channel,
  rootDirEntries,
  initialOpenedFile,
  children,
}: ProviderPropsType) {
  // Because we use refs for our state, we need a way to trigger
  // component re-renders when the ref state changes.
  //
  // https://legacy.reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate
  //
  const [, forceComponentRerender] = useReducer((x) => x + 1, 0);

  const { app } = useApp();
  const navigateTo = useNavigate();

  const fileTreeRef = useRef<DirEntryType>(sortTree(rootDirEntries));
  const openedDirectoriesRef = useRef<Set<string>>(new Set());
  const [openedFile, _setOpenedFile] = useState<FileType | null>(initialOpenedFile);

  const setOpenedFile = useCallback(
    (fn: (file: FileType | null) => FileType | null) => {
      _setOpenedFile((prevOpenedFile) => {
        const openedFile = fn(prevOpenedFile);
        if (openedFile) {
          setLastOpenedFile(app.id, openedFile);
        }
        return openedFile;
      });
    },
    [app.id],
  );

  // Handle file updates from the server
  useEffect(() => {
    function onFileUpdated(payload: FileUpdatedPayloadType) {
      setOpenedFile(() => payload.file);
      forceComponentRerender();
    }
    channel.on('file:updated', onFileUpdated);

    return () => {
      channel.off('file:updated', onFileUpdated);
    };
  }, [channel, setOpenedFile]);

  const navigateToFile = useCallback(
    (file: { path: string }) => {
      navigateTo(`/apps/${app.id}/files/${encodeURIComponent(file.path)}`);
    },
    [app.id, navigateTo],
  );

  useEffect(() => {
    if (initialOpenedFile !== null && initialOpenedFile?.path !== openedFile?.path) {
      setOpenedFile(() => initialOpenedFile);
    }
  }, [initialOpenedFile, openedFile?.path, setOpenedFile]);

  const openFile = useCallback(
    (entry: FileEntryType) => {
      navigateToFile(entry);
    },
    [navigateToFile],
  );

  const createFile = useCallback(
    async (dirname: string, basename: string, source?: string) => {
      source = source || '';
      const { data: fileEntry } = await doCreateFile(app.id, dirname, basename, source);
      fileTreeRef.current = createNode(fileTreeRef.current, fileEntry);
      forceComponentRerender(); // required
      return fileEntry;
    },
    [app.id],
  );

  const updateFile = useCallback(
    (modified: FileType) => {
      channel.push('file:updated', { file: modified });
      setOpenedFile(() => modified);
      forceComponentRerender();
    },
    [channel, setOpenedFile],
  );

  const deleteFile = useCallback(
    async (entry: FileEntryType) => {
      await doDeleteFile(app.id, entry.path);
      setOpenedFile((openedFile) => {
        if (openedFile && openedFile.path === entry.path) {
          return null;
        }
        return openedFile;
      });
      fileTreeRef.current = deleteNode(fileTreeRef.current, entry.path);
      forceComponentRerender(); // required
    },
    [app.id, setOpenedFile],
  );

  const renameFile = useCallback(
    async (entry: FileEntryType, name: string) => {
      const { data: newEntry } = await doRenameFile(app.id, entry.path, name);
      setOpenedFile((openedFile) => {
        if (openedFile && openedFile.path === entry.path) {
          return { ...openedFile, path: newEntry.path, name: newEntry.basename };
        }
        return openedFile;
      });
      fileTreeRef.current = updateFileNode(fileTreeRef.current, entry, newEntry);
      forceComponentRerender(); // required
    },
    [app.id, setOpenedFile],
  );

  const isFolderOpen = useCallback((entry: DirEntryType) => {
    return openedDirectoriesRef.current.has(entry.path);
  }, []);

  const openFolder = useCallback(
    async (entry: DirEntryType) => {
      // Optimistically open the folder.
      openedDirectoriesRef.current.add(entry.path);
      forceComponentRerender();
      const { data: directory } = await loadDirectory(app.id, entry.path);
      fileTreeRef.current = updateDirNode(fileTreeRef.current, directory);
      forceComponentRerender();
    },
    [app.id],
  );

  const closeFolder = useCallback((entry: DirEntryType) => {
    openedDirectoriesRef.current.delete(entry.path);
    forceComponentRerender();
  }, []);

  const toggleFolder = useCallback(
    (entry: DirEntryType) => {
      if (isFolderOpen(entry)) {
        closeFolder(entry);
      } else {
        openFolder(entry);
      }
    },
    [isFolderOpen, openFolder, closeFolder],
  );

  const createFolder = useCallback(
    async (dirname: string, basename: string) => {
      const { data: folderEntry } = await createDirectory(app.id, dirname, basename);
      fileTreeRef.current = createNode(fileTreeRef.current, folderEntry);
      forceComponentRerender(); // required
      openFolder(folderEntry);
    },
    [app.id, openFolder],
  );

  const deleteFolder = useCallback(
    async (entry: DirEntryType) => {
      await deleteDirectory(app.id, entry.path);
      setOpenedFile((openedFile) => {
        if (openedFile && openedFile.path.startsWith(entry.path)) {
          return null;
        }
        return openedFile;
      });
      openedDirectoriesRef.current.delete(entry.path);
      fileTreeRef.current = deleteNode(fileTreeRef.current, entry.path);
      forceComponentRerender(); // required
    },
    [app.id, setOpenedFile],
  );

  const renameFolder = useCallback(
    async (entry: DirEntryType, name: string) => {
      const { data: newEntry } = await renameDirectory(app.id, entry.path, name);

      setOpenedFile((openedFile) => {
        if (openedFile && openedFile.path.startsWith(entry.path)) {
          return { ...openedFile, path: openedFile.path.replace(entry.path, newEntry.path) };
        }
        return openedFile;
      });

      if (openedDirectoriesRef.current.has(entry.path)) {
        openedDirectoriesRef.current.delete(entry.path);
        openedDirectoriesRef.current.add(newEntry.path);
      }

      fileTreeRef.current = renameDirNode(fileTreeRef.current, entry, newEntry);

      forceComponentRerender(); // required
    },
    [app.id, setOpenedFile],
  );

  const context: FilesContextValue = {
    fileTree: fileTreeRef.current,
    openedFile,
    openFile,
    createFile,
    updateFile,
    renameFile,
    deleteFile,
    createFolder,
    renameFolder,
    deleteFolder,
    openFolder,
    closeFolder,
    toggleFolder,
    isFolderOpen,
  };

  return <FilesContext.Provider value={context}>{children}</FilesContext.Provider>;
}

export function useFiles(): FilesContextValue {
  return useContext(FilesContext) as FilesContextValue;
}

================
File: web/src/components/apps/use-logs.tsx
================
import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';

import { AppChannel } from '@/clients/websocket';
import { DepsInstallLogPayloadType, PreviewLogPayloadType } from '@srcbook/shared';

export type LogMessage = {
  type: 'stderr' | 'stdout' | 'info';
  source: 'srcbook' | 'vite' | 'npm';
  timestamp: Date;
  message: string;
};

export interface LogsContextValue {
  logs: Array<LogMessage>;
  clearLogs: () => void;
  unreadLogsCount: number;
  panelIcon: 'default' | 'error';

  addLog: (type: LogMessage['type'], source: LogMessage['source'], message: string) => void;

  open: boolean;
  togglePane: () => void;
  closePane: () => void;
}

const LogsContext = createContext<LogsContextValue | undefined>(undefined);

type ProviderPropsType = {
  channel: AppChannel;
  children: React.ReactNode;
};

export function LogsProvider({ channel, children }: ProviderPropsType) {
  const [logs, setLogs] = useState<Array<LogMessage>>([]);
  const [unreadLogsCount, setUnreadLogsCount] = useState(0);
  const [panelIcon, setPanelIcon] = useState<LogsContextValue['panelIcon']>('default');

  const [open, setOpen] = useState(false);

  function clearLogs() {
    setLogs([]);
    setPanelIcon('default');
    setUnreadLogsCount(0);
  }

  const addLog = useCallback(
    (type: LogMessage['type'], source: LogMessage['source'], message: LogMessage['message']) => {
      setLogs((logs) => [...logs, { type, message, source, timestamp: new Date() }]);
      if (type === 'stderr') {
        setPanelIcon('error');
      }
      setUnreadLogsCount((n) => n + 1);
    },
    [],
  );

  function togglePane() {
    setOpen((n) => !n);
    setPanelIcon('default');
    setUnreadLogsCount(0);
  }

  function closePane() {
    setOpen(false);
    setPanelIcon('default');
    setUnreadLogsCount(0);
  }

  // As the server generates logs, show them in the logs panel
  useEffect(() => {
    function onPreviewLog(payload: PreviewLogPayloadType) {
      for (const row of payload.log.data.split('\n')) {
        addLog(payload.log.type, 'vite', row);
      }
    }

    channel.on('preview:log', onPreviewLog);

    function onDepsInstallLog(payload: DepsInstallLogPayloadType) {
      for (const row of payload.log.data.split('\n')) {
        addLog(payload.log.type, 'npm', row);
      }
    }
    channel.on('deps:install:log', onDepsInstallLog);

    return () => {
      channel.off('preview:log', onPreviewLog);
      channel.off('deps:install:log', onDepsInstallLog);
    };
  }, [channel, addLog]);

  return (
    <LogsContext.Provider
      value={{
        logs,
        clearLogs,
        unreadLogsCount,
        panelIcon,

        addLog,

        open,
        togglePane,
        closePane,
      }}
    >
      {children}
    </LogsContext.Provider>
  );
}

export function useLogs(): LogsContextValue {
  return useContext(LogsContext) as LogsContextValue;
}

================
File: web/src/components/apps/use-package-json.tsx
================
import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';
import { OutputType } from '@srcbook/components/src/types';
import { AppChannel } from '@/clients/websocket';
import {
  DepsInstallLogPayloadType,
  DepsInstallStatusPayloadType,
  DepsStatusResponsePayloadType,
} from '@srcbook/shared';
import { useLogs } from './use-logs';

type NpmInstallStatus = 'idle' | 'installing' | 'complete' | 'failed';

export interface PackageJsonContextValue {
  npmInstall: (packages?: string[]) => Promise<void>;
  clearNodeModules: () => void;

  nodeModulesExists: boolean | null;
  status: NpmInstallStatus;
  installing: boolean;
  failed: boolean;
  output: Array<OutputType>;
  showInstallModal: boolean;
  setShowInstallModal: (value: boolean) => void;
}

const PackageJsonContext = createContext<PackageJsonContextValue | undefined>(undefined);

type ProviderPropsType = {
  channel: AppChannel;
  children: React.ReactNode;
};

export function PackageJsonProvider({ channel, children }: ProviderPropsType) {
  const [status, setStatus] = useState<NpmInstallStatus>('idle');
  const [output, setOutput] = useState<Array<OutputType>>([]);
  const [nodeModulesExists, setNodeModulesExists] = useState<boolean | null>(null);
  const [showInstallModal, setShowInstallModal] = useState(false);
  const { addLog } = useLogs();

  useEffect(() => {
    channel.push('deps:status', {});
  }, [channel]);

  useEffect(() => {
    const callback = (data: DepsStatusResponsePayloadType) => {
      setNodeModulesExists(data.nodeModulesExists);
    };
    channel.on('deps:status:response', callback);

    return () => {
      channel.off('deps:status:response', callback);
    };
  }, [channel]);

  useEffect(() => {
    const callback = (payload: DepsInstallStatusPayloadType) => {
      setStatus(payload.status);
    };
    channel.on('deps:install:status', callback);

    return () => {
      channel.off('deps:install:status', callback);
    };
  }, [channel]);

  const npmInstall = useCallback(
    async (packages?: Array<string>) => {
      addLog(
        'info',
        'srcbook',
        `Running ${!packages ? 'npm install' : `npm install ${packages.join(' ')}`}...`,
      );

      // NOTE: caching of the log output is required here because socket events that call callback
      // functions in here hold on to old scope values
      let contents = '';

      return new Promise<void>((resolve, reject) => {
        const logCallback = ({ log }: DepsInstallLogPayloadType) => {
          setOutput((old) => [...old, log]);
          contents += log.data;
        };
        channel.on('deps:install:log', logCallback);

        const statusCallback = (payload: DepsInstallStatusPayloadType) => {
          switch (payload.status) {
            case 'installing':
              break;
            case 'failed':
            case 'complete':
              channel.off('deps:install:log', logCallback);
              channel.off('deps:install:status', statusCallback);

              addLog(
                'info',
                'srcbook',
                `${!packages ? 'npm install' : `npm install ${packages.join(' ')}`} exited with status code ${payload.code}`,
              );

              if (payload.status === 'complete') {
                resolve();
              } else {
                reject(new Error(`Error running npm install: ${contents}`));
              }
              break;
          }
        };
        channel.on('deps:install:status', statusCallback);

        setOutput([]);
        setStatus('installing');
        channel.push('deps:install', { packages });
      });
    },
    [channel, addLog],
  );

  const clearNodeModules = useCallback(() => {
    channel.push('deps:clear', {});
    setOutput([]);
  }, [channel]);

  const context: PackageJsonContextValue = {
    npmInstall,
    clearNodeModules,
    nodeModulesExists,
    status,
    installing: status === 'installing',
    failed: status === 'failed',
    output,
    showInstallModal,
    setShowInstallModal,
  };

  return <PackageJsonContext.Provider value={context}>{children}</PackageJsonContext.Provider>;
}

export function usePackageJson() {
  const context = useContext(PackageJsonContext);

  if (!context) {
    throw new Error('usePackageJson must be used within a PackageJsonProvider');
  }

  return context;
}

================
File: web/src/components/apps/use-preview.tsx
================
import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';

import { AppChannel } from '@/clients/websocket';
import { PreviewStatusPayloadType } from '@srcbook/shared';
import useEffectOnce from '@/components/use-effect-once';
import { usePackageJson } from './use-package-json';
import { useLogs } from './use-logs';

export type PreviewStatusType = 'booting' | 'connecting' | 'running' | 'stopped';

export interface PreviewContextValue {
  url: string | null;
  status: PreviewStatusType;
  stop: () => void;
  start: () => void;
  exitCode: number | null;
}

const PreviewContext = createContext<PreviewContextValue | undefined>(undefined);

type ProviderPropsType = {
  channel: AppChannel;
  children: React.ReactNode;
};

export function PreviewProvider({ channel, children }: ProviderPropsType) {
  const [url, setUrl] = useState<string | null>(null);
  const [status, setStatus] = useState<PreviewStatusType>('connecting');
  const [exitCode, setExitCode] = useState<number | null>(null);

  const { npmInstall, nodeModulesExists } = usePackageJson();
  const { addLog } = useLogs();

  useEffect(() => {
    function onStatusUpdate(payload: PreviewStatusPayloadType) {
      setUrl(payload.url);
      setStatus(payload.status);

      switch (payload.status) {
        case 'booting':
          addLog('info', 'srcbook', 'Dev server is booting...');
          break;
        case 'running':
          addLog('info', 'srcbook', `Dev server is running at ${payload.url}`);
          break;
        case 'stopped':
          addLog('info', 'srcbook', `Dev server exited with status ${payload.code}`);
          setExitCode(payload.code);
          break;
      }
    }

    channel.on('preview:status', onStatusUpdate);

    return () => channel.off('preview:status', onStatusUpdate);
  }, [channel, addLog]);

  async function start() {
    if (nodeModulesExists === false) {
      await npmInstall();
    }
    channel.push('preview:start', {});
  }

  const stop = useCallback(() => {
    channel.push('preview:stop', {});
  }, [channel]);

  // If the node_modules directory gets deleted, then stop the preview server
  useEffect(() => {
    if (nodeModulesExists !== false) {
      return;
    }
    stop();
  }, [nodeModulesExists, stop]);

  // When the page initially loads, start the vite server
  useEffectOnce(() => {
    start();
  });

  return (
    <PreviewContext.Provider value={{ url, status, stop, start, exitCode }}>
      {children}
    </PreviewContext.Provider>
  );
}

export function usePreview(): PreviewContextValue {
  return useContext(PreviewContext) as PreviewContextValue;
}

================
File: web/src/components/apps/use-version.tsx
================
import React, { createContext, useContext, useState, useCallback, useEffect } from 'react';
import { useApp } from './use-app';
import { checkoutVersion, commitVersion, getCurrentVersion } from '@/clients/http/apps';

interface Version {
  sha: string;
  message?: string;
}

interface VersionContextType {
  currentVersion: Version | null;
  createVersion: (message: string) => Promise<string | undefined>;
  checkout: (sha: string) => Promise<void>;
  fetchVersions: () => Promise<void>;
}

const VersionContext = createContext<VersionContextType | undefined>(undefined);

export const VersionProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { app } = useApp();
  const [currentVersion, setCurrentVersion] = useState<Version | null>(null);

  const fetchVersion = useCallback(async () => {
    if (!app) return;

    try {
      const currentVersionResponse = await getCurrentVersion(app.id);
      setCurrentVersion({ sha: currentVersionResponse.sha });
    } catch (error) {
      console.error('Error fetching current version:', error);
    }
  }, [app]);

  useEffect(() => {
    fetchVersion();
  }, [fetchVersion]);

  const commitFiles = useCallback(
    async (message: string) => {
      if (!app) return;

      try {
        const response = await commitVersion(app.id, message);
        setCurrentVersion({ sha: response.sha, message });
        return response.sha;
      } catch (error) {
        console.error('Error committing files:', error);
      }
    },
    [app],
  );

  const checkout = useCallback(
    async (sha: string) => {
      if (!app) return;

      try {
        const { sha: checkoutSha } = await checkoutVersion(app.id, sha);
        setCurrentVersion({ sha: checkoutSha });
      } catch (error) {
        console.error('Error checking out version:', error);
      }
    },
    [app],
  );

  return (
    <VersionContext.Provider
      value={{ currentVersion, createVersion: commitFiles, checkout, fetchVersions: fetchVersion }}
    >
      {children}
    </VersionContext.Provider>
  );
};

export const useVersion = () => {
  const context = useContext(VersionContext);
  if (context === undefined) {
    throw new Error('useVersion must be used within a VersionProvider');
  }
  return context;
};

================
File: web/src/components/cells/code.tsx
================
import { useEffect, useState } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import {
  CellType,
  CodeCellType,
  CodeCellUpdateAttrsType,
  CellErrorPayloadType,
  CellFormattedPayloadType,
  AiGeneratedCellPayloadType,
  TsServerDefinitionLocationResponsePayloadType,
  TsServerDiagnosticType,
} from '@srcbook/shared';
import { useSettings } from '@/components/use-settings';
import CodeCell from '@srcbook/components/src/components/cells/code';
import { SessionType } from '@/types';
import { CellModeType } from '@srcbook/components/src/types';
import { SessionChannel } from '@/clients/websocket';
import { useCells } from '@srcbook/components/src/components/use-cell';
import { mapCMLocationToTsServer, mapTsServerLocationToCM } from './util';
import { toast } from 'sonner';
import { getFileContent } from '@/lib/server';
import { tsHover } from '@/components/cells/hover';
import { autocompletion } from '@codemirror/autocomplete';
import { type Diagnostic, linter } from '@codemirror/lint';
import { javascript } from '@codemirror/lang-javascript';
import { getCompletions } from '@/components/cells/get-completions';
import CodeMirror, {
  EditorState,
  EditorView,
  Extension,
  KeyBinding,
  keymap,
  Prec,
} from '@uiw/react-codemirror';
import useTheme from '@srcbook/components/src/components/use-theme';
import { Dialog, DialogContent } from '@srcbook/components/src/components/ui/dialog';

function tsLinter(
  cell: CodeCellType,
  getTsServerDiagnostics: (id: string) => TsServerDiagnosticType[],
  getTsServerSuggestions: (id: string) => TsServerDiagnosticType[],
) {
  const semanticDiagnostics = getTsServerDiagnostics(cell.id);
  const syntaticDiagnostics = getTsServerSuggestions(cell.id);
  const diagnostics = [...syntaticDiagnostics, ...semanticDiagnostics].filter(
    isDiagnosticWithLocation,
  );

  const cm_diagnostics = diagnostics.map((diagnostic) => {
    return convertTSDiagnosticToCM(diagnostic, cell.source);
  });

  return linter(async (): Promise<readonly Diagnostic[]> => {
    return cm_diagnostics;
  });
}

function tsCategoryToSeverity(
  diagnostic: Pick<TsServerDiagnosticType, 'category' | 'code'>,
): Diagnostic['severity'] {
  if (diagnostic.code === 7027) {
    return 'warning';
  }
  // force resolve types with fallback
  switch (diagnostic.category) {
    case 'error':
      return 'error';
    case 'warning':
      return 'warning';
    case 'suggestion':
      return 'warning';
    case 'info':
      return 'info';
    default:
      return 'info';
  }
}

function isDiagnosticWithLocation(
  diagnostic: TsServerDiagnosticType,
): diagnostic is TsServerDiagnosticType {
  return !!(typeof diagnostic.start.line === 'number' && typeof diagnostic.end.line === 'number');
}

function tsDiagnosticMessage(diagnostic: TsServerDiagnosticType): string {
  if (typeof diagnostic.text === 'string') {
    return diagnostic.text;
  }
  return JSON.stringify(diagnostic); // Fallback
}

function convertTSDiagnosticToCM(diagnostic: TsServerDiagnosticType, code: string): Diagnostic {
  const message = tsDiagnosticMessage(diagnostic);

  return {
    from: mapTsServerLocationToCM(code, diagnostic.start.line, diagnostic.start.offset),
    to: mapTsServerLocationToCM(code, diagnostic.end.line, diagnostic.end.offset),
    message: message,
    severity: tsCategoryToSeverity(diagnostic),
    renderMessage: () => {
      const dom = document.createElement('div');
      dom.className = 'p-2 space-y-3 border-t max-w-lg max-h-64 text-xs relative';
      dom.innerText = message;

      return dom;
    },
  };
}

const DEBOUNCE_DELAY = 500;

type BaseProps = {
  session: SessionType;
  cell: CodeCellType;
};

type RegularProps = BaseProps & {
  readOnly?: false;
  channel: SessionChannel;
  updateCellOnServer: (cell: CodeCellType, attrs: CodeCellUpdateAttrsType) => void;
  onDeleteCell: (cell: CellType) => void;
};
type ReadOnlyProps = BaseProps & { readOnly: true };
type Props = RegularProps | ReadOnlyProps;

export default function ControlledCodeCell(props: Props) {
  const { readOnly, cell } = props;
  const channel = !readOnly ? props.channel : null;

  const { theme, codeTheme } = useTheme();

  const [filenameError, _setFilenameError] = useState<string | null>(null);
  const [showStdio, setShowStdio] = useState(false);
  const [cellMode, setCellMode] = useState<CellModeType>('off');
  const [generationType, setGenerationType] = useState<'edit' | 'fix'>('edit');
  const [prompt, setPrompt] = useState('');
  const [newSource, setNewSource] = useState('');
  const [fullscreen, setFullscreen] = useState(false);
  const { aiEnabled } = useSettings();

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalContent, setModalContent] = useState('');

  useHotkeys(
    'mod+enter',
    () => {
      if (!prompt) return;
      if (cellMode !== 'prompting') return;
      if (!aiEnabled) return;
      generate();
    },
    { enableOnFormTags: ['textarea'] },
  );

  useHotkeys(
    'escape',
    () => {
      if (cellMode === 'prompting') {
        setCellMode('off');
        setPrompt('');
      }
    },

    { enableOnFormTags: ['textarea'] },
  );

  const {
    updateCell: updateCellOnClient,
    clearOutput,
    getTsServerDiagnostics,
    getTsServerSuggestions,
  } = useCells();

  function setFilenameError(error: string | null) {
    _setFilenameError(error);
    setTimeout(() => _setFilenameError(null), 3000);
  }

  useEffect(() => {
    if (!channel) {
      return;
    }

    function callback(payload: CellErrorPayloadType) {
      if (payload.cellId !== cell.id) {
        return;
      }

      const filenameError = payload.errors.find((e) => e.attribute === 'filename');

      if (filenameError) {
        setFilenameError(filenameError.message);
      }

      const formattingError = payload.errors.find((e) => e.attribute === 'formatting');
      if (formattingError) {
        toast.error(formattingError.message);
        setCellMode('off');
      }
    }

    channel.on('cell:error', callback);

    return () => channel.off('cell:error', callback);
  }, [cell.id, channel]);

  useEffect(() => {
    if (!channel) {
      return;
    }

    function callback(payload: CellFormattedPayloadType) {
      if (payload.cellId === cell.id) {
        updateCellOnClient({ ...payload.cell });
        setCellMode('off');
      }
    }

    channel.on('cell:formatted', callback);
    return () => channel.off('cell:formatted', callback);
  }, [cell.id, channel, updateCellOnClient]);

  function onUpdateFileName(filename: string) {
    if (!channel) {
      return;
    }

    updateCellOnClient({ ...cell, filename });
    channel.push('cell:rename', {
      cellId: cell.id,
      filename,
    });
  }

  useEffect(() => {
    if (!channel) {
      return;
    }

    function callback(payload: AiGeneratedCellPayloadType) {
      if (payload.cellId !== cell.id) return;
      // We move to the "review" stage of the generation process:
      setNewSource(payload.output);
      setCellMode('reviewing');
    }
    channel.on('ai:generated', callback);
    return () => channel.off('ai:generated', callback);
  }, [cell.id, channel]);

  const generate = () => {
    if (!channel) {
      return;
    }

    setGenerationType('edit');
    channel.push('ai:generate', {
      cellId: cell.id,
      prompt,
    });
    setCellMode('generating');
  };

  const aiFixDiagnostics = (diagnostics: string) => {
    if (!channel) {
      return;
    }
    setCellMode('fixing');
    setGenerationType('fix');
    channel.push('ai:fix_diagnostics', {
      cellId: cell.id,
      diagnostics,
    });
  };

  function runCell() {
    if (!channel) {
      return false;
    }
    if (cell.status === 'running') {
      return false;
    }

    setShowStdio(true);

    // Update client side only. The server will know it's running from the 'cell:exec' event.
    updateCellOnClient({ ...cell, status: 'running' });
    clearOutput(cell.id);

    // Add artificial delay to allow debounced updates to propagate
    // TODO: Handle this in a more robust way
    setTimeout(() => {
      channel.push('cell:exec', {
        cellId: cell.id,
      });
    }, DEBOUNCE_DELAY + 10);
  }

  function stopCell() {
    if (!channel) {
      return;
    }
    channel.push('cell:stop', { cellId: cell.id });
  }

  function onRevertDiff() {
    setCellMode(generationType === 'edit' ? 'prompting' : 'off');
    setNewSource('');
  }

  function onAcceptDiff() {
    if (readOnly) {
      return;
    }
    updateCellOnClient({ ...cell, source: newSource });
    props.updateCellOnServer(cell, { source: newSource });
    setPrompt('');
    setCellMode('off');
  }

  function formatCell() {
    if (!channel) {
      return;
    }
    setCellMode('formatting');
    channel.push('cell:format', {
      cellId: cell.id,
    });
  }

  async function onGetDefinitionContents(pos: number, cell: CodeCellType): Promise<string> {
    return new Promise((resolve, reject) => {
      if (!channel) {
        return;
      }

      async function gotoDefCallback({ response }: TsServerDefinitionLocationResponsePayloadType) {
        if (!channel) {
          return;
        }

        channel.off('tsserver:cell:definition_location:response', gotoDefCallback);
        if (response === null) {
          reject(new Error(`Error fetching file content: no response!`));
          return;
        }
        const file_response = await getFileContent(response.file);
        if (file_response.result.type === 'cell') {
          document
            .getElementById(file_response.result.filename)
            ?.scrollIntoView({ behavior: 'smooth' });
        } else {
          if (file_response.error) {
            reject(new Error(`Error fetching file content: ${file_response.result}`));
          } else {
            resolve(file_response.result.content);
          }
        }
      }

      channel.on('tsserver:cell:definition_location:response', gotoDefCallback);
      channel.push('tsserver:cell:definition_location:request', {
        cellId: cell.id,
        request: { location: mapCMLocationToTsServer(cell.source, pos) },
      });
    });
  }

  // The order of these extensions is important.
  // We want the errors to be first, so we call tsLinter before tsHover.
  const extensions: Array<Extension> = [javascript({ typescript: true })];
  if (channel) {
    extensions.push(tsHover(cell, channel, theme));
  }
  extensions.push(tsLinter(cell, getTsServerDiagnostics, getTsServerSuggestions));
  if (channel) {
    extensions.push(
      autocompletion({
        override: [(context) => getCompletions(context, cell, channel)],
      }),
    );
  }
  extensions.push(
    Prec.highest(
      EditorView.domEventHandlers({
        click: (e, view) => {
          if (!onGetDefinitionContents) {
            return;
          }
          const pos = view.posAtCoords({ x: e.clientX, y: e.clientY });
          if (pos && e.altKey) {
            onGetDefinitionContents(pos, cell)
              .then((result) => {
                setModalContent(result);
                setIsModalOpen(true);
              })
              .catch((error) => {
                console.error('Error calling onGetDefinitionContents:', error);
                toast.error('Error calling goto definition!');
              });
          }
        },
      }),
    ),
  );

  const keys: Array<KeyBinding> = [];
  if (runCell) {
    keys.push({
      key: 'Mod-Enter',
      run: () => {
        runCell();
        return true;
      },
    });
  }
  if (formatCell) {
    keys.push({
      key: 'Shift-Alt-f',
      run: () => {
        formatCell();
        return true;
      },
    });
  }
  extensions.push(Prec.highest(keymap.of(keys)));

  if (['generating', 'prompting', 'formatting'].includes(cellMode)) {
    extensions.push(EditorView.editable.of(false));
    extensions.push(EditorState.readOnly.of(true));
  }

  if (props.readOnly) {
    return <CodeCell readOnly cell={props.cell} session={props.session} codeTheme={codeTheme} />;
  } else {
    return (
      <>
        <CodeCell
          aiEnabled={aiEnabled}
          aiFixDiagnostics={aiFixDiagnostics}
          cell={props.cell}
          cellMode={cellMode}
          filenameError={filenameError}
          fullscreen={fullscreen}
          generationType={generationType}
          newSource={newSource}
          onAccept={onAcceptDiff}
          onChangeCellModeType={setCellMode}
          onChangeFilenameError={setFilenameError}
          onChangeFullscreen={setFullscreen}
          onChangeGenerationType={setGenerationType}
          onChangeNewSource={setNewSource}
          onChangePrompt={setPrompt}
          onChangeShowStdio={setShowStdio}
          onDeleteCell={props.onDeleteCell}
          onFormatCell={formatCell}
          onGenerate={generate}
          onGetDefinitionContents={onGetDefinitionContents}
          onRevert={onRevertDiff}
          onRunCell={runCell}
          onStopCell={stopCell}
          onUpdateFileName={onUpdateFileName}
          prompt={prompt}
          session={props.session}
          showStdio={showStdio}
          updateCellOnServer={props.updateCellOnServer}
          fixDiagnostics={aiFixDiagnostics}
          editorExtensions={extensions}
          codeTheme={codeTheme}
        />
        <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
          <DialogContent className="w-[80vw] h-[80vh] max-w-none p-0 overflow-scroll">
            <CodeMirror
              className="overflow-scroll focus-visible:outline-none"
              value={modalContent}
              theme={codeTheme}
              extensions={[
                javascript({ typescript: true }),
                EditorView.editable.of(false),
                EditorState.readOnly.of(true),
              ]}
            />
          </DialogContent>
        </Dialog>
      </>
    );
  }
}

================
File: web/src/components/cells/generate-ai.tsx
================
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useHotkeys } from 'react-hotkeys-hook';
import { type CodeCellType, type MarkdownCellType } from '@srcbook/shared';
import { generateCells } from '@/lib/server';
import { CircleAlert, Trash2, Sparkles } from 'lucide-react';
import { SessionType } from '@/types';
import { GenerateAICellType } from '@srcbook/components/src/types';
import { useCells } from '@srcbook/components/src/components/use-cell';
import { cn } from '@/lib/utils';
import { Button } from '@srcbook/components/src/components/ui/button';
import { useSettings } from '@/components/use-settings';

export default function GenerateAiCell(props: {
  cell: GenerateAICellType;
  insertIdx: number;
  session: SessionType;
  onSuccess: (idx: number, cells: Array<CodeCellType | MarkdownCellType>) => void;
}) {
  const { cell, insertIdx, session, onSuccess } = props;
  const [state, setState] = useState<'idle' | 'loading'>('idle');
  const { removeCell } = useCells();
  const [prompt, setPrompt] = useState('');
  const [error, setError] = useState<string | null>(null);

  const { aiEnabled } = useSettings();

  const navigate = useNavigate();
  useHotkeys(
    'mod+enter',
    () => {
      if (!prompt) return;
      generate();
    },
    { enableOnFormTags: ['textarea'] },
  );

  const generate = async () => {
    setError(null);
    setState('loading');
    const { result, error } = await generateCells(session.id, {
      query: prompt,
      insertIdx: insertIdx,
    });
    setState('idle');
    if (error) {
      setError(result);
    } else {
      // We have successfully converted a prompt into a valid cell.
      // Create the new markdown | code cell, then cleanup the current temporary one.
      onSuccess(insertIdx, result);
      removeCell(cell);
    }
  };

  return (
    <div
      id={`cell-${cell.id}`}
      className={cn(
        'group/cell relative w-full rounded-md border border-border transition-all',
        state === 'loading'
          ? 'ring-1 ring-ai-ring border-ai-ring'
          : 'focus-within:ring-1 focus-within:ring-ring focus-within:border-ring',
        error &&
          'ring-1 ring-sb-red-30 border-sb-red-30 hover:border-sb-red-30 focus-within:border-sb-red-30 focus-within:ring-sb-red-30',
      )}
    >
      <div className="flex flex-col">
        <div className="p-1 w-full flex items-center justify-between z-10">
          <div className="flex items-center gap-2">
            <h5 className="pl-4 text-sm font-mono font-bold">Generate with AI</h5>
            <Button
              variant="secondary"
              size="icon"
              className="border-secondary hover:border-muted"
              onClick={() => removeCell(cell)}
            >
              <Trash2 size={16} />
            </Button>
          </div>

          <div>
            <Button
              disabled={!prompt || !aiEnabled}
              onClick={generate}
              variant={state === 'idle' ? 'default' : 'ai'}
            >
              {state === 'idle' ? 'Generate' : 'Generating'}
            </Button>
          </div>
        </div>

        <div className={cn('flex items-start', error && 'border-b')}>
          <Sparkles size={16} className="m-2.5" />

          <textarea
            value={prompt}
            // eslint-disable-next-line jsx-a11y/no-autofocus -- needed for action flow
            autoFocus
            onChange={(e) => setPrompt(e.target.value)}
            placeholder="Write a prompt..."
            className="flex min-h-[80px] bg-transparent w-full rounded-sm px-3 py-2 text-sm placeholder:text-muted-foreground focus-visible:outline-none pl-0"
          />
        </div>

        {error && (
          <div className="flex items-center gap-2 m-2 px-2.5 py-2 text-sb-red-80 bg-sb-red-30 rounded-sm justify-center">
            <CircleAlert size={16} />
            <p className="text-xs line-clamp-1 ">{error}</p>
          </div>
        )}

        {!aiEnabled && (
          <div className="flex items-center justify-between bg-sb-yellow-20 text-sb-yellow-80 rounded-sm text-sm px-3 py-1 m-3">
            <p>AI provider not configured.</p>

            <button
              className="font-medium underline cursor-pointer"
              onClick={() => navigate('/settings')}
            >
              Settings
            </button>
          </div>
        )}
      </div>
    </div>
  );
}

================
File: web/src/components/cells/get-completions.ts
================
import { SessionChannel } from '@/clients/websocket';
import { CompletionContext, CompletionResult } from '@codemirror/autocomplete';
import { CodeCellType, TsServerCompletionEntriesPayloadType } from '@srcbook/shared';
import { mapCMLocationToTsServer } from './util';

export function getCompletions(
  context: CompletionContext,
  cell: CodeCellType,
  channel: SessionChannel,
): Promise<CompletionResult | null> {
  return new Promise((resolve) => {
    if (cell.language !== 'typescript') {
      resolve(null);
      return;
    }

    const word = context.matchBefore(/\w*/);
    if (word?.from == word?.to && !context.explicit) {
      resolve(null);
      return;
    }

    const pos = context.pos;

    function callback({ response }: TsServerCompletionEntriesPayloadType) {
      channel.off('tsserver:cell:completions:response', callback);
      if (response === null) {
        return;
      }
      const options = response.entries.map((entry) => ({
        label: entry.name,
        type: entry.kind,
        info: entry.kindModifiers,
      }));

      resolve({
        from: word?.from ?? pos,
        options: options,
      });
    }

    channel.on('tsserver:cell:completions:response', callback);

    channel.push('tsserver:cell:completions:request', {
      cellId: cell.id,
      request: {
        location: mapCMLocationToTsServer(cell.source, pos),
      },
    });
  });
}

================
File: web/src/components/cells/hover.ts
================
import type {
  CodeCellType,
  TsServerJsDocTagsType,
  TsServerJSDocType,
  TsServerQuickInfoResponsePayloadType,
} from '@srcbook/shared';
import { Extension, hoverTooltip } from '@uiw/react-codemirror';
import { mapCMLocationToTsServer } from './util';
import { SessionChannel } from '@/clients/websocket';
import { parse } from 'marked';
import { formatCode } from '@srcbook/components/src/lib/code-theme';
import { type ThemeType } from '@srcbook/components/src/components/use-theme';

/** Hover extension for TS server information */
export function tsHover(cell: CodeCellType, channel: SessionChannel, theme: ThemeType): Extension {
  return hoverTooltip(async (view, pos) => {
    if (cell.language !== 'typescript') {
      return null; // bail early if not typescript
    }

    const { from, to, text } = view.state.doc.lineAt(pos);
    let start = pos;
    let end = pos;

    while (start > from && /\w/.test(text[start - from - 1] ?? '')) start--;
    while (end < to && /\w/.test(text[end - from] ?? '')) end++;

    return {
      pos: start,
      end: end,
      create: () => {
        const tooltipContainer = document.createElement('div');
        tooltipContainer.className = 'hidden';

        function callback({ response }: TsServerQuickInfoResponsePayloadType) {
          tooltipContainer.className = 'p-2 space-y-2 max-w-3xl max-h-96 overflow-scroll text-xs';
          const signatureNode = formatCode(response.displayString, theme);
          tooltipContainer.appendChild(signatureNode);

          const documentationNode = formatDocumentation(response.documentation);
          if (documentationNode !== null) {
            tooltipContainer.appendChild(documentationNode);
          }

          const tagsNode = formatTags(response.tags);
          if (tagsNode !== null) {
            tooltipContainer.appendChild(tagsNode);
          }
        }

        return {
          dom: tooltipContainer,
          mount() {
            channel.on('tsserver:cell:quickinfo:response', callback);
            channel.push('tsserver:cell:quickinfo:request', {
              cellId: cell.id,
              request: { location: mapCMLocationToTsServer(cell.source, pos) },
            });
          },
          destroy() {
            channel.off('tsserver:cell:quickinfo:response', callback);
          },
        };
      },
    };
  });
}

function formatDocumentation(documentation: TsServerJSDocType): HTMLElement | null {
  if (!documentation) {
    return null;
  }

  const text =
    typeof documentation === 'string'
      ? documentation.trim()
      : documentation
          .map((part) => (typeof part === 'string' ? part : `${part.text} kind ${part.kind}`))
          .join('\n\n')
          .trim();

  if (text.length === 0) {
    return null;
  }

  const div = document.createElement('div');
  div.className = 'sb-prose-mini text-secondary-foreground';
  div.innerHTML = parse(text) as string;

  return div;
}

function formatTags(tags: TsServerJsDocTagsType): HTMLElement | null {
  if (tags.length === 0) {
    return null;
  }

  const div = document.createElement('div');
  div.className = 'sb-prose-mini text-secondary-foreground space-y-2';

  for (const tag of tags) {
    const tagDiv = document.createElement('div');

    const span = document.createElement('span');
    span.className = 'italic';

    if (tag.name === 'example') {
      span.innerText = '@example';
      tagDiv.appendChild(span);
      tagDiv.appendChild(document.createElement('br'));
    } else {
      span.innerText = `@${tag.name}`;
      tagDiv.appendChild(span);
    }

    if (typeof tag.text === 'string') {
      const span = document.createElement('span');
      span.appendChild(document.createTextNode('\u00A0'));
      span.appendChild(document.createTextNode(tag.text));
      tagDiv.append(span);
    }

    div.appendChild(tagDiv);
  }

  return div;
}

================
File: web/src/components/cells/util.ts
================
export function mapTsServerLocationToCM(code: string, line: number, offset: number): number {
  const lines = code.split('\n');
  const startOffset =
    lines.slice(0, line - 1).reduce((sum, line) => sum + line.length + 1, 0) + offset - 1;
  return Math.min(code.length - 1, startOffset);
}

export function mapCMLocationToTsServer(
  code: string,
  cmPosition: number,
): { line: number; offset: number } {
  const lines = code.split('\n');
  let remainingPosition = cmPosition;
  let lineIndex = 0;

  while (lineIndex < lines.length && remainingPosition > (lines[lineIndex]?.length ?? 0)) {
    remainingPosition -= (lines[lineIndex]?.length ?? 0) + 1; // +1 for newline character
    lineIndex++;
  }

  return {
    line: lineIndex + 1,
    offset: remainingPosition,
  };
}

================
File: web/src/components/session-menu/index.tsx
================
import { marked } from 'marked';
import { cn } from '@/lib/utils';
import { useHotkeys } from 'react-hotkeys-hook';
import { useEffect, useMemo, useState } from 'react';
import { SessionChannel } from '@/clients/websocket';
import {
  KeyboardIcon,
  ListIcon,
  MessageCircleIcon,
  PackageIcon,
  SettingsIcon,
  KeySquareIcon,
  XIcon,
} from 'lucide-react';
import type { SessionType } from '@/types';
import KeyboardShortcutsDialog from '@/components/keyboard-shortcuts-dialog';
import FeedbackDialog from '@/components/feedback-dialog';
import { Button } from '@srcbook/components/src/components/ui/button';
import { Sheet, SheetContent } from '@srcbook/components/src/components/ui/sheet';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@srcbook/components/src/components/ui/tooltip';
import SessionMenuPanelTableOfContents from './table-of-contents-panel';
import SessionMenuPanelPackages from './packages-panel';
import SessionMenuPanelSettings from './settings-panel';
import SessionMenuPanelSecrets from './secrets-panel';

export type SessionMenuPanelContentsProps = {
  readOnly: boolean;
  session: SessionType;
  channel: SessionChannel | null;
  openDepsInstallModal: (() => void) | null;
};

export const SESSION_MENU_PANELS = [
  {
    name: 'tableOfContents' as const,
    icon: ListIcon,
    openWidthInPx: 312,
    contents: () => <SessionMenuPanelTableOfContents />,
    tooltipContent: 'Table of contents',
    showInReadOnly: true,
  },
  {
    name: 'packages' as const,
    icon: PackageIcon,
    openWidthInPx: 480,
    contents: ({ readOnly, openDepsInstallModal }: SessionMenuPanelContentsProps) => (
      <SessionMenuPanelPackages readOnly={readOnly} openDepsInstallModal={openDepsInstallModal} />
    ),
    tooltipContent: 'package.json',
    showInReadOnly: true,
  },
  {
    name: 'settings' as const,
    icon: SettingsIcon,
    openWidthInPx: 480,
    contents: (props: SessionMenuPanelContentsProps) => <SessionMenuPanelSettings {...props} />,
    tooltipContent: 'Settings and configuration',
    showInReadOnly: true,
  },
  {
    name: 'secrets' as const,
    icon: KeySquareIcon,
    openWidthInPx: 480,
    contents: (props: SessionMenuPanelContentsProps) => (
      <SessionMenuPanelSecrets session={props.session} />
    ),
    showInReadOnly: false,
  },
];
export type Panel = (typeof SESSION_MENU_PANELS)[0];

type BaseProps = {
  session: SessionType;
  selectedPanelName: Panel['name'];
  selectedPanelOpen: boolean;
  onChangeSelectedPanelNameAndOpen: (
    old: (param: [Panel['name'], boolean]) => [Panel['name'], boolean],
  ) => void;
};

type Props =
  | (BaseProps & { readOnly: true })
  | (BaseProps & {
      readOnly?: false;
      openDepsInstallModal: () => void;
      channel: SessionChannel;
    });

marked.use({ gfm: true });

const SESSION_MENU_SHEET_PANEL_WIDTH_BREAKPOINT_PX = 1024;

type SessionMenuPanelProps = {
  open: boolean;
  openWidthPx: number;
  onClose: () => void;
  children: React.ReactNode;
  sidebar?: React.ReactNode;
};

function SessionMenuPanel(props: SessionMenuPanelProps) {
  const [mode, setMode] = useState<'panel' | 'sheet' | null>(null);
  useEffect(() => {
    // ref: https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/ResizeObserver#examples
    const observer = new ResizeObserver((entries) => {
      if (entries.length < 1) {
        return;
      }

      const entry = entries[0];
      if (!entry) {
        return;
      }

      const widthInPx = entry.contentRect.width;
      const newMode = widthInPx > SESSION_MENU_SHEET_PANEL_WIDTH_BREAKPOINT_PX ? 'panel' : 'sheet';
      setMode(newMode);
    });

    observer.observe(document.body);
    return () => {
      observer.unobserve(document.body);
    };
  }, []);

  switch (mode) {
    case 'sheet':
      return (
        <div className="fixed inset-0 top-12 z-50 pointer-events-none">
          <Sheet open={props.open} onOpenChange={() => props.onClose()}>
            <SheetContent
              side="left"
              className="overflow-y-auto p-0"
              style={{ width: props.openWidthPx }}
              portal={false}
            >
              <div className="flex grow shrink h-full">
                {props.sidebar ? (
                  <div className="grow-0 shrink-0 w-12 h-full">{props.sidebar}</div>
                ) : null}
                <div className="grow shrink p-6">{props.children}</div>
              </div>
            </SheetContent>
          </Sheet>
        </div>
      );

    case 'panel':
    default:
      return (
        /* 1. Wraps the whole thing in a static positioned div that takes up the proper width for */
        /*    alignment */
        <div
          className="hidden lg:block grow-0 shrink-0 transition-all duration-100"
          style={{ width: props.open ? props.openWidthPx : 0 }}
        >
          {/* 2. Fixed position the panel so it doesn't scroll with the page */}
          <div
            className={cn(
              'flex flex-col gap-6 border-r transition-all duration-100 z-50',
              'fixed top-12 left-12 bottom-0 overflow-y-auto bg-background',
              { 'border-r-0': !props.open },
            )}
            style={{ width: props.open ? props.openWidthPx : 0 }}
          >
            <div
              className={cn('absolute top-1 right-1 transition-opacity duration-100', {
                'opacity-0': !props.open,
              })}
            >
              <Button variant="icon" size="icon" onClick={props.onClose}>
                <XIcon size={16} />
              </Button>
            </div>

            {/* 3. By again setting the width on this wrapper, the panel closing won't cause text to */}
            {/*    wrap due to intermediate width changes / etc */}
            <div className="p-6" style={{ width: props.openWidthPx }}>
              {props.children}
            </div>
          </div>
        </div>
      );
  }
}

type SidebarProps = {
  readOnly?: boolean;
  selectedPanelName: Panel['name'];
  selectedPanelOpen: boolean;
  onChangeSelectedPanelNameAndOpen: (
    old: (param: [Panel['name'], boolean]) => [Panel['name'], boolean],
  ) => void;
  onShowShortcutsModal: () => void;
  onShowFeedbackModal: () => void;
};

function Sidebar({
  readOnly,
  selectedPanelName,
  selectedPanelOpen,
  onChangeSelectedPanelNameAndOpen,
  onShowShortcutsModal,
  onShowFeedbackModal,
}: SidebarProps) {
  return (
    <div className="flex flex-col items-center justify-between w-12 h-full py-4">
      <div className="flex flex-col items-center w-full gap-2">
        {SESSION_MENU_PANELS.map((panel) => {
          if (readOnly && !panel.showInReadOnly) {
            return null;
          }

          const Icon = panel.icon;
          return (
            <TooltipProvider key={panel.name}>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="icon"
                    size="icon"
                    className="active:translate-y-0"
                    onClick={() =>
                      onChangeSelectedPanelNameAndOpen(([oldName, oldOpen]) => {
                        return oldName === panel.name && oldOpen
                          ? [oldName, false]
                          : [panel.name, true];
                      })
                    }
                  >
                    <Icon
                      size={18}
                      className={cn({
                        'stroke-secondary-foreground':
                          selectedPanelOpen && selectedPanelName === panel.name,
                        'stroke-tertiary-foreground':
                          !selectedPanelOpen || selectedPanelName !== panel.name,
                      })}
                    />
                  </Button>
                </TooltipTrigger>
                <TooltipContent side="right">{panel.tooltipContent}</TooltipContent>
              </Tooltip>
            </TooltipProvider>
          );
        })}
      </div>
      <div className="flex flex-col items-center w-full gap-2">
        <TooltipProvider>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                variant="icon"
                size="icon"
                className="active:translate-y-0"
                onClick={onShowShortcutsModal}
              >
                <KeyboardIcon size={18} className="stroke-tertiary-foreground" />
              </Button>
            </TooltipTrigger>
            <TooltipContent side="right">Keyboard shortcuts</TooltipContent>
          </Tooltip>
        </TooltipProvider>
        {!readOnly ? (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="icon"
                  size="icon"
                  className="active:translate-y-0"
                  onClick={onShowFeedbackModal}
                >
                  <MessageCircleIcon size={18} className="stroke-tertiary-foreground" />
                </Button>
              </TooltipTrigger>
              <TooltipContent side="right">Leave feedback</TooltipContent>
            </Tooltip>
          </TooltipProvider>
        ) : null}
      </div>
    </div>
  );
}

export default function SessionMenu(props: Props) {
  const {
    readOnly,
    session,
    selectedPanelName,
    selectedPanelOpen,
    onChangeSelectedPanelNameAndOpen,
  } = props;
  const openDepsInstallModal = !readOnly ? props.openDepsInstallModal : null;
  const channel = !readOnly ? props.channel : null;

  const [showShortcuts, setShowShortcuts] = useState(false);
  const [showFeedback, setShowFeedback] = useState(false);

  const selectedPanel = useMemo(
    () => SESSION_MENU_PANELS.find((panel) => panel.name === selectedPanelName)!,
    [selectedPanelName],
  );

  // The key '?' is buggy, so we use 'Slash' with 'shift' modifier.
  // This assumes qwerty layout.
  useHotkeys('shift+Slash', () => setShowShortcuts(!showShortcuts));

  const selectedPanelContentsProps: SessionMenuPanelContentsProps = useMemo(
    () => ({
      readOnly: readOnly || false,
      session,
      channel,
      openDepsInstallModal,
    }),
    [readOnly, session, channel, openDepsInstallModal],
  );

  return (
    <>
      <KeyboardShortcutsDialog
        readOnly={readOnly}
        open={showShortcuts}
        onOpenChange={setShowShortcuts}
      />
      {!readOnly ? <FeedbackDialog open={showFeedback} onOpenChange={setShowFeedback} /> : null}

      {/* The sidebar is of a certain defined pixel width whoose parent takes the space of the fixed position element: */}
      <div className="grow-0 shrink-0 w-12">
        <div className="fixed top-12 left-0 bottom-0 w-12">
          <Sidebar
            readOnly={readOnly}
            selectedPanelName={selectedPanelName}
            selectedPanelOpen={selectedPanelOpen}
            onChangeSelectedPanelNameAndOpen={onChangeSelectedPanelNameAndOpen}
            onShowShortcutsModal={() => setShowShortcuts(true)}
            onShowFeedbackModal={() => setShowFeedback(true)}
          />
        </div>
      </div>

      {/* The opened panel is of a certain defined pixel width whose parent takes the space of the fixed position element: */}
      <SessionMenuPanel
        open={selectedPanelOpen}
        openWidthPx={selectedPanel?.openWidthInPx ?? 0}
        onClose={() => onChangeSelectedPanelNameAndOpen(([name, _open]) => [name, false])}
        sidebar={
          <Sidebar
            readOnly={readOnly}
            selectedPanelName={selectedPanelName}
            selectedPanelOpen={selectedPanelOpen}
            onChangeSelectedPanelNameAndOpen={onChangeSelectedPanelNameAndOpen}
            onShowShortcutsModal={() => setShowShortcuts(true)}
            onShowFeedbackModal={() => setShowFeedback(true)}
          />
        }
      >
        {selectedPanel.contents(selectedPanelContentsProps)}
      </SessionMenuPanel>
    </>
  );
}

================
File: web/src/components/session-menu/packages-panel.tsx
================
import { useState } from 'react';
import { OutputType } from '@srcbook/components/src/types';
import {
  Info,
  LoaderCircle,
  Play,
  PanelBottomOpen,
  PanelBottomClose,
  CopyIcon,
  CheckIcon,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import CollapsibleContainer from '@/components/collapsible-container';
import CodeMirror, { keymap, Prec } from '@uiw/react-codemirror';
import { json } from '@codemirror/lang-json';
import useTheme from '@srcbook/components/src/components/use-theme';
import { Button } from '@srcbook/components/src/components/ui/button';
import { usePackageJson } from '@/components/use-package-json';

import { SessionMenuPanelContentsProps } from '.';

type PropsType = Pick<SessionMenuPanelContentsProps, 'readOnly' | 'openDepsInstallModal'>;

export default function SessionMenuPanelPackages({ readOnly, openDepsInstallModal }: PropsType) {
  return (
    <>
      <h4 className="text-lg font-semibold leading-tight mb-4">Dependencies</h4>
      <PackageJson readOnly={readOnly} openDepsInstallModal={openDepsInstallModal} />
    </>
  );
}

function PackageJson({
  readOnly,
  openDepsInstallModal,
}: {
  readOnly: boolean;
  openDepsInstallModal: (() => void) | null;
}) {
  const { codeTheme } = useTheme();
  const { source, onChangeSource, validationError, npmInstall, installing, output, failed } =
    usePackageJson();

  const [open, setOpen] = useState(true);

  function evaluateModEnter() {
    npmInstall();
    return true;
  }

  const hasOutput = output.length > 0;

  return (
    <div>
      <CollapsibleContainer
        open={open}
        onChangeOpen={setOpen}
        title="package.json"
        className={cn({ 'border-run': installing })}
      >
        <div className="pt-1 pb-3 px-3">
          <CodeMirror
            readOnly={readOnly}
            value={source}
            theme={codeTheme}
            extensions={[
              json(),
              Prec.highest(keymap.of([{ key: 'Mod-Enter', run: evaluateModEnter }])),
            ]}
            onChange={onChangeSource}
            basicSetup={{ lineNumbers: false, foldGutter: false }}
          />
        </div>
        {validationError !== null && <Error error={validationError} />}
        {failed && <Error error="Failed to install dependencies" />}
        {hasOutput && <OutputContainer output={output} />}
      </CollapsibleContainer>
      {open && openDepsInstallModal && (
        <div className="flex justify-end items-center gap-2 pt-1">
          <Button variant="secondary" onClick={openDepsInstallModal}>
            Add package
          </Button>
          {installing ? (
            <Button variant="run" size="default-with-icon" disabled>
              <LoaderCircle size={16} className="animate-spin" />
              Installing
            </Button>
          ) : (
            <Button
              size="default-with-icon"
              onClick={() => npmInstall()}
              disabled={installing || validationError !== null}
              className="font-mono"
            >
              <Play size={16} />
              npm install
            </Button>
          )}
        </div>
      )}
    </div>
  );
}

function OutputContainer(props: { output: OutputType[] }) {
  const [show, setShow] = useState(true);
  const [copyIcon, setCopyIcon] = useState<'copy' | 'copied'>('copy');

  const output = props.output
    .map(({ data }) => data)
    .join('')
    .trim();

  function onCopy() {
    navigator.clipboard.writeText(output);
    setCopyIcon('copied');
    setTimeout(() => setCopyIcon('copy'), 1500);
  }

  return (
    <div className="divide-y border-border font-mono text-sm">
      <div className="border-t border-border px-3 py-2 flex items-center justify-between bg-muted text-medium text-tertiary-foreground">
        <h5 className="leading-none">Logs</h5>
        <div className="flex items-center gap-6">
          <button
            className="hover:text-secondary-hover"
            onClick={onCopy}
            disabled={copyIcon === 'copied'}
          >
            {copyIcon === 'copy' ? <CopyIcon size={18} /> : <CheckIcon size={18} />}
          </button>
          <button className="hover:text-secondary-hover" onClick={() => setShow(!show)}>
            {show ? <PanelBottomOpen size={18} /> : <PanelBottomClose size={18} />}
          </button>
        </div>
      </div>
      {show && <div className="p-3 overflow-scroll whitespace-pre text-[13px]">{output}</div>}
    </div>
  );
}

function Error(props: { error: string | null }) {
  return (
    <div className="px-1.5 pb-1.5">
      <div className="bg-error text-error-foreground text-sm font-medium py-2 pl-[10px] pr-3 flex items-start gap-1.5 rounded-sm">
        <div className="shrink-0 mt-0.5">
          <Info size={16} />
        </div>
        <p>{props.error}</p>
      </div>
    </div>
  );
}

================
File: web/src/components/session-menu/secrets-panel.tsx
================
import { useEffect, useState } from 'react';
import { toast } from 'sonner';

import {
  getSecrets,
  createSecret,
  associateSecretWithSession,
  disassociateSecretWithSession,
} from '@/lib/server';
import { Switch } from '@srcbook/components/src/components/ui/switch';
import { SessionMenuPanelContentsProps } from '.';
import { Button } from '@srcbook/components/src/components/ui/button';
import { Input } from '@srcbook/components/src/components/ui/input';
import { isValidSecretName } from '@/lib/utils';

type PropsType = Pick<SessionMenuPanelContentsProps, 'session'>;

export default function SessionMenuPanelSecrets({ session }: PropsType) {
  const [secrets, setSecrets] = useState<{ name: string; checked: boolean }[]>([]);
  const [showForm, setShowForm] = useState(false);

  async function loadSecrets() {
    try {
      const { result: secretsWithAssociations } = await getSecrets();

      const secrets = secretsWithAssociations.map((s) => ({
        name: s.name,
        checked: s.associatedWithSessionIds.includes(session.id),
      }));

      setSecrets(secrets.reverse());
    } catch (err) {
      console.error('Error loading secrets', err);
      return;
    }
  }

  useEffect(() => {
    loadSecrets();

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  function toggleSecret(secretName: string) {
    setSecrets((secrets) =>
      secrets.map((s) => {
        return s.name === secretName ? { ...s, checked: !s.checked } : s;
      }),
    );
  }

  async function onChangeSecretEnabled(secretName: string, enabled: boolean) {
    toggleSecret(secretName); // optimistic update

    try {
      const operation = enabled ? associateSecretWithSession : disassociateSecretWithSession;
      await operation(session.id, secretName);
    } catch (err) {
      toggleSecret(secretName); // undo optimistic update
      console.error(`Error toggling secret ${secretName}`, err);
      toast.error('Error enabling/disabling secret!');
      return;
    }
  }

  async function onSecretAdded(secretName: string) {
    setShowForm(false);
    await loadSecrets();
    toggleSecret(secretName);
    await associateSecretWithSession(session.id, secretName);
  }

  return (
    <>
      <h4 className="text-lg font-semibold leading-tight mb-2">Secrets</h4>

      <div className="flex items-center justify-between">
        {showForm ? (
          <InlineForm onSecretAdded={onSecretAdded} />
        ) : (
          <>
            <p className="text-tertiary-foreground">Enable secrets below</p>
            <Button variant="secondary" onClick={() => setShowForm(true)}>
              Add secret
            </Button>
          </>
        )}
      </div>

      <div className="mt-8">
        {secrets.map((secret) => (
          <label
            key={secret.name}
            htmlFor={`secret-${secret.name}`}
            className="flex items-center justify-between h-8 font-mono cursor-pointer"
          >
            {secret.name}

            <Switch
              id={`secret-${secret.name}`}
              checked={secret.checked}
              onCheckedChange={(checked) => onChangeSecretEnabled(secret.name, checked)}
            />
          </label>
        ))}
      </div>
    </>
  );
}

function InlineForm(props: { onSecretAdded: (name: string) => void }) {
  const [name, setName] = useState('');
  const [value, setValue] = useState('');
  const [error, _setError] = useState<string | null>(null);

  function setError(error: string | null) {
    if (error === null) {
      _setError(null);
      return;
    }

    _setError(error);
    setTimeout(() => _setError(null), 5000);
  }

  function isValidSecret() {
    return isValidSecretName(name) && value.length > 0;
  }

  async function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();

    _setError(null);

    try {
      await createSecret({ name, value });
    } catch (err) {
      console.error('Error creating secret', err);
      setError('Error creating secret');
      return;
    }

    props.onSecretAdded(name);

    setName('');
    setValue('');
  }

  return (
    <div className="flex flex-col gap-1.5">
      <form name="inline-secret-form" className="flex items-center space-x-4" onSubmit={onSubmit}>
        <Input
          required
          autoComplete="off"
          placeholder="SECRET_NAME"
          value={name}
          onChange={(e) => setName(e.currentTarget.value.toUpperCase())}
        />
        <Input
          required
          autoComplete="off"
          value={value}
          onChange={(e) => setValue(e.currentTarget.value)}
          placeholder="secret-value"
        />
        <Button type="submit" variant="secondary" disabled={!isValidSecret()}>
          Add
        </Button>
      </form>
      {error && <p className="text-error text-[13px]">{error}</p>}
    </div>
  );
}

================
File: web/src/components/session-menu/settings-panel.tsx
================
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import type { TitleCellType, TsConfigUpdatedPayloadType } from '@srcbook/shared';
import { X, Info } from 'lucide-react';
import CodeMirror from '@uiw/react-codemirror';
import { json } from '@codemirror/lang-json';

import { cn } from '@/lib/utils';
import { useSettings } from '@/components/use-settings';
import CollapsibleContainer from '@/components/collapsible-container';
import useTheme from '@srcbook/components/src/components/use-theme';
import { SessionChannel } from '@/clients/websocket';
import { useTsconfigJson } from '@/components/use-tsconfig-json';
import { useCells } from '@srcbook/components/src/components/use-cell';

import type { SessionMenuPanelContentsProps } from '.';

type PropsType = Pick<SessionMenuPanelContentsProps, 'readOnly' | 'session' | 'channel'>;

export default function SessionMenuPanelSettings({ readOnly, session, channel }: PropsType) {
  const navigate = useNavigate();
  const { aiEnabled } = useSettings();
  const { cells } = useCells();

  const [showAiNudge, setShowAiNudge] = useState(!aiEnabled);

  const title = cells.find((cell) => cell.type === 'title') as TitleCellType;

  return (
    <>
      <h4 className="text-lg font-semibold leading-tight mb-4">Settings</h4>

      <div className="flex items-center justify-between gap-8 text-sm mb-5">
        <h5 className="font-medium max-w-72 truncate">{title.text}</h5>
        <p className="text-tertiary-foreground">
          {session.language === 'typescript' ? 'TypeScript' : 'JavaScript'}
        </p>
      </div>

      {showAiNudge && (
        <div className="relative flex flex-col px-3 py-3.5 border border-ai-border bg-ai text-ai-foreground rounded-sm text-sm">
          <button
            className="absolute top-2 right-2 cursor-pointer text-sb-purple-60"
            onClick={() => setShowAiNudge(false)}
          >
            <X size={16} />
          </button>
          <h2 className="font-bold">Use AI in notebook</h2>
          <p>
            AI features not enabled. To enable them, set up in{' '}
            <button
              className="font-medium underline cursor-pointer"
              onClick={() => navigate('/settings')}
            >
              {' '}
              global settings
            </button>
            .
          </p>
        </div>
      )}
      {/* TOOD: Add more settings or handle this in a better way */}
      {session.language === 'javascript' && (
        <p className="text-tertiary-foreground text-lg mt-5">No additional settings</p>
      )}
      {session.language === 'typescript' && (
        <div className="text-foreground mt-2 space-y-6">
          <TsconfigJson readOnly={readOnly} channel={channel} />
        </div>
      )}
    </>
  );
}

function TsconfigJson({
  readOnly,
  channel,
}: {
  readOnly?: boolean;
  channel: SessionChannel | null;
}) {
  const { codeTheme } = useTheme();
  const { source, onChangeSource, validationError } = useTsconfigJson();
  const [open, setOpen] = useState(true);
  const [saved, setSaved] = useState(false);

  useEffect(() => {
    if (!channel) return;
    const callback = (_payload: TsConfigUpdatedPayloadType) => {
      setSaved(true);
      setTimeout(() => setSaved(false), 20000);
    };

    channel.on('tsconfig.json:updated', callback);

    return () => channel.off('tsconfig.json:updated', callback);
  }, [channel, setSaved]);

  return (
    <div>
      <CollapsibleContainer
        open={open}
        onChangeOpen={setOpen}
        title="tsconfig.json"
        className={cn({ 'border-error': validationError !== null })}
      >
        <div className="pt-1 pb-3 px-3 relative">
          <CodeMirror
            readOnly={readOnly}
            value={source}
            theme={codeTheme}
            extensions={[json()]}
            onChange={onChangeSource}
            basicSetup={{ lineNumbers: false, foldGutter: false }}
          />
          {saved && <p className="absolute right-1 bottom-1 text-xs text-foreground/80">Saved!</p>}
        </div>
        {validationError !== null && <Error error={validationError} />}
      </CollapsibleContainer>
    </div>
  );
}

function Error(props: { error: string | null }) {
  return (
    <div className="px-1.5 pb-1.5">
      <div className="bg-error text-error-foreground text-sm font-medium py-2 pl-[10px] pr-3 flex items-start gap-1.5 rounded-sm">
        <div className="shrink-0 mt-0.5">
          <Info size={16} />
        </div>
        <p>{props.error}</p>
      </div>
    </div>
  );
}

================
File: web/src/components/session-menu/table-of-contents-panel.tsx
================
import { marked, type Tokens } from 'marked';
import { CodeCellType, MarkdownCellType, TitleCellType } from '@srcbook/shared';
import { Circle } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useCells } from '@srcbook/components/src/components/use-cell';

type PropsType = Record<string, never>;

export default function SessionMenuPanelTableOfContents(_props: PropsType) {
  const { cells: allCells } = useCells();
  const cells = allCells.filter((cell) => {
    return cell.type === 'title' || cell.type === 'markdown' || cell.type === 'code';
  }) as Array<TitleCellType | CodeCellType | MarkdownCellType>;

  return (
    <>
      <h4 className="text-lg font-semibold leading-tight mb-4">Table of contents</h4>

      <div className="max-w-60 text-tertiary-foreground pr-10">
        {cells.map((cell) => {
          const isRunningCell = cell.type === 'code' && cell.status === 'running';
          return (
            <div
              key={cell.id}
              className={cn(
                'flex items-center py-1 pl-3 gap-2 border-l cursor-pointer text-sm',
                isRunningCell
                  ? 'text-run border-l-run font-medium'
                  : 'hover:border-l-foreground hover:text-foreground',
              )}
            >
              {isRunningCell && <Circle size={14} strokeWidth={3} className="text-run" />}
              <button
                className="truncate"
                onClick={() => document.getElementById(`cell-${cell.id}`)?.scrollIntoView()}
              >
                {tocFromCell(cell)}
              </button>
            </div>
          );
        })}
      </div>
    </>
  );
}

const tocFromCell = (cell: TitleCellType | CodeCellType | MarkdownCellType) => {
  if (cell.type === 'title') {
    return cell.text;
  } else if (cell.type === 'code') {
    return cell.filename;
  } else if (cell.type === 'markdown') {
    const tokens = marked.lexer(cell.text);
    const heading = tokens.find((token) => token.type === 'heading') as Tokens.Heading | undefined;
    if (heading) {
      return heading.text;
    }
    const paragraph = tokens.find((token) => token.type === 'paragraph') as
      | Tokens.Paragraph
      | undefined;
    if (paragraph) {
      return paragraph.text;
    }
    return 'Markdown cell';
  }
};

================
File: web/src/components/ai-generate-tips-dialog.tsx
================
import { useState } from 'react';
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components/src/components/ui/dialog';

export default function AiGenerateTipsDialog({ children }: { children: React.ReactNode }) {
  const [open, setOpen] = useState(false);
  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent className="w-[640px] max-w-[640px]">
        <DialogHeader>
          <DialogTitle>Prompt tips</DialogTitle>
          <div className="text-sm">
            <p>Here are a few tips to get the AI to work well for you.</p>

            <ul className="list-disc list-inside py-4 leading-5">
              <li>The AI already knows about all of the contents of this notebook.</li>
              <li>It also knows what cell you're updating.</li>
              <li>You can ask the AI to add or improve comments or JSDoc.</li>
              <li>You can ask the AI to refactor or rewrite the whole thing.</li>
              <li>
                Try asking the AI to refactor, improve or modularize your code, simply by asking for
                it.
              </li>
            </ul>
          </div>
        </DialogHeader>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/chat.tsx
================
import {
  Button,
  cn,
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@srcbook/components';
import Markdown from './apps/markdown.js';
import { diffFiles } from './apps/lib/diff.js';
import TextareaAutosize from 'react-textarea-autosize';
import {
  ArrowUp,
  Minus,
  Paperclip,
  LoaderCircle,
  History,
  PanelTopOpen,
  Loader,
  ViewIcon,
  Undo2Icon,
  Redo2Icon,
  GripHorizontal,
  ThumbsUp,
  ThumbsDown,
  GitMerge,
  EllipsisVertical,
} from 'lucide-react';
import * as React from 'react';
import {
  aiEditApp,
  loadHistory,
  appendToHistory,
  aiGenerationFeedback,
} from '@/clients/http/apps.js';
import { AppType, randomid } from '@srcbook/shared';
import { useFiles } from './apps/use-files';
import { type FileType } from './apps/types';
import type {
  FileDiffType,
  UserMessageType,
  MessageType,
  HistoryType,
  CommandMessageType,
  PlanMessageType,
  DiffMessageType,
} from '@srcbook/shared';
import { DiffStats } from './apps/diff-stats.js';
import { useApp } from './apps/use-app.js';
import { usePackageJson } from './apps/use-package-json.js';
import { AiFeedbackModal } from './apps/AiFeedbackModal';
import { useVersion } from './apps/use-version.js';
import { Link } from 'react-router-dom';

function Chat({
  history,
  loading,
  onClose,
  app,
  fileDiffs,
  diffApplied,
  revertDiff,
  reApplyDiff,
  openDiffModal,
}: {
  history: HistoryType;
  loading: 'description' | 'actions' | null;
  onClose: () => void;
  app: AppType;
  fileDiffs: FileDiffType[];
  diffApplied: boolean;
  revertDiff: () => void;
  reApplyDiff: () => void;
  openDiffModal: () => void;
}) {
  const { npmInstall } = usePackageJson();
  const messagesEndRef = React.useRef<HTMLDivElement>(null);

  // Tried scrolling with flex-direction: column-reverse but it didn't work
  // with generated content, so fallback to using JS
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  React.useEffect(() => {
    scrollToBottom();
  }, [history, loading]);

  return (
    <div className="rounded-lg bg-background w-[440px] border shadow-xl max-h-[75vh]">
      <div className="flex justify-between h-[40px] items-center border-b px-1">
        <span className="text-sm px-2">Chat</span>
        <span className="flex items-center">
          <Button variant="icon" className="h-7 w-7 p-1.5 border-none" onClick={onClose}>
            <Minus size={18} className="text-sb-core-80" />
          </Button>
        </span>
      </div>
      <div className="max-h-[calc(75vh-40px)] p-2 overflow-y-auto">
        <div className="flex flex-col gap-2">
          {/* TODO: each message object needs a unique identifier */}
          {history.map((message: MessageType, index: number) => {
            if (message.type === 'user') {
              return (
                <p className="text-sm bg-inline-code rounded-md p-2 w-fit" key={index}>
                  {message.message}
                </p>
              );
            } else if (message.type === 'command') {
              const packages = message.packages;
              if (!packages) {
                console.error(
                  'The only supported command is `npm install <packages>`. Got:',
                  message.command,
                );
                return;
              }
              return (
                <div className="text-sm space-y-1" key={index}>
                  <p>Install dependencies</p>
                  <div className="flex justify-between items-center gap-1">
                    <p className="font-mono bg-inline-code rounded-md p-2 overflow-x-scroll whitespace-nowrap flex-grow">
                      {`npm install ${packages.join(' ')}`}
                    </p>
                    <Button onClick={() => npmInstall(packages)}>Run</Button>
                  </div>
                </div>
              );
            } else if (message.type === 'plan') {
              return <Markdown key={index} source={message.content.trim()} />;
            } else if (message.type === 'diff') {
              // Calculate the incremental version, i.e. v1 for the first diffbox, v2 for the second, etc.
              // This is separate from the git version number.
              const diffs = history.filter((m) => m.type === 'diff');
              const currentDiffIndex = diffs.findIndex((m) => m === message);
              const incrementalVersion = currentDiffIndex + 1;

              return (
                <DiffBox
                  key={index}
                  files={message.diff}
                  app={app}
                  version={message.version}
                  planId={message.planId}
                  incrementalVersion={incrementalVersion}
                />
              );
            }
          })}

          <div className={cn('flex gap-2 w-full px-2', fileDiffs.length > 0 ? '' : 'hidden')}>
            <Button
              variant="ai-secondary"
              onClick={diffApplied ? revertDiff : reApplyDiff}
              className="flex-1 flex items-center gap-1.5"
            >
              {diffApplied ? <Undo2Icon size={16} /> : <Redo2Icon size={16} />}
              <span>{diffApplied ? 'Undo' : 'Re-apply'}</span>
            </Button>
            <Button
              variant="ai"
              onClick={openDiffModal}
              className="flex-1 flex items-center gap-1.5"
            >
              <ViewIcon size={16} />
              <span>Review changes</span>
            </Button>
          </div>

          {loading !== null && (
            <div className="flex items-center gap-2 text-sm pt-3">
              <Loader size={18} className="animate-spin text-ai-btn" />{' '}
              <p className="text-xs">
                {loading === 'description'
                  ? 'Generating plan...'
                  : 'Applying changes (this can take a while)...'}
              </p>
            </div>
          )}
          {/* empty div for scrolling */}
          <div ref={messagesEndRef} />
        </div>
      </div>
    </div>
  );
}

function Query({
  onSubmit,
  onFocus,
  isLoading,
  isVisible,
  setVisible,
}: {
  onSubmit: (query: string) => Promise<void>;
  onFocus: () => void;
  isLoading: boolean;
  isVisible: boolean;
  setVisible: (visible: boolean) => void;
}) {
  const [query, setQuery] = React.useState('');

  const handleSubmit = () => {
    const value = query.trim();
    if (value) {
      setQuery('');
      onSubmit(value);
    }
  };

  return (
    <div
      className={cn(
        'rounded-lg w-[440px] border p-2 shadow-xl transition-all',
        'bg-background hover:border-ai-ring focus-within:border-ai-ring',
        isLoading && 'hover:border-border',
      )}
    >
      <TextareaAutosize
        disabled={isLoading}
        placeholder="What do you want to change?"
        className="flex w-full rounded-sm bg-transparent px-2 mb-2 text-sm caret-ai-btn placeholder:text-muted-foreground focus-visible:outline-none resize-none"
        maxRows={20}
        onChange={(e) => setQuery(e.target.value)}
        onFocus={onFocus}
        value={query}
        onKeyDown={(e) => {
          if (e.metaKey && !e.shiftKey && e.key === 'Enter') {
            e.preventDefault();
            e.stopPropagation();
            handleSubmit();
          }
        }}
      />
      <span className="flex items-center justify-end gap-1.5 mt-2">
        <Button variant="icon" className="h-7 w-7 p-1.5 border-none text-tertiary-foreground">
          {isVisible ? (
            <PanelTopOpen size={18} onClick={() => setVisible(false)} />
          ) : (
            <History size={18} onClick={() => setVisible(true)} />
          )}
        </Button>
        <TooltipProvider delayDuration={200}>
          <Tooltip>
            <TooltipTrigger asChild>
              <Button variant="icon" className="h-7 w-7 p-1.5 border-none text-tertiary-foreground">
                <Paperclip size={18} />
              </Button>
            </TooltipTrigger>
            <TooltipContent>Coming soon!</TooltipContent>
          </Tooltip>
        </TooltipProvider>
        <Button
          variant="ai"
          className={'h-7 w-7 p-1.5 foxus:outline-none border-none'}
          onClick={handleSubmit}
          disabled={!query}
        >
          {isLoading ? <LoaderCircle size={18} className="animate-spin" /> : <ArrowUp size={18} />}
        </Button>
      </span>
    </div>
  );
}

function DiffBox({
  files,
  app,
  incrementalVersion,
  version,
  planId,
}: {
  files: FileDiffType[];
  app: AppType;
  incrementalVersion: number;
  version: string;
  planId: string;
}) {
  const [showFeedbackToast, setShowFeedbackToast] = React.useState(false);
  const [feedbackGiven, _setFeedbackGiven] = React.useState<null | 'positive' | 'negative'>(null);
  const [isFeedbackModalOpen, setIsFeedbackModalOpen] = React.useState(false);

  const { checkout, currentVersion } = useVersion();

  const setFeedbackGiven = (feedback: 'positive' | 'negative') => {
    setShowFeedbackToast(true);
    _setFeedbackGiven(feedback);
    setTimeout(() => setShowFeedbackToast(false), 2500);
  };

  const handleFeedbackSubmit = (feedbackText: string) => {
    setFeedbackGiven('negative');
    aiGenerationFeedback(app.id, { planId, feedback: { type: 'negative', text: feedbackText } });
  };

  return (
    <>
      <div
        className={cn(
          'px-2 mx-2 pb-2 rounded border overflow-y-auto bg-ai border-ai-border text-ai-foreground transition-all',
          currentVersion?.sha === version ? 'border-ai-foreground' : 'border-ai-border',
        )}
      >
        <div className="flex flex-col justify-between min-h-full">
          <div className="flex justify-between items-center">
            <div className="flex gap-2 items-center text-sm h-10">
              <span className="font-medium">{app.name}</span>
              <span className="font-mono">V{incrementalVersion}</span>
            </div>
            {/* We don't need this guard if we assume only new apps */}
            {version && (
              <div className="flex items-center gap-2">
                <div className="flex items-center gap-1">
                  <GitMerge size={16} />
                  <span className="font-mono text-sm">
                    #{version ? version.slice(0, 7) : 'unknown version'}
                  </span>
                </div>

                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="icon" className="h-8 w-8 p-0">
                      <EllipsisVertical size={16} />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuItem onClick={() => checkout(version)}>
                      Revert to this version
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={() => alert('Coming soon!')}>
                      Fork this version
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>
            )}
          </div>
          <div>
            {files.map((file) => (
              <div key={file.path}>
                <div className="flex justify-between items-center text-sm font-mono h-8">
                  <Link to={`/apps/${app.id}/files/${encodeURIComponent(file.path)}`}>
                    <p className="font-mono hover:underline">{file.path}</p>
                  </Link>
                  <DiffStats additions={file.additions} deletions={file.deletions} />
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>
      <div className="flex px-2 items-center gap-2 my-2">
        <Button
          variant="icon"
          className={cn(
            'h-7 w-7 p-1.5 border-none',
            feedbackGiven === 'positive' ? 'text-secondary-foreground' : 'text-tertiary-foreground',
          )}
          aria-label="Upvote"
          onClick={() => {
            setFeedbackGiven('positive');
            aiGenerationFeedback(app.id, { planId, feedback: { type: 'positive' } });
          }}
        >
          <ThumbsUp size={18} />
        </Button>
        <Button
          variant="icon"
          className={cn(
            'h-7 w-7 p-1.5 border-none',
            feedbackGiven === 'negative' ? 'text-secondary-foreground' : 'text-tertiary-foreground',
          )}
          aria-label="Downvote"
          onClick={() => setIsFeedbackModalOpen(true)}
        >
          <ThumbsDown size={18} />
        </Button>
        {showFeedbackToast && (
          <p className="text-sm text-tertiary-foreground">Thanks for the feedback!</p>
        )}
      </div>
      <AiFeedbackModal
        isOpen={isFeedbackModalOpen}
        onClose={() => setIsFeedbackModalOpen(false)}
        onSubmit={handleFeedbackSubmit}
      />
    </>
  );
}

export function DraggableChatPanel(props: { children: React.ReactNode }): React.JSX.Element {
  const [isDragging, setIsDragging] = React.useState(false);
  const [position, setPosition] = React.useState({ x: 20, y: 20 });
  const chatRef = React.useRef<HTMLDivElement>(null);
  const dragStartPos = React.useRef({ x: 0, y: 0 });
  const [showOverlay, setShowOverlay] = React.useState(false);

  const handleMouseDown = (e: React.MouseEvent) => {
    if (e.target instanceof Element && e.target.closest('.drag-handle')) {
      setIsDragging(true);
      setShowOverlay(true);
      dragStartPos.current = {
        x: e.clientX + position.x,
        y: e.clientY + position.y,
      };
    }
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (isDragging && chatRef.current) {
      const newX = dragStartPos.current.x - e.clientX;
      const newY = dragStartPos.current.y - e.clientY;

      // Ensure the chat panel stays within the viewport
      const maxX = window.innerWidth - chatRef.current.offsetWidth;
      const maxY = window.innerHeight - chatRef.current.offsetHeight;

      setPosition({
        x: Math.max(0, Math.min(newX, maxX)),
        y: Math.max(0, Math.min(newY, maxY)),
      });
    }
  };

  const handleMouseUp = () => {
    setIsDragging(false);
    setShowOverlay(false);
  };

  React.useEffect(() => {
    if (showOverlay) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    } else {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    }
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isDragging, showOverlay]);

  // Note: we show a full screen overlay otherwise the mouse events
  // don't fire correctly when hovering over the iframe.

  return (
    <>
      {showOverlay && (
        <div
          style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
          }}
        />
      )}
      {/* eslint-disable-next-line */}
      <div
        ref={chatRef}
        className="fixed"
        style={{
          bottom: `${position.y}px`,
          right: `${position.x}px`,
          userSelect: `${isDragging ? 'none' : 'auto'}`,
        }}
        onMouseDown={handleMouseDown}
      >
        <div className="flex items-end gap-1">
          <GripHorizontal
            className={cn(
              'text-gray-400 drag-handle bg-background/10 rounded-sm',
              isDragging ? 'cursor-grabbing' : 'cursor-grab',
            )}
          />
          {props.children}
        </div>
      </div>
    </>
  );
}

type PropsType = {
  triggerDiffModal: (props: { files: FileDiffType[]; onUndoAll: () => void } | null) => void;
};

export function ChatPanel(props: PropsType): React.JSX.Element {
  const { app } = useApp();

  const [history, setHistory] = React.useState<HistoryType>([]);
  const [fileDiffs, setFileDiffs] = React.useState<FileDiffType[]>([]);
  const [visible, setVisible] = React.useState(false);
  const [loading, setLoading] = React.useState<'description' | 'actions' | null>(null);
  const [diffApplied, setDiffApplied] = React.useState(false);
  const { createFile, deleteFile } = useFiles();
  const { createVersion } = useVersion();

  // Initialize history from the DB
  React.useEffect(() => {
    loadHistory(app.id)
      .then(({ data }) => setHistory(data))
      .catch((error) => {
        console.error('Error fetching chat history:', error);
      });
  }, [app]);

  const handleSubmit = async (query: string) => {
    const planId = randomid();
    setLoading('description');
    setFileDiffs([]);
    const userMessage = { type: 'user', message: query, planId } as UserMessageType;
    setHistory((prevHistory) => [...prevHistory, userMessage]);
    appendToHistory(app.id, userMessage);
    setVisible(true);

    const iterable = await aiEditApp(app.id, query, planId);

    const fileUpdates: FileType[] = [];

    for await (const message of iterable) {
      if (message.type === 'description') {
        const planMessage = {
          type: 'plan',
          content: message.data.content,
          planId,
        } as PlanMessageType;
        setHistory((prevHistory) => [...prevHistory, planMessage]);
        appendToHistory(app.id, planMessage);
        setLoading('actions');
      } else if (message.type === 'action') {
        if (message.data.type === 'command') {
          const commandMessage = {
            type: 'command',
            command: message.data.command,
            packages: message.data.packages,
            description: message.data.description,
            planId,
          } as CommandMessageType;
          setHistory((prevHistory) => [...prevHistory, commandMessage]);
          appendToHistory(app.id, commandMessage);
        } else if (message.data.type === 'file') {
          fileUpdates.push(message.data);
        }
      } else {
        console.error('Unknown message type:', message);
      }
    }

    if (fileUpdates.length > 0) {
      // Write the changes
      for (const update of fileUpdates) {
        createFile(update.dirname, update.basename, update.modified);
      }

      // Create a new version
      const version = await createVersion(`Changes for planId: ${planId}`);

      const fileDiffs: FileDiffType[] = fileUpdates.map((file: FileType) => {
        const { additions, deletions } = diffFiles(file.original ?? '', file.modified);
        return {
          modified: file.modified,
          original: file.original,
          basename: file.basename,
          dirname: file.dirname,
          path: file.path,
          additions,
          deletions,
          type: file.original ? 'edit' : ('create' as 'edit' | 'create'),
        };
      });

      const diffMessage = { type: 'diff', diff: fileDiffs, planId, version } as DiffMessageType;
      setHistory((prevHistory) => [...prevHistory, diffMessage]);
      appendToHistory(app.id, diffMessage);

      setFileDiffs(fileDiffs);
      setDiffApplied(true);
    }
    setLoading(null);
  };

  // TODO: this closes over state that might be stale.
  // This probably needs to use a ref for file diffs to
  // ensure the most recent state is always referenced.
  const revertDiff = () => {
    for (const file of fileDiffs) {
      if (file.original) {
        createFile(file.dirname, file.basename, file.original);
      } else {
        // TODO: this needs some testing, this shows the idea only
        deleteFile({
          type: 'file',
          path: file.path,
          dirname: file.dirname,
          basename: file.basename,
        });
      }
    }
    setDiffApplied(false);
  };

  const reApplyDiff = () => {
    for (const file of fileDiffs) {
      createFile(file.dirname, file.basename, file.modified);
    }
    setDiffApplied(true);
  };

  const handleClose = () => {
    setVisible(false);
  };

  const handleFocus = () => {
    if (history.length > 0) {
      setVisible(true);
    }
  };

  function openDiffModal() {
    props.triggerDiffModal({
      files: fileDiffs,
      onUndoAll: () => {
        revertDiff();
        props.triggerDiffModal(null);
      },
    });
  }

  return (
    <DraggableChatPanel>
      <div className="flex flex-col gap-2">
        {visible && (
          <Chat
            history={history}
            loading={loading}
            onClose={handleClose}
            app={app}
            diffApplied={diffApplied}
            reApplyDiff={reApplyDiff}
            revertDiff={revertDiff}
            fileDiffs={fileDiffs}
            openDiffModal={openDiffModal}
          />
        )}
        <Query
          onSubmit={handleSubmit}
          isLoading={loading !== null}
          onFocus={handleFocus}
          isVisible={visible}
          setVisible={setVisible}
        />
      </div>
    </DraggableChatPanel>
  );
}

================
File: web/src/components/collapsible-container.tsx
================
import { ChevronRight } from 'lucide-react';
import { cn } from '@/lib/utils';
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from '@srcbook/components/src/components/ui/collapsible';

export default function CollapsibleContainer(props: {
  open: boolean;
  onChangeOpen: (value: boolean) => void;
  title: string;
  className?: string | null;
  children: React.ReactNode;
}) {
  const { open, onChangeOpen, title, children } = props;

  return (
    <Collapsible open={open} onOpenChange={onChangeOpen}>
      <div className={cn('w-full border rounded-sm', props.className)}>
        <CollapsibleTrigger className="block w-full">
          <div className="p-3 flex items-center justify-between">
            <h5 className="font-medium leading-none">{title}</h5>
            <ChevronRight
              className={cn('w-4 h-4 transition-transform text-tertiary-foreground', {
                'transform rotate-90': open,
              })}
            />
          </div>
        </CollapsibleTrigger>
        <CollapsibleContent>{children}</CollapsibleContent>
      </div>
    </Collapsible>
  );
}

================
File: web/src/components/delete-app-dialog.tsx
================
import { deleteApp } from '@/clients/http/apps';
import { useState } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components/src/components/ui/dialog';
import { Button } from '@srcbook/components/src/components/ui/button';
import { AppType } from '@srcbook/shared';

type PropsType = {
  app: AppType;
  onClose: () => void;
  onDeleted: () => void;
};

export default function DeleteAppModal({ app, onClose, onDeleted }: PropsType) {
  const [error, setError] = useState<string | null>(null);

  async function onDelete() {
    try {
      await deleteApp(app.id);
      onDeleted();
    } catch (err) {
      console.error(err);
      setError('Something went wrong. Please try again.');
      setTimeout(() => setError(null), 3000);
    }
  }

  return (
    <Dialog
      open={true}
      onOpenChange={(open) => {
        if (open === false) {
          onClose();
        }
      }}
    >
      <DialogContent className="max-w-sm">
        <DialogHeader>
          <DialogTitle>Delete "{app.name}"?</DialogTitle>
          <DialogDescription asChild>
            <div>
              <p className="text-foreground">Deleting an App cannot be undone.</p>
            </div>
          </DialogDescription>
        </DialogHeader>
        {error && <p className="text-destructive">{error}</p>}
        <div className="flex justify-end space-x-2">
          <Button variant="secondary" onClick={onClose}>
            Cancel
          </Button>
          <Button variant="destructive" onClick={onDelete}>
            Delete
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/delete-cell-dialog.tsx
================
import { useState } from 'react';
import { Button } from '@srcbook/components/src/components/ui/button';
import {
  Dialog,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@srcbook/components/src/components/ui/dialog';

export default function DeleteCellWithConfirmationModal({
  onDeleteCell,
  children,
}: {
  onDeleteCell: () => void;
  children: React.ReactNode;
}) {
  const [open, setOpen] = useState(false);
  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>{children}</DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Delete this cell</DialogTitle>
          <DialogDescription>
            We currently don't support history, are you sure you want to delete it?
          </DialogDescription>
          <div className="flex w-full justify-end items-center gap-2 pt-4 bg-background">
            <Button
              variant="secondary"
              onClick={() => {
                setOpen(false);
              }}
            >
              Cancel
            </Button>
            <Button variant="destructive" onClick={() => onDeleteCell()}>
              Delete
            </Button>
          </div>
        </DialogHeader>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/delete-srcbook-dialog.tsx
================
import { deleteSrcbook } from '@/lib/server';
import { useNavigate } from 'react-router-dom';
import { getTitleForSession } from '@/lib/utils';
import { useState } from 'react';
import type { SessionType } from '../types';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components/src/components/ui/dialog';
import { Button } from '@srcbook/components/src/components/ui/button';

export default function DeleteSrcbookModal({
  open,
  onOpenChange,
  session,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  session: SessionType | undefined;
}) {
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();
  if (!session) return;

  const onConfirmDelete = async () => {
    deleteSrcbook({ id: session.id })
      .then(() => {
        onOpenChange(false);
        navigate('/', { replace: true });
      })
      .catch((err: Error) => {
        console.error(err);
        setError('Something went wrong. Please try again.');
        setTimeout(() => setError(null), 3000);
      });
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-sm">
        <DialogHeader>
          <DialogTitle>Delete "{getTitleForSession(session)}"?</DialogTitle>
          <DialogDescription asChild>
            <div>
              <p className="text-foreground">Deleting a Notebook cannot be undone.</p>
            </div>
          </DialogDescription>
        </DialogHeader>
        {error && <p className="text-destructive">{error}</p>}
        <div className="flex justify-end space-x-2">
          <Button variant="secondary" onClick={() => onOpenChange(false)}>
            Cancel
          </Button>
          <Button variant="destructive" onClick={onConfirmDelete}>
            Delete
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/drag-and-drop-srcmd-modal.tsx
================
import { useCallback, useState } from 'react';
import { useDropzone } from 'react-dropzone';
import { useNavigate } from 'react-router-dom';
import { Upload } from 'lucide-react';
import { CardContainer } from './srcbook-cards';
import { createSession, importSrcbook } from '@/lib/server';

function Modal(props: { open: boolean }) {
  if (!props.open) {
    return null;
  }

  const state = props.open ? 'open' : 'closed';

  return (
    <>
      <div
        aria-hidden="true"
        data-state={state}
        className="fixed inset-0 z-50 bg-sb-core-130/90 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0"
      ></div>
      <CardContainer
        role="dialog"
        data-state={state}
        className="focus-within:outline-none fixed w-full max-w-sm h-48 p-6 left-[50%] top-[50%] z-50 grid gap-4 bg-background border rounded-md shadow-xl translate-x-[-50%] translate-y-[-50%] duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%]"
      >
        <div className="flex flex-col h-full gap-3">
          <div className="flex-1 flex items-center justify-center">
            <div className="w-14 h-14 flex items-center justify-center bg-primary text-primary-foreground rounded-full">
              <Upload size={18} />
            </div>
          </div>
          <div className="flex-1 flex flex-col items-center justify-center gap-2">
            <strong className="text-lg font-semibold leading-tight">Open Notebook</strong>
            <p className="text-tertiary-foreground">
              Drop <code className="code">.src.md</code> file to open
            </p>
          </div>
        </div>
      </CardContainer>
    </>
  );
}

export function DragAndDropSrcmdModal(props: { children: React.ReactNode }) {
  const [showDndModal, setShowDndModal] = useState(false);

  const navigate = useNavigate();

  const onDrop = useCallback(
    async (files: File[]) => {
      // TODO: Error handling
      if (files.length !== 1) {
        return;
      }

      const file = files[0];

      // TODO: Error handling
      if (!file?.name.endsWith('.src.md')) {
        return;
      }

      const text = await file.text();

      // TODO: Error handling
      const { result } = await importSrcbook({ text });
      const { result: session } = await createSession({ path: result.dir });

      setShowDndModal(false);

      return navigate(`/srcbooks/${session.id}`);
    },
    [navigate],
  );

  const { getRootProps } = useDropzone({
    onDrop,
    noClick: true,
    multiple: false,
    maxFiles: 1,
    onDragEnter: () => setShowDndModal(true),
    onDragLeave: () => setShowDndModal(false),
  });

  return (
    <div {...getRootProps()}>
      {props.children}
      <Modal open={showDndModal} />
    </div>
  );
}

================
File: web/src/components/feedback-dialog.tsx
================
import { useState } from 'react';
import { sendFeedback } from '@/lib/server';
import { toast } from 'sonner';
import { Button } from '@srcbook/components/src/components/ui/button';
import { Input } from '@srcbook/components/src/components/ui/input';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components/src/components/ui/dialog';
import { Textarea } from '@srcbook/components/src/components/ui/textarea';

export default function FeedbackDialog({
  open,
  onOpenChange,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}) {
  const [feedback, setFeedback] = useState('');
  const [email, setEmail] = useState('');

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-xl">
        <DialogHeader>
          <DialogTitle>Share Feedback</DialogTitle>
          <DialogDescription asChild>
            <div className="pt-4 flex flex-col gap-2">
              <p>
                We're always looking to improve Srcbook and your feedback is invaluable.
                <br />
                You can open a public{' '}
                <a
                  href="https://github.com/srcbookdev/srcbook/issues/new"
                  className="underline font-medium"
                >
                  GitHub issue
                </a>{' '}
                or use the form below.
              </p>
              <Textarea
                placeholder="Share anonymous feedback"
                value={feedback}
                onChange={(e) => setFeedback(e.target.value)}
              />
              <Input
                type="text"
                value={email}
                placeholder="Email (optional)"
                onChange={(e) => setEmail(e.target.value)}
              />
              <Button
                disabled={!feedback}
                onClick={() => {
                  sendFeedback({ feedback, email });
                  setFeedback('');
                  setEmail('');
                  toast.info('Thanks for the feedback!');
                  onOpenChange(false);
                }}
                className="self-end"
              >
                Send
              </Button>
            </div>
          </DialogDescription>
        </DialogHeader>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/generate-srcbook-modal.tsx
================
import { useState } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { Link } from 'react-router-dom';
import { cn } from '@/lib/utils';
import { Button } from '@srcbook/components/src/components/ui/button';
import { Textarea } from '@srcbook/components/src/components/ui/textarea';
import { Sparkles, Loader2 } from 'lucide-react';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components/src/components/ui/dialog';
import { generateSrcbook } from '@/lib/server';
import { useSettings } from '@/components/use-settings';

const EXAMPLES = [
  'Cover the basics of validating data in TypeScript using Zod, including how to infer types from schemas',
  'Create an AI agent in Node.js that browses the web and answers questions using langchain',
  'Implement breadth-first-search and depth-first-search using TypeScript',
];

export default function GenerateSrcbookModal({
  open,
  setOpen,
  openSrcbook,
}: {
  open: boolean;
  setOpen: (open: boolean) => void;
  openSrcbook: (path: string) => void;
}) {
  const [query, setQuery] = useState('');
  const [status, setStatus] = useState<'idle' | 'loading'>('idle');
  const [error, setError] = useState<'generic' | 'api_key' | null>(null);
  const { aiEnabled } = useSettings();

  useHotkeys(
    'mod+enter',
    () => {
      if (!open) return;
      generate();
    },
    { enableOnFormTags: ['textarea'] },
  );

  const generate = async () => {
    if (!query) {
      return;
    }

    setError(null);
    setStatus('loading');

    // Some errors will be handled by the API handler and return with
    // {error: true, result: {message: string}}}
    // Some example errors that we expect are:
    //  - the generated text from the LLM did not parse correctly into Srcbook format
    //  - the API key is invalid
    //  - rate limits or out-of-credits issues
    const { result, error } = await generateSrcbook({ query });

    if (error) {
      console.error(result);
      setStatus('idle');
      if (/Incorrect API key provided/.test(result)) {
        setError('api_key');
      } else {
        setError('generic');
      }
    } else {
      openSrcbook(result.dir);
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogContent className={cn('flex flex-col transition-height w-[800px]')}>
        <DialogHeader>
          <DialogTitle>Generate with AI</DialogTitle>
        </DialogHeader>
        <div className="flex flex-col gap-3">
          {!aiEnabled && <APIKeyWarning />}
          <Textarea
            placeholder="Write a prompt to create a Notebook..."
            className="focus-visible:ring-2"
            rows={4}
            value={query}
            disabled={!aiEnabled || status === 'loading'}
            onChange={(e) => setQuery(e.target.value)}
          />
          <Button
            className="self-end flex items-center gap-2"
            disabled={!query || status === 'loading'}
            onClick={generate}
          >
            {status === 'loading' ? (
              <>
                <Loader2 size={20} className="animate-spin" /> <p>Generating</p>
              </>
            ) : (
              <p>Generate</p>
            )}
          </Button>
          {error !== null && <ErrorMessage type={error} onRetry={generate} />}
          <div className="border-t">
            <p className="py-3 font-medium">Examples</p>
            <div className="flex flex-col gap-2">
              {EXAMPLES.map((example) => (
                <button
                  onClick={() => setQuery(example)}
                  className="border border-border flex items-center justify-center gap-3 cursor-pointer hover:bg-muted rounded px-1.5 py-2"
                  key={JSON.stringify(example)}
                >
                  <div className="flex items-center relative justify-center p-2.5 w-8 h-8">
                    <Sparkles size={18} className="absolute" />
                  </div>
                  <p className="text-sm text-left">{example}</p>
                </button>
              ))}
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

function APIKeyWarning() {
  return (
    <div className="flex items-center justify-between bg-sb-yellow-20 text-sb-yellow-80 rounded-sm text-sm font-medium px-3 py-2">
      <p>AI provider not configured.</p>
      <Link to="/settings" className="underline">
        Settings
      </Link>
    </div>
  );
}

function ErrorMessage({ type, onRetry }: { type: 'api_key' | 'generic'; onRetry: () => void }) {
  return (
    <div className="bg-error text-error-foreground rounded-sm text-sm font-medium px-3 py-2">
      {type === 'api_key' ? <APIKeyError /> : <GenericError onRetry={onRetry} />}
    </div>
  );
}

function APIKeyError() {
  return (
    <div className="flex items-center justify-between">
      <p>Invalid API key</p>
      <Link to="/settings" className="underline">
        Settings
      </Link>
    </div>
  );
}

function GenericError(props: { onRetry: () => void }) {
  return (
    <div className="flex items-center justify-between">
      <p>Something went wrong</p>
      <button onClick={props.onRetry} className="underline">
        Try again
      </button>
    </div>
  );
}

================
File: web/src/components/import-export-srcbook-modal.tsx
================
import { useNavigate } from 'react-router-dom';
import {
  FileCodeIcon,
  FileDownIcon,
  FileUpIcon,
  GlobeIcon,
  Loader2Icon,
  NotebookIcon,
} from 'lucide-react';
import { toast } from 'sonner';
import { createSession, exportSrcmdText, importSrcbook } from '@/lib/server';
import { getTitleForSession } from '@/lib/utils';
import { SessionType } from '@/types';
import { useEffect, useMemo, useRef, useState } from 'react';
import {
  Tabs,
  TabsList,
  TabsTrigger,
  TabsContent,
} from '@srcbook/components/src/components/ui/underline-flat-tabs';
import { showSaveFilePicker } from '@/lib/file-system-access';
import { Input } from '@srcbook/components/src/components/ui/input';
import { Textarea } from '@srcbook/components/src/components/ui/textarea';
import { Button } from '@srcbook/components/src/components/ui/button';
import SrcMdUploadDropZone from '@/components/srcmd-upload-drop-zone';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components/src/components/ui/dialog';

export function ImportSrcbookModal({
  open,
  onOpenChange,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}) {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [activeTab, setActiveTab] = useState<'file' | 'url' | 'clipboard'>('file');

  // "url" tab
  const [url, setUrl] = useState('');
  const urlInputRef = useRef<HTMLInputElement | null>(null);

  // "clipboard" tab:
  const [clipboard, setClipboard] = useState('');
  const clipboardTextareaRef = useRef<HTMLTextAreaElement | null>(null);

  // When changing tabs, focus the inputs on each tab
  useEffect(() => {
    setTimeout(() => {
      switch (activeTab) {
        case 'url':
          urlInputRef.current?.focus();
          break;
        case 'clipboard':
          clipboardTextareaRef.current?.focus();
          break;
      }
    }, 0);
  }, [activeTab]);

  // When hiding the modal, reset all controls
  useEffect(() => {
    if (!open) {
      return;
    }

    setActiveTab('file');
    setUrl('');
    setClipboard('');
  }, [open]);

  const navigate = useNavigate();

  async function onCreateSrcbookFromFilesystem(file: File) {
    setError(null);
    setLoading(true);

    const text = await file.text();
    const { error: importError, result: importResult } = await importSrcbook({ text });

    if (importError) {
      setLoading(false);
      setError('There was an error while importing this srcbook.');
      return;
    }

    const { error, result } = await createSession({ path: importResult.dir });

    if (error) {
      setLoading(false);
      setError('There was an error while importing this srcbook.');
      return;
    }

    setActiveTab('file');
    setLoading(false);
    onOpenChange(false);
    return navigate(`/srcbooks/${result.id}`);
  }

  async function onCreateSrcbookFromUrl(url: string) {
    setError(null);
    setLoading(true);

    const { error: importError, result: importResult } = await importSrcbook({ url });

    if (importError) {
      setLoading(false);
      setError('There was an error while importing this srcbook.');
      return;
    }

    const { error, result } = await createSession({ path: importResult.dir });

    if (error) {
      setLoading(false);
      setError('There was an error while importing this srcbook.');
      return;
    }

    setActiveTab('file');
    setLoading(false);
    onOpenChange(false);
    return navigate(`/srcbooks/${result.id}`);
  }

  async function onCreateSrcbookFromClipboard(clipboard: string) {
    setError(null);
    setLoading(true);

    const { error: importError, result: importResult } = await importSrcbook({ text: clipboard });

    if (importError) {
      setLoading(false);
      setError('There was an error while importing this srcbook.');
      return;
    }

    const { error, result } = await createSession({ path: importResult.dir });

    if (error) {
      setLoading(false);
      setError('There was an error while importing this srcbook.');
      return;
    }

    setActiveTab('file');
    setLoading(false);
    onOpenChange(false);
    return navigate(`/srcbooks/${result.id}`);
  }

  function onChangeTab(tab: string) {
    setActiveTab(tab as 'file' | 'url' | 'clipboard');

    // Reset state on tab change
    setError(null);
    setUrl('');
    setClipboard('');
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl">
        <DialogHeader>
          <DialogTitle>Open Notebook</DialogTitle>
          <DialogDescription asChild>
            <p>Use one of the options below to open a Notebook.</p>
          </DialogDescription>
        </DialogHeader>

        <Tabs value={activeTab} onValueChange={onChangeTab}>
          <div className="border-b mb-4">
            <TabsList>
              <TabsTrigger disabled={loading} value="file">
                <div className="flex items-center gap-2">
                  <FileUpIcon size={18} />
                  Upload file
                </div>
              </TabsTrigger>
              <TabsTrigger disabled={loading} value="url">
                <div className="flex items-center gap-2">
                  <GlobeIcon size={18} />
                  Import URL
                </div>
              </TabsTrigger>
              <TabsTrigger disabled={loading} value="clipboard">
                <div className="flex items-center gap-2">
                  <FileCodeIcon size={18} />
                  Paste source
                </div>
              </TabsTrigger>
            </TabsList>
          </div>

          <TabsContent className="mt-0" value="file">
            <SrcMdUploadDropZone onDrop={onCreateSrcbookFromFilesystem} className="h-[160px]" />
          </TabsContent>
          <TabsContent className="mt-0" value="url">
            <div className="flex gap-2 w-full px-2">
              <Input
                ref={urlInputRef}
                value={url}
                onChange={(event) => setUrl(event.target.value)}
                placeholder="https://hub.srcbook.com/srcbooks/srcbook-to-import.src.md"
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    onCreateSrcbookFromUrl(url);
                  }
                }}
              />
              <Button
                type="button"
                onClick={() => onCreateSrcbookFromUrl(url)}
                disabled={url.length === 0 || loading}
              >
                {loading ? (
                  <div className="flex items-center gap-2">
                    <Loader2Icon size={18} className="animate-spin" />
                    Loading...
                  </div>
                ) : (
                  'Create'
                )}
              </Button>
            </div>
          </TabsContent>
          <TabsContent className="mt-0" value="clipboard">
            <div className="flex flex-col gap-4 h-[160px]">
              <Textarea
                ref={clipboardTextareaRef}
                value={clipboard}
                onChange={(event) => setClipboard(event.target.value)}
                placeholder="Paste clipboard here"
                className="min-h-[112px] resize-vertical"
              />
              <div className="flex justify-end">
                <Button
                  type="button"
                  onClick={() => onCreateSrcbookFromClipboard(clipboard)}
                  disabled={clipboard.length === 0 || loading}
                >
                  {loading ? (
                    <div className="flex items-center gap-2">
                      <Loader2Icon size={18} className="animate-spin" />
                      Loading...
                    </div>
                  ) : (
                    'Create'
                  )}
                </Button>
              </div>
            </div>
          </TabsContent>
        </Tabs>
        {error && <p className="text-sm text-destructive">{error}</p>}
      </DialogContent>
    </Dialog>
  );
}

export function ExportSrcbookModal({
  open,
  onOpenChange,
  session,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  session: SessionType;
}) {
  const [activeTab, setActiveTab] = useState<'file' | 'text'>('file');

  const clipboardTextareaRef = useRef<HTMLTextAreaElement | null>(null);

  const [srcbookText, setSrcbookText] = useState<
    | { status: 'idle' }
    | { status: 'loading' }
    | { status: 'complete'; text: string }
    | { status: 'error' }
  >({ status: 'idle' });
  useEffect(() => {
    if (!open) {
      return;
    }

    const run = async () => {
      setSrcbookText({ status: 'loading' });

      let text;
      try {
        text = await exportSrcmdText(session.id);
      } catch (error) {
        console.error('Error export srcbook as text:', error);
        setSrcbookText({ status: 'error' });
        return;
      }

      setSrcbookText({ status: 'complete', text });
    };
    run();
  }, [open, session.id]);

  // When changing tabs, focus the inputs on each tab
  useEffect(() => {
    setTimeout(() => {
      switch (activeTab) {
        case 'text':
          clipboardTextareaRef.current?.focus();
          clipboardTextareaRef.current?.select();
          break;
      }
    }, 0);
  }, [activeTab]);

  // When hiding the modal, reset all controls
  useEffect(() => {
    if (!open) {
      return;
    }

    setActiveTab('file');
  }, [open]);

  const downloadFileName = useMemo(() => {
    const fileNameWithoutExtension = getTitleForSession(session)
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');

    return `${fileNameWithoutExtension}.src.md`;
  }, [session]);

  async function onDownloadSrcbook() {
    if (srcbookText.status !== 'complete') {
      return;
    }

    // If the file system access api is available (as of september 2024, this is only chrome), then
    // use this rather than just downloading a file.
    if (typeof showSaveFilePicker !== 'undefined') {
      let fileHandle;
      try {
        fileHandle = await showSaveFilePicker({
          id: 'srcbookExportFile',
          suggestedName: downloadFileName,
        });
      } catch (err) {
        if ((err as Error).name === 'AbortError') {
          // The user quit out of the save picker without selecting a location
          return;
        }

        console.error('Error getting file handle:', err);
        return;
      }

      const writable = await fileHandle.createWritable();
      await writable.write(srcbookText.text);
      await writable.close();

      onOpenChange(false);

      toast.success(`Saved ${fileHandle.name}.`, { duration: 2000 });

      return;
    }

    const blob = new Blob([srcbookText.text]);

    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', downloadFileName);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    toast.success(`Saved ${downloadFileName}.`, { duration: 2000 });
  }

  function onCopySrcbookToClipboard() {
    if (srcbookText.status !== 'complete') {
      return;
    }

    onOpenChange(false);
    navigator.clipboard.writeText(srcbookText.text);
    toast.success('Copied to clipboard.', { duration: 2000 });
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl">
        <DialogHeader>
          <DialogTitle>Export Srcbook</DialogTitle>
          <DialogDescription asChild>
            <p>
              Export this Notebook to a <code className="code">.src.md</code> file which is
              shareable and can be imported into any Srcbook application.
            </p>
          </DialogDescription>
        </DialogHeader>

        <Tabs value={activeTab} onValueChange={(tab) => setActiveTab(tab as 'file' | 'text')}>
          <div className="border-b mb-4">
            <TabsList>
              <TabsTrigger value="file">
                <div className="flex items-center gap-2">
                  <FileDownIcon size={18} />
                  Download file
                </div>
              </TabsTrigger>
              <TabsTrigger value="text">
                <div className="flex items-center gap-2">
                  <FileCodeIcon size={18} />
                  Copy source
                </div>
              </TabsTrigger>
            </TabsList>
          </div>

          <TabsContent className="mt-0" value="file">
            <div className="flex flex-col gap-4 w-full items-center justify-center h-[160px] border border-dashed rounded-md cursor-default">
              <div className="flex flex-col items-center gap-2 text-tertiary-foreground">
                <NotebookIcon size={24} />
                <code className="text-xs">{downloadFileName}</code>
              </div>
              <Button onClick={onDownloadSrcbook}>
                {typeof showSaveFilePicker !== 'undefined' ? 'Save File' : 'Download File'}
              </Button>
            </div>
          </TabsContent>
          <TabsContent className="mt-0" value="text">
            <div className="flex flex-col gap-4">
              <Textarea
                ref={clipboardTextareaRef}
                value={srcbookText.status === 'complete' ? srcbookText.text : ''}
                className="font-mono text-xs whitespace-pre min-h-[112px] resize-vertical"
                readOnly
              />
              <div className="flex justify-end">
                <Button type="button" onClick={onCopySrcbookToClipboard}>
                  Copy to Clipboard
                </Button>
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/install-package-modal.tsx
================
import { useState, useEffect } from 'react';
import { OutputType } from '@srcbook/components/src/types';
import { Loader2 } from 'lucide-react';
import { useDebounce } from 'use-debounce';
import { cn } from '@/lib/utils';
import { searchNpmPackages } from '@/lib/server';
import { Input } from '@srcbook/components/src/components/ui/input';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components/src/components/ui/dialog';

type NPMPackageType = {
  name: string;
  version: string;
  description?: string;
};

function getSelected(results: NPMPackageType[], selectedName: string, type: 'next' | 'prev') {
  const idx = results.findIndex((r) => r.name === selectedName);
  const selectedIdx = type === 'next' ? idx + 1 : idx - 1;

  const len = results.length;

  if (selectedIdx < 0) {
    return results[len - 1]?.name ?? null;
  } else if (selectedIdx >= len) {
    return results[0]?.name ?? null;
  } else {
    return results[selectedIdx]?.name ?? null;
  }
}

export default function InstallPackageModal({
  open,
  setOpen,
  npmInstall,
  installing,
  output,
}: {
  open: boolean;
  setOpen: (val: boolean) => void;
  npmInstall: (packages?: string[]) => void;
  installing: boolean;
  output: OutputType[];
}) {
  const [mode, setMode] = useState<'search' | 'loading' | 'success' | 'error'>('search');
  const [query, setQuery] = useState('');
  const [results, setResults] = useState<NPMPackageType[]>([]);
  const [pkg, setPkg] = useState<string>('');
  const [selectedName, setSelectedName] = useState<string | null>(null);

  const [value] = useDebounce(query, 300);

  useEffect(() => {
    setSelectedName(null);
    searchNpmPackages(value, 6) // Modal height works best with max 6 entries
      .then((data) => {
        const results = data.result;
        setResults(results);
        if (results.length > 0) {
          setSelectedName(results[0].name);
        }
      })
      .catch((e) => console.error('error:', e));
  }, [value]);

  useEffect(() => {
    if (mode === 'loading' && !installing) {
      setMode('success');
    }
  }, [mode, installing]);

  const addPackage = (packageName: string) => {
    setPkg(packageName);
    setMode('loading');
    npmInstall([packageName]);
  };

  return (
    <Dialog
      open={open}
      onOpenChange={(newOpen) => {
        if (!newOpen) {
          setQuery('');
          // Use a timeout to prevent flickering while it animates out
          setTimeout(() => setMode('search'), 300);
        } else {
          setMode('search');
        }
        setOpen(newOpen);
      }}
    >
      <DialogContent
        className={cn(
          'flex flex-col transition-height',
          mode === 'search' ? 'w-[800px] h-[484px]' : '',
        )}
      >
        {mode === 'error' && (
          <div className="flex flex-col w-full h-full items-center justify-center gap-3">
            <DialogTitle className="text-destructive">Something went wrong</DialogTitle>
            <p>Failed to install {pkg}, please try again.</p>
          </div>
        )}
        {mode === 'loading' && (
          <div className="flex w-full h-full items-center justify-center gap-3">
            <Loader2 className="animate-spin" />
            <p>Installing {pkg}</p>
          </div>
        )}
        {mode === 'success' && (
          <>
            <DialogHeader>
              <DialogTitle>Successfully added {pkg}</DialogTitle>
            </DialogHeader>
            <p className="font-mono text-sm whitespace-pre-line">
              {output.map((o) => o.data).join('')}
            </p>
          </>
        )}
        {mode === 'search' && (
          <>
            <DialogHeader>
              <DialogTitle>Install NPM package</DialogTitle>
              <DialogDescription id="npm-search-modal">
                Search for packages to add to your Srcbook.
              </DialogDescription>
            </DialogHeader>
            <Input
              placeholder="Search for a package"
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              role="combobox"
              aria-expanded={results.length > 0}
              aria-controls="npm-search-results"
              aria-labelledby="npm-search-modal"
              onKeyDown={(e) => {
                if (selectedName === null) {
                  return;
                }

                if (e.key === 'Enter') {
                  addPackage(selectedName);
                } else if (e.key === 'ArrowDown') {
                  e.preventDefault();
                  setSelectedName(getSelected(results, selectedName, 'next'));
                } else if (e.key === 'ArrowUp') {
                  e.preventDefault();
                  setSelectedName(getSelected(results, selectedName, 'prev'));
                }
              }}
            />
            {results.length > 0 ? (
              <SearchResultsList
                results={results}
                selectedName={selectedName!}
                setSelectedName={setSelectedName}
                onSelect={addPackage}
              />
            ) : (
              <NoSearchResults />
            )}
          </>
        )}
      </DialogContent>
    </Dialog>
  );
}

function NoSearchResults() {
  return <p className="text-tertiary-foreground text-sm text-center">No results found.</p>;
}

function SearchResultsList(props: {
  results: NPMPackageType[];
  selectedName: string;
  setSelectedName: (name: string) => void;
  onSelect: (name: string) => void;
}) {
  return (
    <ul
      id="npm-search-results"
      role="listbox"
      aria-label="NPM search results"
      className="overflow-y-scroll focus:border-yellow-300"
    >
      {props.results.map((result) => {
        const selected = result.name === props.selectedName;

        return (
          <li
            key={result.name}
            role="option"
            aria-disabled="false"
            aria-selected={selected}
            tabIndex={0}
            onKeyDown={(e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                props.onSelect(result.name);
              }
            }}
            className={cn(
              'px-2 py-1 rounded-sm cursor-pointer border border-transparent text-sm',
              selected && 'bg-muted border-border',
            )}
            onClick={() => props.onSelect(result.name)}
            onMouseEnter={() => props.setSelectedName(result.name)}
          >
            <div className="flex items-center gap-2 whitespace-nowrap">
              <strong className="truncate">{result.name}</strong>
              <span className="text-tertiary-foreground">{result.version}</span>
            </div>
            <p title={result.description} className="mt-1 text-tertiary-foreground truncate">
              {result.description}
            </p>
          </li>
        );
      })}
    </ul>
  );
}

================
File: web/src/components/keyboard-shortcuts-dialog.tsx
================
import Shortcut from '@srcbook/components/src/components/keyboard-shortcut';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from '@srcbook/components/src/components/ui/dialog';

function ShortcutRow({ keys, description }: { keys: string[]; description: string }) {
  return (
    <div className="grid grid-cols-5 w-full py-2">
      <p className="col-span-2">
        <Shortcut keys={keys} />
      </p>
      <p className="col-span-3">{description}</p>
    </div>
  );
}

export default function KeyboardShortcutsDialog({
  readOnly,
  open,
  onOpenChange,
}: {
  readOnly?: boolean;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}) {
  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Keyboard Shortcuts</DialogTitle>
          <DialogDescription asChild>
            <div>
              <h5 className="font-semibold pt-4 pb-2">Global</h5>
              <ShortcutRow keys={['?']} description="show this dialog" />
              <ShortcutRow keys={['mod', ';']} description="open package.json" />
              <ShortcutRow keys={['mod', 'i']} description="open npm package install modal" />
              <h5 className="font-semibold pt-6 pb-2">AI chat</h5>
              <ShortcutRow keys={['mod', 'enter']} description="send current message to the AI" />
              {!readOnly ? (
                <>
                  <h5 className="font-semibold pt-6 pb-2">Markdown edit</h5>
                  <ShortcutRow keys={['esc']} description="switch back to preview mode" />
                  <ShortcutRow keys={['mod', '↵']} description="switch back to preview mode" />
                  <h5 className="font-semibold pt-6 pb-2">Code cell edit</h5>
                  <ShortcutRow keys={['mod', '↵']} description="run cell" />
                  <ShortcutRow keys={['mod', '/']} description="toggle lines comment" />
                  <ShortcutRow keys={['alt', '↑']} description="move lines up" />
                  <ShortcutRow keys={['alt', '↓']} description="move lines down" />
                  <ShortcutRow
                    keys={['shift', 'alt', 'f']}
                    description="format code using Prettier"
                  />
                  <ShortcutRow keys={['alt', 'click']} description="go to definition" />
                  <h5 className="font-semibold pt-6 pb-2">App Builder</h5>
                  <ShortcutRow keys={['mod', 'shift', 'y']} description="toggle errors panel" />
                </>
              ) : null}
            </div>
          </DialogDescription>
        </DialogHeader>
      </DialogContent>
    </Dialog>
  );
}

================
File: web/src/components/logos.tsx
================
import { CodeLanguageType } from '@srcbook/shared';

type PropsType = {
  size?: string | number;
  className?: string;
};

export function SrcbookLogo(props: PropsType) {
  return (
    <svg
      width={props.size ?? 16}
      height={props.size ?? 16}
      className={props.className}
      viewBox="0 0 25 25"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M12.5192 1.91235L17.0537 4.53232L18.1874 5.18731M21.5883 7.15228V12.2914V13.5762M21.5883 17.4306L17.0537 20.0506L15.9201 20.7056M12.5192 22.6705L7.98463 20.0506L6.85099 19.3956M3.45007 17.4306V12.2914V11.0067M3.45007 7.15228L7.98463 4.53232L9.11826 3.87733"
        stroke="currentColor"
        strokeWidth="1.25"
        strokeLinejoin="round"
      />
      <circle cx="12.5192" cy="1.91235" r="1.28759" fill="currentColor" />
      <circle cx="21.5882" cy="7.15234" r="1.28759" fill="currentColor" />
      <circle cx="21.5882" cy="13.5771" r="1.28759" fill="currentColor" />
      <circle cx="21.5882" cy="17.4307" r="1.28759" fill="currentColor" />
      <circle cx="15.9191" cy="20.7056" r="1.28759" fill="currentColor" />
      <circle cx="12.5192" cy="22.6704" r="1.28759" fill="currentColor" />
      <circle cx="6.84997" cy="19.3955" r="1.28759" fill="currentColor" />
      <circle cx="3.45007" cy="17.4307" r="1.28759" fill="currentColor" />
      <circle cx="3.45007" cy="11.0076" r="1.28759" fill="currentColor" />
      <circle cx="3.45007" cy="7.15234" r="1.28759" fill="currentColor" />
      <circle cx="9.11724" cy="3.87743" r="1.28759" fill="currentColor" />
      <circle cx="18.1863" cy="5.18725" r="1.28759" fill="currentColor" />
    </svg>
  );
}

export function JavaScriptLogo(props: PropsType) {
  return (
    <svg
      width={props.size ?? '24'}
      height={props.size ?? '24'}
      viewBox="0 0 512 512"
      fill="none"
      className={props.className}
      xmlns="http://www.w3.org/2000/svg"
    >
      <g clipPath="url(#clip0_32_1298)">
        <path d="M512 0H0V512H512V0Z" fill="#F7DF1E" />
        <path
          d="M343.934 400.002C354.247 416.841 367.665 429.218 391.396 429.218C411.331 429.218 424.066 419.255 424.066 405.488C424.066 388.99 410.982 383.147 389.039 373.549L377.011 368.388C342.292 353.597 319.228 335.067 319.228 295.895C319.228 259.811 346.722 232.342 389.689 232.342C420.279 232.342 442.271 242.989 458.118 270.864L420.653 294.92C412.404 280.129 403.505 274.302 389.689 274.302C375.597 274.302 366.665 283.242 366.665 294.92C366.665 309.354 375.605 315.197 396.248 324.137L408.275 329.289C449.154 346.819 472.235 364.69 472.235 404.87C472.235 448.187 438.207 471.918 392.509 471.918C347.827 471.918 318.96 450.625 304.835 422.717L343.934 400.002ZM173.974 404.171C181.533 417.581 188.408 428.918 204.938 428.918C220.745 428.918 230.717 422.733 230.717 398.685V235.089H278.829V399.336C278.829 449.154 249.62 471.828 206.986 471.828C168.464 471.828 146.156 451.893 134.811 427.882L173.974 404.171Z"
          fill="black"
        />
      </g>
      <defs>
        <clipPath id="clip0_32_1298">
          <rect width="512" height="512" fill="white" />
        </clipPath>
      </defs>
    </svg>
  );
}

export function TypeScriptLogo(props: PropsType) {
  return (
    <svg
      width={props.size ?? '24'}
      height={props.size ?? '24'}
      viewBox="0 0 512 512"
      fill="none"
      className={props.className}
      xmlns="http://www.w3.org/2000/svg"
    >
      <g clipPath="url(#clip0_32_1301)">
        <path
          d="M462 0H50C22.3858 0 0 22.3858 0 50V462C0 489.614 22.3858 512 50 512H462C489.614 512 512 489.614 512 462V50C512 22.3858 489.614 0 462 0Z"
          fill="#3178C6"
        />
        <path
          d="M512 0H0.000267982C0.000660601 170.667 0.00243569 341.333 0 512H512V0Z"
          fill="#3178C6"
        />
        <path
          fillRule="evenodd"
          clipRule="evenodd"
          d="M316.939 407.424V457.485C325.077 461.657 334.702 464.785 345.814 466.871C356.926 468.957 368.637 470 380.949 470C392.948 470 404.346 468.853 415.145 466.558C425.944 464.264 435.413 460.483 443.551 455.216C451.689 449.95 458.132 443.066 462.879 434.566C467.626 426.066 470 415.559 470 403.044C470 393.97 468.644 386.018 465.931 379.187C463.218 372.356 459.306 366.281 454.193 360.962C449.081 355.643 442.951 350.871 435.804 346.647C428.657 342.423 420.597 338.434 411.624 334.68C405.051 331.968 399.156 329.335 393.939 326.78C388.722 324.224 384.288 321.617 380.636 318.958C376.984 316.298 374.167 313.482 372.185 310.51C370.203 307.537 369.211 304.174 369.211 300.419C369.211 296.978 370.098 293.875 371.872 291.111C373.646 288.347 376.15 285.975 379.384 283.993C382.619 282.012 386.583 280.473 391.278 279.378C395.974 278.283 401.19 277.736 406.929 277.736C411.102 277.736 415.51 278.049 420.153 278.674C424.796 279.3 429.465 280.265 434.161 281.568C438.856 282.872 443.42 284.515 447.855 286.496C452.289 288.478 456.384 290.772 460.14 293.38V246.604C452.524 243.684 444.203 241.52 435.178 240.112C426.153 238.704 415.797 238 404.112 238C392.217 238 380.949 239.278 370.307 241.833C359.665 244.388 350.301 248.377 342.214 253.8C334.128 259.224 327.738 266.133 323.043 274.529C318.348 282.924 316 292.962 316 304.643C316 319.557 320.304 332.281 328.912 342.815C337.519 353.348 350.587 362.265 368.116 369.566C375.002 372.382 381.419 375.145 387.366 377.857C393.313 380.569 398.452 383.385 402.781 386.305C407.111 389.225 410.528 392.406 413.033 395.848C415.537 399.289 416.789 403.2 416.789 407.581C416.789 410.814 416.006 413.812 414.441 416.576C412.876 419.34 410.502 421.738 407.32 423.772C404.138 425.806 400.173 427.396 395.426 428.543C390.678 429.691 385.123 430.264 378.758 430.264C367.907 430.264 357.161 428.361 346.518 424.554C335.876 420.748 326.016 415.038 316.939 407.424ZM232.78 284.082H297V243H118V284.082H181.906V467H232.78V284.082Z"
          fill="white"
        />
      </g>
      <defs>
        <clipPath id="clip0_32_1301">
          <rect width="512" height="512" fill="white" />
        </clipPath>
      </defs>
    </svg>
  );
}

export function LanguageLogo({ language, ...props }: PropsType & { language: CodeLanguageType }) {
  return language === 'typescript' ? <TypeScriptLogo {...props} /> : <JavaScriptLogo {...props} />;
}

================
File: web/src/components/mailing-list-card.tsx
================
import { useState } from 'react';
import { X, Mailbox } from 'lucide-react';
import { Card, CardContent } from '@srcbook/components/src/components/ui/card';
import { Input } from '@srcbook/components/src/components/ui/input';
import { Button } from '@srcbook/components/src/components/ui/button';
import { toast } from 'sonner';
import { subscribeToMailingList } from '@/lib/server';
import { useSettings } from '@/components/use-settings';

export default function MailingListCard() {
  const { subscriptionEmail, updateConfig } = useSettings();
  const [isVisible, setIsVisible] = useState(!subscriptionEmail);
  const [email, setEmail] = useState('');
  const [subscribed, setSubscribed] = useState(false);

  const handleClose = async () => {
    await updateConfig({ subscriptionEmail: 'dismissed' });
    setIsVisible(false);
  };

  const handleSubmit: React.FormEventHandler<HTMLFormElement> = async (e) => {
    e.preventDefault();
    try {
      const response = await subscribeToMailingList(email);
      if (response.success) {
        setSubscribed(true);
        await updateConfig({ subscriptionEmail: email });
        setTimeout(() => {
          setIsVisible(false);
        }, 3000);
      } else {
        toast.error('There was an error subscribing to the mailing list. Please try again later.');
      }
    } catch (error) {
      toast.error('There was an error subscribing to the mailing list. Please try again later.');
      console.error('Subscription error:', error);
    }
  };

  if (!isVisible) return null;

  return (
    <Card className="fixed bottom-6 left-6 w-[460px] shadow-lg z-30">
      <div className="relative">
        <button
          className="absolute top-2 right-2 hover:bg-muted p-1 rounded-sm"
          onClick={handleClose}
        >
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </button>
        <CardContent className="p-6">
          <div className="flex flex-col gap-2">
            <Mailbox size={24} />
            {subscribed ? (
              <>
                <h1 className="mt-2 text-lg font-medium">Thank you for subscribing!</h1>
                <p>We'll keep you updated with the latest news and features.</p>
              </>
            ) : (
              <>
                <h1 className="mt-2 text-lg font-medium">Join our mailing list!</h1>
                <p className="">
                  Get the latest updates, early access features, and expert tips delivered to your
                  inbox.
                </p>
                <form onSubmit={handleSubmit} className="flex gap-1 py-3">
                  <Input
                    type="email"
                    placeholder="Email"
                    className=""
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                  />
                  <Button type="submit">Subscribe</Button>
                </form>
              </>
            )}
          </div>
        </CardContent>
      </div>
    </Card>
  );
}

================
File: web/src/components/navbar.tsx
================
import { useState } from 'react';
import { useNavigate, NavLink, Link } from 'react-router-dom';
import {
  PlusIcon,
  ChevronDownIcon,
  SparklesIcon,
  ImportIcon,
  TrashIcon,
  ShareIcon,
  ExternalLinkIcon,
} from 'lucide-react';
import { TitleCellType } from '@srcbook/shared';

import { SessionType } from '@/types';
import { SrcbookLogo } from '@/components/logos';
import { Button } from '@srcbook/components/src/components/ui/button';
import GenerateSrcbookModal from '@/components/generate-srcbook-modal';
import DeleteSrcbookModal from '@/components/delete-srcbook-dialog';
import { ExportSrcbookModal, ImportSrcbookModal } from '@/components/import-export-srcbook-modal';
import useTheme from '@srcbook/components/src/components/use-theme';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@srcbook/components/src/components/ui/dropdown-menu';
import { createSession, createSrcbook } from '@/lib/server';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@srcbook/components/src/components/ui/tooltip';

function LightDarkModeDebugChanger() {
  const { theme, toggleTheme } = useTheme();

  if (process.env.NODE_ENV === 'production') {
    return null;
  }

  return (
    <div className="absolute left-1/2 -translate-x-1/2">
      <button
        onClick={toggleTheme}
        className="border-none outline-none text-muted-foreground hover:text-foreground font-semibold transition-colors"
      >
        {theme === 'light' ? '(DEV) Dark mode' : '(DEV) Light mode'}
      </button>
    </div>
  );
}

type SessionNavbarProps = {
  readOnly?: boolean;
  session: SessionType;
  srcbooks: Array<SessionType>;
  title: string;
  baseDir: string;
};

export function SessionNavbar(props: SessionNavbarProps) {
  const navigate = useNavigate();

  const [showGenSrcbookModal, setShowGenSrcbookModal] = useState(false);
  const [showImportSrcbookModal, setShowImportSrcbookModal] = useState(false);
  const [showDelete, setShowDelete] = useState(false);
  const [showSave, setShowSave] = useState(false);

  const srcbooks = props.srcbooks.sort((a, b) => b.openedAt - a.openedAt).slice(0, 6);

  async function openSrcbook(path: string) {
    // When switching srcbooks, make sure all the modals are hidden
    setShowGenSrcbookModal(false);
    setShowImportSrcbookModal(false);
    setShowSave(false);

    const { result: srcbook } = await createSession({ path });
    navigate(`/srcbooks/${srcbook.id}`);
  }

  async function onCreateSrcbook() {
    const { result } = await createSrcbook({
      path: props.baseDir,
      name: 'Untitled',

      // FIXME: copy the same language as the currently visible srcbook - should this be less
      // implicit?
      language: props.session.language,
    });
    openSrcbook(result.path);
  }

  return (
    <>
      <GenerateSrcbookModal
        open={showGenSrcbookModal}
        setOpen={setShowGenSrcbookModal}
        openSrcbook={openSrcbook}
      />
      <ImportSrcbookModal open={showImportSrcbookModal} onOpenChange={setShowImportSrcbookModal} />
      <DeleteSrcbookModal open={showDelete} onOpenChange={setShowDelete} session={props.session} />
      <ExportSrcbookModal open={showSave} onOpenChange={setShowSave} session={props.session} />

      <header className="h-12 w-full flex items-center justify-between fixed bg-background z-50 border-b border-border text-sm font-medium">
        <nav className="flex items-center justify-between px-4 flex-1">
          <div className="flex items-center gap-2">
            <NavLink to="/">
              <h1 className="font-mono font-bold flex items-center space-x-[10px] pr-1">
                <SrcbookLogo size={20} />
                <span>Srcbook</span>
              </h1>
            </NavLink>

            <span className="select-none">/</span>

            {srcbooks.length < 2 ? (
              <span className="px-1.5">{props.title}</span>
            ) : (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="icon" className="font-normal px-1.5 active:translate-y-0">
                    <div className="flex items-center gap-1 font-medium">
                      {props.title}
                      <ChevronDownIcon size={12} />
                    </div>
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="start" className="w-56">
                  {srcbooks.map((srcbook) => {
                    if (srcbook.id === props.session.id) {
                      return null;
                    }
                    const titleCell = srcbook.cells.find((cell) => cell.type === 'title') as
                      | TitleCellType
                      | undefined;
                    if (!titleCell) {
                      return null;
                    }

                    return (
                      <DropdownMenuItem
                        key={srcbook.id}
                        onClick={() => navigate(`/srcbooks/${srcbook.id}`)}
                        className="cursor-pointer"
                      >
                        {titleCell.text}
                      </DropdownMenuItem>
                    );
                  })}

                  {/* FIXME: how should more than 6 entries be rendered? */}
                  {props.srcbooks.length > 6 ? (
                    <DropdownMenuItem asChild className="cursor-pointer border-t mt-2 pt-2">
                      <Link to="/">See all</Link>
                    </DropdownMenuItem>
                  ) : null}
                </DropdownMenuContent>
              </DropdownMenu>
            )}

            {!props.readOnly ? (
              <>
                <div className="w-[1px] h-5 bg-border" />

                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="icon" className="w-8 h-8 p-0 active:translate-y-0">
                      <PlusIcon size={18} />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="start" className="w-56">
                    <DropdownMenuItem onClick={onCreateSrcbook} className="cursor-pointer">
                      <PlusIcon className="mr-2 h-4 w-4" />
                      <span>Create Srcbook</span>
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onClick={() => {
                        // FIXME: wrap this function calls in a setTimeout so that this runs after the
                        // dropdown menu at least starts closing (ie, removes `pointer-events: none;`)
                        //
                        // Otherwise the Dialog this setState call opens and the DropdownMenu will fight
                        // for control over the body tag styles.
                        setTimeout(() => {
                          setShowGenSrcbookModal(true);
                        }, 0);
                      }}
                      className="cursor-pointer"
                    >
                      <SparklesIcon className="mr-2 h-4 w-4" />
                      <span>Generate Srcbook</span>
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onClick={() => {
                        // FIXME: wrap this function calls in a setTimeout so that this runs after the
                        // dropdown menu at least starts closing (ie, removes `pointer-events: none;`)
                        //
                        // Otherwise the Dialog this setState call opens and the DropdownMenu will fight
                        // for control over the body tag styles.
                        setTimeout(() => {
                          setShowImportSrcbookModal(true);
                        }, 0);
                      }}
                      className="cursor-pointer"
                    >
                      <ImportIcon className="mr-2 h-4 w-4" />
                      <span>Open Notebook</span>
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </>
            ) : null}
          </div>

          <LightDarkModeDebugChanger />

          <div className="flex items-center gap-2">
            {!props.readOnly ? (
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      variant="icon"
                      size="icon"
                      onClick={() => setShowDelete(true)}
                      className="active:translate-y-0"
                    >
                      <TrashIcon size={18} />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>Delete this Srcbook</TooltipContent>
                </Tooltip>
              </TooltipProvider>
            ) : null}
            <Button
              variant="secondary"
              onClick={() => setShowSave(true)}
              className="active:translate-y-0"
            >
              <div className="flex gap-2">
                <ShareIcon size={16} />
                Share
              </div>
            </Button>
          </div>
        </nav>
      </header>
    </>
  );
}

function SocialGithubIcon() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="19" height="19" fill="none" viewBox="0 0 19 19">
      <path
        fill="#8E979D"
        d="M10 .792a9 9 0 00-2.833 17.583c.416.083.75-.375.75-.75v-1.208c-2.5.541-3.292-1.209-3.292-1.209a2.708 2.708 0 00-.917-1.333c-.833-.583.042-.542.042-.542a1.792 1.792 0 011.375.834c.708 1.208 2.292 1.083 2.792.875a2.25 2.25 0 01.208-1.209c-2.833-.5-4.375-2.166-4.375-4.416A4.458 4.458 0 014.958 6.25a2.583 2.583 0 01.125-2.667A3.708 3.708 0 017.75 4.792 6.292 6.292 0 0110 4.458c.76-.023 1.52.075 2.25.292a3.75 3.75 0 012.667-1.167 2.709 2.709 0 01.166 2.667 4.458 4.458 0 011.167 3.167c0 2.25-1.542 3.916-4.375 4.416.18.376.252.794.208 1.209v2.583a.753.753 0 00.792.75A9.043 9.043 0 0010 .792z"
      ></path>
    </svg>
  );
}

function SocialDiscordIcon() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
      <path
        fill="#8E979D"
        d="M18.942 5.556a16.288 16.288 0 00-4.126-1.297c-.178.321-.386.754-.529 1.097a15.15 15.15 0 00-4.573 0A11.73 11.73 0 009.18 4.26c-1.448.25-2.834.693-4.129 1.3-2.611 3.946-3.319 7.794-2.965 11.587a16.495 16.495 0 005.06 2.593c.408-.56.771-1.156 1.084-1.785a10.659 10.659 0 01-1.706-.83c.143-.106.283-.217.418-.331 3.29 1.539 6.866 1.539 10.118 0 .137.114.277.225.418.33a10.63 10.63 0 01-1.71.833c.314.627.675 1.224 1.084 1.785a16.466 16.466 0 005.064-2.595c.415-4.397-.71-8.21-2.973-11.59zM8.678 14.813c-.988 0-1.798-.922-1.798-2.045 0-1.123.792-2.047 1.798-2.047 1.005 0 1.815.922 1.798 2.047.001 1.123-.793 2.045-1.798 2.045zm6.644 0c-.988 0-1.798-.922-1.798-2.045 0-1.123.793-2.047 1.798-2.047 1.006 0 1.816.922 1.798 2.047 0 1.123-.793 2.045-1.798 2.045z"
      ></path>
    </svg>
  );
}

export function Navbar() {
  return (
    <header className="h-12 w-full flex items-center justify-between fixed bg-background z-50 border-b border-border text-sm ">
      <nav className="flex items-center justify-between px-4 flex-1">
        <div className="flex items-center gap-6">
          <NavLink to="/">
            <h1 className="font-mono font-bold flex items-center space-x-[10px]">
              <SrcbookLogo size={20} />
              <span>Srcbook</span>
            </h1>
          </NavLink>

          <ul className="flex items-center gap-6">
            <li>
              <NavLink
                to="/secrets"
                className="font-semibold text-tertiary-foreground visited:text-tertiary-foreground hover:text-foreground transition-colors"
              >
                Secrets
              </NavLink>
            </li>
            <li>
              <NavLink
                to="/settings"
                className="font-semibold text-tertiary-foreground visited:text-tertiary-foreground hover:text-foreground transition-colors"
              >
                Settings
              </NavLink>
            </li>
            <li>
              <a
                href="https://hub.srcbook.com"
                target="_blank"
                className="font-semibold text-tertiary-foreground visited:text-tertiary-foreground hover:text-foreground transition-colors"
              >
                <div className="flex items-center gap-1.5">
                  Hub
                  <ExternalLinkIcon size={14} />
                </div>
              </a>
            </li>
          </ul>
        </div>

        <LightDarkModeDebugChanger />

        <div className="flex items-center gap-2">
          <a href="https://discord.gg/shDEGBSe2d" target="_blank">
            <Button variant="icon" size="icon" className="active:translate-y-0">
              <SocialDiscordIcon />
            </Button>
          </a>
          <a href="https://github.com/srcbookdev/srcbook" target="_blank">
            <Button variant="icon" size="icon" className="active:translate-y-0">
              <SocialGithubIcon />
            </Button>
          </a>
        </div>
      </nav>
    </header>
  );
}

================
File: web/src/components/onboarding.tsx
================
import React from 'react';
import { LayoutGridIcon, FileTextIcon } from 'lucide-react';
import { AiSettings } from '@/routes/settings';

const OnboardingModal: React.FunctionComponent = () => {
  return (
    <div className="flex flex-col gap-6">
      <h2 className="text-3xl font-medium">Welcome to Srcbook!</h2>
      <p>Srcbook is an AI-powered TypeScript app builder and interactive playground.</p>

      <div className="flex flex-col gap-3">
        <h4 className="font-medium">With Srcbook you can:</h4>
        <div className="flex flex-col md:flex-row gap-6">
          <div
            className="p-5 rounded-lg bg-[#FFD9E1]"
            style={{
              background:
                'linear-gradient(180deg, rgba(255,217,225,1) 0%, rgba(219,183,223,1) 100%)',
            }}
          >
            <div className="flex items-center mb-6">
              <LayoutGridIcon size={24} className="text-ai-btn" />
            </div>
            <h3 className="text-ai-btn font-medium mt-3">App builder</h3>
            <p className="text-ai-btn mt-2">Create Web Applications with the speed of thinking</p>
          </div>

          <div className="border p-5 rounded-lg">
            <div className="flex items-center mb-6">
              <FileTextIcon size={24} className="text-button-secondary" />
            </div>
            <h3 className="text-primary font-medium mt-3">Notebook</h3>
            <p className="text-primary mt-2">
              Experimenting without the hassle of setting up environments
            </p>
          </div>
        </div>
      </div>

      <div>
        <label htmlFor="aiProvider" className="block mb-3">
          To get started, select your AI provider and enter your API key:
        </label>

        <AiSettings saveButtonLabel="Continue" />
      </div>
    </div>
  );
};

export default OnboardingModal;

================
File: web/src/components/srcbook-cards.tsx
================
import { Sparkles, Circle, PlusIcon, Trash2, Import, LayoutGrid } from 'lucide-react';
import { Button } from '@srcbook/components/src/components/ui/button';
import { CodeLanguageType } from '@srcbook/shared';
import { SrcbookLogo } from './logos';
import { cn } from '@/lib/utils';
import { useState } from 'react';
import { ExampleSrcbookType } from '@/types';

function LongDashedHorizontalLine(props: { className?: string }) {
  return (
    <div className={props.className}>
      <svg width="1000" height="2" viewBox="0 -1 1000 2" xmlns="http://www.w3.org/2000/svg">
        <line
          x1="0"
          y1="0"
          x2="1000"
          y2="0"
          stroke="currentColor"
          strokeWidth="1"
          strokeDasharray="8, 4"
        />
      </svg>
    </div>
  );
}

function LongDashedVerticalLine(props: { className?: string }) {
  return (
    <div className={props.className}>
      <svg width="2" height="1000" viewBox="-1 0 2 1000" xmlns="http://www.w3.org/2000/svg">
        <line
          x1="0"
          y1="0"
          x2="0"
          y2="1000"
          stroke="currentColor"
          strokeWidth="1"
          strokeDasharray="8, 4"
        />
      </svg>
    </div>
  );
}

export function MainCTACard(props: { srcbook: ExampleSrcbookType; onClick: () => void }) {
  const { srcbook, onClick } = props;

  return (
    <div
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onClick?.();
        }
      }}
      className="flex flex-col items-center cursor-pointer border hover:border-foreground transition-colors active:translate-y-0.5 rounded-sm"
      onClick={onClick}
    >
      <div className="w-full grow h-[130px] bg-sb-core-20 rounded-t-[2px] flex items-center justify-center">
        <SrcbookLogo size={64} className="text-sb-core-40" />
      </div>
      <div className="w-full relative overflow-clip">
        <LongDashedHorizontalLine className="absolute top-[10px] text-border" />
        <LongDashedHorizontalLine className="absolute bottom-[10px] text-border" />
        <LongDashedVerticalLine className="absolute left-[10px] top-0 text-border" />
        <LongDashedVerticalLine className="absolute right-[10px] top-0 text-border" />
        <div className="w-full flex-1 p-6 space-y-2">
          <h4 className="h5 line-clamp-2">{srcbook.title}</h4>
          <p className="text-sm text-ter tiary-foreground line-clamp-2">{srcbook.description}</p>
          <div className="flex items-center justify-between">
            <div className="space-x-1">
              {srcbook.tags.map((tag) => (
                <Tag key={tag} value={tag} />
              ))}
            </div>
            <span className="font-mono text-sm text-tertiary-foreground">
              {srcbook.language === 'typescript' ? 'TS' : 'JS'}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
}

function Tag(props: { value: string }) {
  return (
    <span className="px-1.5 py-1 text-[13px] bg-sb-yellow-20 text-sb-yellow-70 dark:bg-sb-yellow-50 dark:text-sb-core-160 rounded-sm">
      {props.value}
    </span>
  );
}

export function CardContainer({
  className,
  onClick,
  children,
  ...props
}: React.ComponentPropsWithoutRef<'div'> & {
  onClick?: () => void;
}) {
  return (
    <div
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onClick?.();
        }
      }}
      {...props}
      onClick={onClick}
      className={cn(
        'group border relative rounded-md h-[92px] overflow-clip cursor-pointer transition-colors text-sm',
        className,
      )}
    >
      <div className="px-4 py-3 h-full flex flex-col justify-between">{children}</div>
    </div>
  );
}

type SrcbookCardPropsType = {
  title: string;
  running: boolean;
  cellCount: number;
  language: CodeLanguageType;
  onClick: () => void;
  onDelete: () => void;
};

export function SrcbookCard(props: SrcbookCardPropsType) {
  function onDelete(e: React.MouseEvent<HTMLButtonElement>) {
    e.stopPropagation();
    props.onDelete();
  }

  return (
    <CardContainer
      onClick={props.onClick}
      className={cn(
        'active:translate-y-0.5',
        props.running ? 'border-run' : 'hover:border-foreground',
      )}
    >
      <h5 className="font-medium leading-[18px] line-clamp-2">{props.title}</h5>
      <div className="flex align-bottom items-center justify-between text-tertiary-foreground">
        <div className="text-[13px] flex items-center gap-2">
          {props.running ? (
            <>
              <Circle size={14} strokeWidth={3} className="text-run" />
              <span>Running</span>
            </>
          ) : (
            <span>
              {props.cellCount} {props.cellCount === 1 ? 'Cell' : 'Cells'}
            </span>
          )}
        </div>
        <code className="font-mono group-hover:hidden">
          {props.language === 'javascript' ? 'JS' : 'TS'}
        </code>
        <button
          type="button"
          onClick={onDelete}
          className="hidden group-hover:block hover:text-foreground"
        >
          <Trash2 size={16} />
        </button>
      </div>
    </CardContainer>
  );
}

type AppCardPropsType = {
  name: string;
  onClick: () => void;
  onDelete: () => void;
};

export function AppCard(props: AppCardPropsType) {
  function onDelete(e: React.MouseEvent<HTMLButtonElement>) {
    e.stopPropagation();
    props.onDelete();
  }

  return (
    <CardContainer
      onClick={props.onClick}
      className="active:translate-y-0.5 hover:border-foreground"
    >
      <span className="flex items-center">
        <LayoutGrid size={20} className="mr-2 text-sb-purple-60" />
        <h5 className="font-medium leading-[18px] line-clamp-2">{props.name}</h5>
      </span>
      <div className="flex justify-end">
        <code className="font-mono group-hover:hidden text-tertiary-foreground">TS</code>
        <button
          type="button"
          onClick={onDelete}
          className="hidden group-hover:block hover:text-foreground"
        >
          <Trash2 size={16} />
        </button>
      </div>
    </CardContainer>
  );
}

export function GenerateSrcbookButton(props: { onClick: () => void }) {
  return (
    <CardContainer
      onClick={() => props.onClick()}
      className="active:translate-y-0.5 hover:border-foreground"
    >
      <div className="flex flex-col h-full items-start justify-between">
        <Sparkles size={20} />
        <h5 className="font-medium leading-[18px]">Generate Notebook</h5>
      </div>
    </CardContainer>
  );
}

export function CreateSrcbookButton(props: {
  defaultLanguage: CodeLanguageType;
  onSubmit: (language: CodeLanguageType) => void;
}) {
  const [language, setLanguage] = useState(props.defaultLanguage);

  return (
    <div className="space-y-1">
      <CardContainer
        onClick={() => props.onSubmit(language)}
        className="active:translate-y-0.5 hover:border-foreground"
      >
        <div className="flex flex-col h-full items-start justify-between">
          <PlusIcon size={20} />
          <h5 className="font-medium leading-[18px]">Create Notebook</h5>
        </div>
      </CardContainer>

      <div className="flex border rounded-sm bg-background w-fit">
        <Button
          title="Use JavaScript for this Notebook"
          variant="secondary"
          className={cn(
            'border-none rounded-r-none active:translate-y-0 text-muted-foreground bg-muted w-10',
            language === 'javascript' && 'text-foreground font-bold',
          )}
          onClick={() => setLanguage('javascript')}
        >
          JS
        </Button>
        <Button
          title="Use TypeScript for this Notebook"
          variant="secondary"
          className={cn(
            'border-none rounded-l-none active:translate-y-0 text-muted-foreground bg-muted w-10',
            language === 'typescript' && 'text-foreground font-bold',
          )}
          onClick={() => setLanguage('typescript')}
        >
          TS
        </Button>
      </div>
    </div>
  );
}

export function CreateAppButton(props: { defaultLanguage: CodeLanguageType; onClick: () => void }) {
  return (
    <CardContainer
      onClick={() => props.onClick()}
      className="active:translate-y-0.5 bg-[#F6EEFB80] dark:bg-[#331F4780] border-sb-purple-20 dark:border-sb-purple-80 hover:border-sb-purple-60 text-sb-purple-70 dark:text-sb-purple-20"
    >
      <div className="flex flex-col h-full items-start justify-between">
        <PlusIcon size={20} />
        <div className="flex items-center">
          <h5 className="font-medium leading-[18px] mr-2">Create App</h5>
          <span className="flex items-center justify-center h-[16px] px-2 rounded-lg text-sb-purple-60 dark:text-sb-purple-20 bg-sb-core-0 dark:bg-sb-core-100">
            New
          </span>
        </div>
      </div>
    </CardContainer>
  );
}

export function ImportSrcbookButton(props: { onClick: () => void }) {
  return (
    <CardContainer
      onClick={() => props.onClick()}
      className="border-dashed hover:border-solid focus-within:border-foreground"
    >
      <div className="flex flex-col h-full items-start justify-between">
        <Import size={20} />
        <div className="flex flex-col items-start gap-1">
          <h5 className="font-medium leading-none">Import Notebook</h5>
        </div>
      </div>
    </CardContainer>
  );
}

================
File: web/src/components/srcmd-upload-drop-zone.tsx
================
import { useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { toast } from 'sonner';
import { UploadIcon } from 'lucide-react';

import { cn } from '@/lib/utils';

type SrcMdUploadDropZoneProps = {
  onDrop: (uploadedFile: File) => void;
  className?: string;
};

export default function SrcMdUploadDropZone({ onDrop, className }: SrcMdUploadDropZoneProps) {
  const onDropInternal = useCallback(
    (acceptedFiles: Array<File>) => {
      if (acceptedFiles.length > 1) {
        toast.error('Please drop only a single .src.md file!');
        return;
      }
      const file = acceptedFiles[0]!;

      if (!file.name.endsWith('.src.md')) {
        toast.error('Please drop only a single .src.md file!');
        return;
      }

      onDrop(file);
    },
    [onDrop],
  );

  const { getRootProps, getInputProps, isDragActive } = useDropzone({ onDrop: onDropInternal });

  const rootProps = getRootProps();
  return (
    <button
      {...rootProps}
      className={cn(
        'flex flex-col gap-4 w-full items-center justify-center p-6 border border-dashed rounded-md',
        'hover:bg-muted cursor-pointer',
        {
          'bg-muted': isDragActive,
        },
        className,
        rootProps.className,
      )}
    >
      <input {...getInputProps()} />

      {isDragActive ? (
        <span>Drop file here</span>
      ) : (
        <>
          <div className="w-14 h-14 flex items-center justify-center rounded-full border">
            <UploadIcon size={24} />
          </div>
          <span>
            Click to browse or drag and drop a <code>.src.md</code> file here
          </span>
        </>
      )}
    </button>
  );
}

================
File: web/src/components/use-effect-once.tsx
================
import { useRef, useEffect, type EffectCallback } from 'react';

function useEffectDev(effect: EffectCallback) {
  const ref = useRef(0);

  useEffect(() => {
    ref.current += 1;

    // Only run effect on second call
    if (ref.current === 2) {
      return effect();
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
}

function useEffectProd(effect: EffectCallback) {
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(effect, []);
}

export default process.env.NODE_ENV === 'production' ? useEffectProd : useEffectDev;

================
File: web/src/components/use-package-json.tsx
================
import React, { createContext, useCallback, useContext, useEffect, useState } from 'react';
import {
  DepsValidateResponsePayloadType,
  PackageJsonCellType,
  PackageJsonCellUpdateAttrsType,
} from '@srcbook/shared';
import { OutputType } from '@srcbook/components/src/types';
import { SessionChannel } from '@/clients/websocket';
import { useCells } from '@srcbook/components/src/components/use-cell';
import useEffectOnce from './use-effect-once';

function getValidationError(source: string) {
  try {
    JSON.parse(source);
    return null;
  } catch (e) {
    const err = e as Error;
    return err.message;
  }
}

export interface PackageJsonContextValue {
  source: string;
  onChangeSource: (source: string) => void;
  npmInstall: (packages?: string[]) => void;
  validationError: string | null;
  outdated: boolean | string[];
  installing: boolean;
  failed: boolean;
  output: OutputType[];
}

const PackageJsonContext = createContext<PackageJsonContextValue | undefined>(undefined);

type ProviderPropsType = {
  channel: SessionChannel;
  children: React.ReactNode;
};

/**
 * An interface for working with package.json.
 *
 * This fulfills two purposes:
 *
 * 1. Abstract operations involving package.json
 * 2. Decouple the rest of the code from treating package.json
 *    as a cell since we want to move away from that.
 */
export function PackageJsonProvider({ channel, children }: ProviderPropsType) {
  const { cells, updateCell: updateCellOnClient, getOutput, clearOutput } = useCells();

  const cell = cells.find((cell) => cell.type === 'package.json') as PackageJsonCellType;

  // outdated means package.json is out of date and needs to install deps.
  //
  // If outdated is an array, it means the specific entries in the array are
  // packages that are not yet listed in package.json's dependencies. In this
  // case, we must ensure we install these packages and save them to package.json.
  //
  // If outdated is true, it means there are packages in package.json that need
  // to be installed. This can happen if user created or imported a srcbook and
  // forgot to run `npm install` or when AI adds packages to package.json.
  //
  const [outdated, setOutdated] = useState<boolean | string[]>(false);

  const [validationError, setValidationError] = useState<string | null>(null);

  useEffectOnce(() => {
    channel.push('deps:validate', {});
  });

  const npmInstall = useCallback(
    (packages?: string[]) => {
      const error = getValidationError(cell.source);
      setValidationError(error);
      if (error === null) {
        updateCellOnClient({ ...cell, status: 'running' });
        clearOutput(cell.id);
        setOutdated(false);
        channel.push('deps:install', { packages });
      }
    },
    [cell, channel, updateCellOnClient, clearOutput],
  );

  useEffect(() => {
    const callback = (response: DepsValidateResponsePayloadType) => {
      // If we receive a response at all, it means there are outdated packages.
      setOutdated(response.packages ?? true);
    };

    channel.on('deps:validate:response', callback);
    return () => channel.off('deps:validate:response', callback);
  }, [channel, npmInstall]);

  function updateCellOnServer(updates: PackageJsonCellUpdateAttrsType) {
    channel.push('cell:update', {
      cellId: cell.id,
      updates,
    });
  }

  function onChangeSource(source: string) {
    const updates = { ...cell, source };
    updateCellOnClient(updates);

    const error = getValidationError(source);
    setValidationError(error);

    if (error === null) {
      updateCellOnServer(updates);
    }
  }

  const context: PackageJsonContextValue = {
    source: cell.source,
    onChangeSource,
    npmInstall,
    output: getOutput(cell.id),
    validationError,
    outdated,
    installing: cell.status === 'running',
    failed: cell.status === 'failed',
  };

  return <PackageJsonContext.Provider value={context}>{children}</PackageJsonContext.Provider>;
}

export function usePackageJson() {
  const context = useContext(PackageJsonContext);

  if (!context) {
    throw new Error('usePackageJson must be used within a PackageJsonProvider');
  }

  return context;
}

================
File: web/src/components/use-settings.tsx
================
import React, { createContext, useContext } from 'react';
import { useRevalidator } from 'react-router-dom';
import { updateConfig as updateConfigServer } from '@/lib/server';
import type { SettingsType } from '@/types';

export type SettingsContextValue = SettingsType & {
  aiEnabled: boolean;
  updateConfig: (newConfig: Partial<SettingsType>) => Promise<void>;
};

const SettingsContext = createContext<SettingsContextValue | null>(null);

type ProviderPropsType = {
  config: SettingsType;
  children: React.ReactNode;
};

/**
 * An interface for working with our config.
 */
export function SettingsProvider({ config, children }: ProviderPropsType) {
  const revalidator = useRevalidator();

  const updateConfig = async (newConfig: Partial<SettingsType>) => {
    // Filter out null values and convert back to an object
    const changeSet = Object.fromEntries(
      Object.entries(newConfig).filter(([_, value]) => value !== null),
    );

    await updateConfigServer(changeSet);
    revalidator.revalidate();
  };

  const aiEnabled =
    (config.openaiKey && config.aiProvider === 'openai') ||
    (config.anthropicKey && config.aiProvider === 'anthropic') ||
    (config.xaiKey && config.aiProvider === 'Xai') ||
    (config.geminiKey && config.aiProvider === 'Gemini') ||
    (config.aiProvider === 'custom' && !!config.aiBaseUrl) ||
    false;

  const context: SettingsContextValue = {
    ...config,
    aiEnabled,
    updateConfig,
  };

  return <SettingsContext.Provider value={context}>{children}</SettingsContext.Provider>;
}

export function useSettings() {
  const context = useContext(SettingsContext);

  if (!context) {
    throw new Error('useSettings must be used within a SettingsProvider');
  }

  return context;
}

================
File: web/src/components/use-tsconfig-json.tsx
================
import React, { createContext, useCallback, useContext, useState } from 'react';
import { SessionType } from '@/types';
import { SessionChannel } from '@/clients/websocket';

function getValidationError(source: string) {
  try {
    JSON.parse(source);
    return null;
  } catch (e) {
    const err = e as Error;
    return err.message;
  }
}

export interface TsConfigContextValue {
  source: string;
  onChangeSource: (source: string) => void;
  validationError: string | null;
}

const TsConfigContext = createContext<TsConfigContextValue | undefined>(undefined);

type ProviderPropsType = {
  session: SessionType;
  channel: SessionChannel;
  children: React.ReactNode;
};

/**
 * An interface for working with tsconfig.json.
 */
export function TsConfigProvider({ channel, session, children }: ProviderPropsType) {
  const [source, setSource] = useState(session['tsconfig.json'] || '');
  const [validationError, setValidationError] = useState<string | null>(null);

  const onChangeSource = useCallback(
    (source: string) => {
      setSource(source);

      const error = getValidationError(source);
      setValidationError(error);

      if (error === null) {
        channel.push('tsconfig.json:update', {
          source,
        });
      }
    },
    [setSource, channel, setValidationError],
  );

  const context: TsConfigContextValue = {
    source,
    onChangeSource,
    validationError,
  };

  return <TsConfigContext.Provider value={context}>{children}</TsConfigContext.Provider>;
}

export function useTsconfigJson() {
  const context = useContext(TsConfigContext);

  if (!context) {
    throw new Error('useTsconfigJson must be used within a TsConfigProvider');
  }

  return context;
}

================
File: web/src/lib/environment.ts
================
export const VITE_SRCBOOK_DEBUG_RENDER_SESSION_AS_READ_ONLY =
  (import.meta.env.VITE_SRCBOOK_DEBUG_RENDER_SESSION_AS_READ_ONLY || 'false').toLowerCase() ===
  'true';

================
File: web/src/lib/file-system-access.ts
================
// ref: https://developer.mozilla.org/en-US/docs/Web/API/File_System_API
type ShowSaveFilePicker = (options?: {
  excludeAcceptAllOption?: boolean;
  id?: string;
  startIn?: 'desktop' | 'documents' | 'downloads' | 'music' | 'pictures' | 'videos';
  suggestedName?: string;
  types?: Array<{
    description?: string;
    accept: { [mimetype: string]: Array<string> };
  }>;
}) => Promise<FileSystemFileHandle>;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const showSaveFilePicker: ShowSaveFilePicker | undefined = (window as any)
  .showSaveFilePicker;

================
File: web/src/lib/server.ts
================
import type {
  AiProviderType,
  CodeLanguageType,
  MarkdownCellType,
  CodeCellType,
  SecretWithAssociatedSessions,
} from '@srcbook/shared';
import { SessionType, ExampleSrcbookType } from '@/types';
import SRCBOOK_CONFIG from '@/config';

const API_BASE_URL = `${SRCBOOK_CONFIG.api.origin}/api`;

export async function getFileContent(filename: string) {
  const file_response = await fetch(API_BASE_URL + '/file', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      file: filename,
    }),
  });
  return await file_response.json();
}

interface CreateSrcbookRequestType {
  path: string;
  name: string;
  language: CodeLanguageType;
}

interface CreateSrcbookResponseType {
  error: boolean;
  result: { path: string; name: string };
}

export async function createSrcbook(
  request: CreateSrcbookRequestType,
): Promise<CreateSrcbookResponseType> {
  const response = await fetch(API_BASE_URL + '/srcbooks', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function deleteSrcbook(request: { id: string }) {
  const response = await fetch(API_BASE_URL + '/srcbooks/' + request.id, {
    method: 'DELETE',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }
}

interface ImportSrcbookRequestType {
  path?: string;
  url?: string;
  text?: string;
}

interface ImportSrcbookResponseType {
  error: boolean;
  result: { dir: string; name: string };
}

export async function importSrcbook(
  request: ImportSrcbookRequestType,
): Promise<ImportSrcbookResponseType> {
  const response = await fetch(API_BASE_URL + '/import', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

type GenerateSrcbookRequestType = { query: string };
type GenerateSrcbookResponseType =
  | { error: false; result: { dir: string } }
  | { error: true; result: string };

export async function generateSrcbook(
  request: GenerateSrcbookRequestType,
): Promise<GenerateSrcbookResponseType> {
  const response = await fetch(API_BASE_URL + '/generate', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

type GenerateCellsRequestType = { insertIdx: number; query: string };
type GenerateCellsResponseType =
  | { error: true; result: string }
  | { error: false; result: Array<CodeCellType | MarkdownCellType> };
export async function generateCells(
  sessionId: string,
  request: GenerateCellsRequestType,
): Promise<GenerateCellsResponseType> {
  const response = await fetch(API_BASE_URL + '/sessions/' + sessionId + '/generate_cells', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

interface CreateSessionRequestType {
  path: string;
}

interface CreateSessionResponseType {
  error: boolean;
  result: { id: string };
}

export async function createSession(
  request: CreateSessionRequestType,
): Promise<CreateSessionResponseType> {
  const response = await fetch(API_BASE_URL + '/sessions', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

interface LoadSessionRequestType {
  id: string;
}

interface LoadSessionResponseType {
  error: boolean;
  result: SessionType;
}

export async function loadSession(
  request: LoadSessionRequestType,
): Promise<LoadSessionResponseType> {
  const response = await fetch(API_BASE_URL + '/sessions/' + request.id, {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function loadSessions(): Promise<{ error: boolean; result: SessionType[] }> {
  const response = await fetch(API_BASE_URL + '/sessions', {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

interface ExportSrcmdFileRequestType {
  filename: string;
  directory: string;
}

export async function exportSrcmdFile(sessionId: string, request: ExportSrcmdFileRequestType) {
  const response = await fetch(API_BASE_URL + '/sessions/' + sessionId + '/export', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

export async function exportSrcmdText(sessionId: string) {
  const response = await fetch(API_BASE_URL + '/sessions/' + sessionId + '/export-text');

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.text();
}

// Config settings
interface EditConfigRequestType {
  baseDir?: string;
  defaultLanguage?: 'typescript' | 'javascript';
  openaiKey?: string;
  anthropicKey?: string;
  aiBaseUrl?: string;
  aiModel?: string;
  aiProvider?: AiProviderType;
  subscriptionEmail?: string | null;
}

export async function getConfig() {
  const response = await fetch(API_BASE_URL + '/settings', {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }
  return response.json();
}

export async function updateConfig(request: EditConfigRequestType): Promise<void> {
  const response = await fetch(API_BASE_URL + '/settings', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }
}

// Secret management
export async function getSecrets(): Promise<{ result: SecretWithAssociatedSessions[] }> {
  const response = await fetch(API_BASE_URL + '/secrets', {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }
  return response.json();
}

interface CreateSecretRequestType {
  name: string;
  value: string;
}

export async function createSecret(request: CreateSecretRequestType) {
  const response = await fetch(API_BASE_URL + '/secrets', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });
  if (!response.ok) {
    console.error(response);
    throw new Error('Request for creating a secret failed');
  }
  return response.json();
}

interface UpdateSecretRequestType {
  previousName: string;
  name: string;
  value: string;
}
export async function updateSecret(request: UpdateSecretRequestType) {
  const response = await fetch(API_BASE_URL + '/secrets/' + request.previousName, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(request),
  });
  if (!response.ok) {
    console.error(response);
    throw new Error('Request for updating a secret failed');
  }
  return response.json();
}

interface DeleteSecretRequestType {
  name: string;
}
export async function deleteSecret(request: DeleteSecretRequestType) {
  const response = await fetch(API_BASE_URL + '/secrets/' + request.name, {
    method: 'DELETE',
    headers: { 'content-type': 'application/json' },
  });
  if (!response.ok) {
    console.error(response);
    throw new Error('Request for deleting a secret failed');
  }
  return response.json();
}

export async function associateSecretWithSession(sessionId: string, secretName: string) {
  const response = await fetch(`${API_BASE_URL}/sessions/${sessionId}/secrets/${secretName}`, {
    method: 'PUT',
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }
}

export async function disassociateSecretWithSession(sessionId: string, secretName: string) {
  const response = await fetch(`${API_BASE_URL}/sessions/${sessionId}/secrets/${secretName}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }
}

// NPM package search, has to happen on the server given CORS restrictions
export async function searchNpmPackages(query: string, size: number) {
  if (query === '') {
    return { error: false, result: [] };
  }

  const response = await fetch(
    `${API_BASE_URL}/npm/search?q=${encodeURIComponent(query)}&size=${size}`,
    {
      headers: { 'content-type': 'application/json' },
    },
  );

  if (!response.ok) {
    console.error(response);
    return { error: true, result: [] };
  }

  return response.json();
}

type SrcbookExamplesResponse = {
  result: ExampleSrcbookType[];
};

export async function loadSrcbookExamples(): Promise<SrcbookExamplesResponse> {
  const response = await fetch(API_BASE_URL + '/examples', {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Request failed');
  }

  return response.json();
}

type FeedbackRequestType = {
  feedback: string;
  email: string;
};

export async function sendFeedback({ feedback, email }: FeedbackRequestType) {
  const response = await fetch(API_BASE_URL + '/feedback', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ feedback, email }),
  });

  if (!response.ok) {
    console.error(response);
  }
}

export async function aiHealthcheck() {
  const response = await fetch(API_BASE_URL + '/ai/healthcheck', {
    method: 'GET',
    headers: { 'content-type': 'application/json' },
  });
  if (!response.ok) {
    console.error(response);
  }
  return response.json();
}

export async function subscribeToMailingList(email: string) {
  const response = await fetch(API_BASE_URL + '/subscribe', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ email }),
  });

  if (!response.ok) {
    console.error(response);
    throw new Error('Subscription request failed');
  }

  return response.json();
}

================
File: web/src/lib/utils.ts
================
import type * as React from 'react';
import type { SessionType } from '../types';
import type { CellType, TitleCellType } from '@srcbook/shared';
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// Taken from https://github.com/gregberge/react-merge-refs/blob/main/src/index.tsx
export function mergeRefs<T>(
  refs: Array<React.MutableRefObject<T> | React.LegacyRef<T> | undefined | null>,
): React.RefCallback<T> {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === 'function') {
        ref(value);
      } else if (ref != null) {
        (ref as React.MutableRefObject<T | null>).current = value;
      }
    });
  };
}

export function getTitleForSession(session: SessionType) {
  const titleCell = session.cells.find((cell: CellType) => cell.type === 'title') as TitleCellType;
  return titleCell?.text;
}

export function isValidSecretName(name: string) {
  return /^[A-Z0-9_]+$/.test(name);
}

================
File: web/src/routes/apps/context.tsx
================
import { Outlet, useLoaderData } from 'react-router-dom';
import type { AppType, DirEntryType, FileType } from '@srcbook/shared';

import { FilesProvider } from '@/components/apps/use-files';
import { PreviewProvider } from '@/components/apps/use-preview';
import { LogsProvider } from '@/components/apps/use-logs';
import { PackageJsonProvider } from '@/components/apps/use-package-json';
import { AppProvider, useApp } from '@/components/apps/use-app';
import { VersionProvider } from '@/components/apps/use-version';

export function AppContext() {
  const { app } = useLoaderData() as { app: AppType };

  return (
    <AppProvider key={app.id} app={app}>
      <Outlet />
    </AppProvider>
  );
}

type AppLoaderDataType = {
  rootDirEntries: DirEntryType;
  initialOpenedFile: FileType | null;
};

export function AppProviders(props: { children: React.ReactNode }) {
  const { initialOpenedFile, rootDirEntries } = useLoaderData() as AppLoaderDataType;

  const { channel } = useApp();

  return (
    <FilesProvider
      channel={channel}
      rootDirEntries={rootDirEntries}
      initialOpenedFile={initialOpenedFile}
    >
      <LogsProvider channel={channel}>
        <VersionProvider>
          <PackageJsonProvider channel={channel}>
            <PreviewProvider channel={channel}>{props.children}</PreviewProvider>
          </PackageJsonProvider>
        </VersionProvider>
      </LogsProvider>
    </FilesProvider>
  );
}

================
File: web/src/routes/apps/files-show.tsx
================
import { useFiles } from '@/components/apps/use-files';
import { CodeEditor } from '@/components/apps/editor';
import AppLayout from './layout';

export default function AppFilesShow() {
  const { openedFile, updateFile } = useFiles();

  /* TODO: Handle 404s */

  return (
    <AppLayout activeTab="code" activePanel="explorer">
      {openedFile && (
        <CodeEditor
          path={openedFile.path}
          source={openedFile.source}
          onChange={(source) => updateFile({ ...openedFile, source })}
        />
      )}
    </AppLayout>
  );
}

================
File: web/src/routes/apps/files.tsx
================
import { useNavigate } from 'react-router-dom';
import AppLayout from './layout';
import { getLastOpenedFile } from '@/components/apps/local-storage';
import { useApp } from '@/components/apps/use-app';
import { useEffect } from 'react';

export default function AppFiles() {
  const navigateTo = useNavigate();

  const { app } = useApp();

  useEffect(() => {
    const file = getLastOpenedFile(app.id);
    if (file) {
      navigateTo(`/apps/${app.id}/files/${encodeURIComponent(file.path)}`);
    }
  }, [app.id, navigateTo]);

  return (
    <AppLayout activeTab="code" activePanel="explorer">
      <div className="h-full flex items-center justify-center text-tertiary-foreground">
        Use the file explorer to open a file for editing
      </div>
    </AppLayout>
  );
}

================
File: web/src/routes/apps/layout.tsx
================
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import Sidebar, { type PanelType } from '@/components/apps/sidebar';
import BottomDrawer from '@/components/apps/bottom-drawer';
import { ChatPanel } from '@/components/chat';
import DiffModal from '@/components/apps/diff-modal';
import { FileDiffType } from '@srcbook/shared';
import Header, { type HeaderTab } from '@/components/apps/header';
import { useApp } from '@/components/apps/use-app';
import PackageInstallToast from '@/components/apps/package-install-toast';
import { usePackageJson } from '@/components/apps/use-package-json';
import InstallPackageModal from '@/components/install-package-modal';
import { useHotkeys } from 'react-hotkeys-hook';

export default function AppLayout(props: {
  activeTab: HeaderTab;
  activePanel: PanelType | null;
  children: React.ReactNode;
}) {
  const navigateTo = useNavigate();
  const { app } = useApp();

  const { installing, npmInstall, output, showInstallModal, setShowInstallModal } =
    usePackageJson();

  const [diffModalProps, triggerDiffModal] = useState<{
    files: FileDiffType[];
    onUndoAll: () => void;
  } | null>(null);

  useHotkeys('mod+i', () => {
    setShowInstallModal(true);
  });

  return (
    <>
      {diffModalProps && <DiffModal {...diffModalProps} onClose={() => triggerDiffModal(null)} />}
      <InstallPackageModal
        open={showInstallModal}
        setOpen={setShowInstallModal}
        installing={installing}
        npmInstall={npmInstall}
        output={output}
      />
      <Header
        tab={props.activeTab}
        onChangeTab={(tab) => {
          if (tab === 'preview') {
            navigateTo(`/apps/${app.id}`);
          } else {
            navigateTo(`/apps/${app.id}/files`);
          }
        }}
        className="shrink-0 h-12 max-h-12"
      />
      <div className="h-[calc(100vh-3rem)] flex">
        <Sidebar initialPanel={props.activePanel} />
        <div className="grow shrink flex flex-col w-0">
          <div className="relative grow shrink flex flex-col w-full overflow-hidden">
            <PackageInstallToast />
            <div className="w-full flex-1 overflow-auto">{props.children}</div>
          </div>
          <BottomDrawer />
        </div>
        <ChatPanel triggerDiffModal={triggerDiffModal} />
      </div>
    </>
  );
}

================
File: web/src/routes/apps/loaders.tsx
================
import { type LoaderFunctionArgs } from 'react-router-dom';

import { loadApp, loadDirectory, loadFile } from '@/clients/http/apps';

export async function index({ params }: LoaderFunctionArgs) {
  const { data: app } = await loadApp(params.id!);
  return { app };
}

export async function preview({ params }: LoaderFunctionArgs) {
  const { data: rootDirEntries } = await loadDirectory(params.id!, '.');
  return { rootDirEntries };
}

export async function filesShow({ params }: LoaderFunctionArgs) {
  const path = decodeURIComponent(params.path!);

  const [{ data: rootDirEntries }, { data: file }] = await Promise.all([
    loadDirectory(params.id!, '.'),
    loadFile(params.id!, path),
  ]);

  return { initialOpenedFile: file, rootDirEntries };
}

================
File: web/src/routes/apps/preview.tsx
================
import { useEffect, useState } from 'react';
import { usePreview } from '@/components/apps/use-preview';
import { usePackageJson } from '@/components/apps/use-package-json';
import { useLogs } from '@/components/apps/use-logs';
import { Loader2Icon } from 'lucide-react';
import { Button } from '@srcbook/components';
import AppLayout from './layout';

export default function AppPreview() {
  return (
    <AppLayout activeTab="preview" activePanel={null}>
      <Preview />
    </AppLayout>
  );
}

function Preview() {
  const { url, status, start, exitCode } = usePreview();
  const { nodeModulesExists } = usePackageJson();
  const { togglePane } = useLogs();

  const [startAttempted, setStartAttempted] = useState(false);
  useEffect(() => {
    if (nodeModulesExists && status === 'stopped' && !startAttempted) {
      setStartAttempted(true);
      start();
    }
  }, [nodeModulesExists, status, start, startAttempted]);

  if (nodeModulesExists === false) {
    return (
      <div className="flex justify-center items-center w-full h-full">
        <span className="text-tertiary-foreground">Dependencies not installed</span>
      </div>
    );
  }

  switch (status) {
    case 'connecting':
    case 'booting':
      return (
        <div className="flex justify-center items-center w-full h-full">
          <Loader2Icon size={18} className="animate-spin" />
        </div>
      );
    case 'running':
      if (url === null) {
        return;
      }

      return (
        <div className="w-full h-full">
          <iframe className="w-full h-full" src={url} title="App preview" />
        </div>
      );
    case 'stopped':
      return (
        <div className="flex justify-center items-center w-full h-full">
          {exitCode === null || exitCode === 0 ? (
            <span className="text-tertiary-foreground">Preview server is stopped.</span>
          ) : (
            <div className="flex flex-col gap-6 items-center border border-border p-8 border-dashed rounded-md">
              <span className="text-red-400">Preview server exited with an error.</span>
              <Button variant="secondary" onClick={togglePane}>
                View logs
              </Button>
            </div>
          )}
        </div>
      );
  }
}

================
File: web/src/routes/home.tsx
================
import { useNavigate, useLoaderData, useRevalidator } from 'react-router-dom';
import { AppType, CodeLanguageType, TitleCellType } from '@srcbook/shared';
import {
  getConfig,
  createSession,
  loadSessions,
  createSrcbook,
  importSrcbook,
  loadSrcbookExamples,
} from '@/lib/server';
import type { ExampleSrcbookType, SessionType } from '@/types';
import { useState } from 'react';
import { ImportSrcbookModal } from '@/components/import-export-srcbook-modal';
import GenerateSrcbookModal from '@/components/generate-srcbook-modal';
import {
  MainCTACard,
  AppCard,
  SrcbookCard,
  GenerateSrcbookButton,
  CreateSrcbookButton,
  ImportSrcbookButton,
  CreateAppButton,
} from '@/components/srcbook-cards';
import DeleteSrcbookModal from '@/components/delete-srcbook-dialog';
import { ExternalLink } from 'lucide-react';
import { Button } from '@srcbook/components/src/components/ui/button';
import MailingListCard from '@/components/mailing-list-card';
import CreateAppModal from '@/components/apps/create-modal';
import { createApp, loadApps } from '@/clients/http/apps';
import DeleteAppModal from '@/components/delete-app-dialog';
import Onboarding from '@/components/onboarding';
import { useSettings } from '@/components/use-settings';

export async function loader() {
  const [{ result: config }, { result: srcbooks }, { result: examples }, { data: apps }] =
    await Promise.all([getConfig(), loadSessions(), loadSrcbookExamples(), loadApps('desc')]);

  return {
    defaultLanguage: config.defaultLanguage,
    baseDir: config.baseDir,
    srcbooks,
    examples,
    config,
    apps,
  };
}

type HomeLoaderDataType = {
  apps: AppType[];
  baseDir: string;
  srcbooks: SessionType[];
  examples: ExampleSrcbookType[];
  defaultLanguage: CodeLanguageType;
};

export default function Home() {
  const { apps, defaultLanguage, baseDir, srcbooks, examples } =
    useLoaderData() as HomeLoaderDataType;
  const navigate = useNavigate();

  const { revalidate } = useRevalidator();

  const [showImportSrcbookModal, setShowImportSrcbookModal] = useState(false);
  const [showGenSrcbookModal, setShowGenSrcbookModal] = useState(false);
  const [showDelete, setShowDelete] = useState(false);
  const [srcbookToDelete, setSrcbookToDelete] = useState<SessionType | undefined>(undefined);

  const [appToDelete, setAppToDelete] = useState<AppType | null>(null);
  const [showCreateAppModal, setShowCreateAppModal] = useState(false);

  const { aiEnabled } = useSettings();

  function onDeleteSrcbook(srcbook: SessionType) {
    setSrcbookToDelete(srcbook);
    setShowDelete(true);
  }

  async function openSrcbook(path: string) {
    const { result: srcbook } = await createSession({ path });
    navigate(`/srcbooks/${srcbook.id}`);
  }

  async function onCreateSrcbook(language: CodeLanguageType) {
    const { result } = await createSrcbook({ path: baseDir, name: 'Untitled', language: language });
    openSrcbook(result.path);
  }

  async function onCreateApp(name: string, prompt?: string) {
    const { data: app } = await createApp({ name, prompt });
    navigate(`/apps/${app.id}`);
  }

  async function openExampleSrcbook(example: ExampleSrcbookType) {
    const { result } = await importSrcbook({ path: example.path });
    openSrcbook(result.dir);
  }

  if (!aiEnabled) {
    return <Onboarding />;
  }

  return (
    <div className="divide-y divide-border space-y-8 pb-10">
      {showCreateAppModal && (
        <CreateAppModal onClose={() => setShowCreateAppModal(false)} onCreate={onCreateApp} />
      )}
      {appToDelete && (
        <DeleteAppModal
          app={appToDelete}
          onClose={() => setAppToDelete(null)}
          onDeleted={() => {
            revalidate();
            setAppToDelete(null);
          }}
        />
      )}
      <DeleteSrcbookModal
        open={showDelete}
        onOpenChange={setShowDelete}
        session={srcbookToDelete}
      />
      <GenerateSrcbookModal
        open={showGenSrcbookModal}
        setOpen={setShowGenSrcbookModal}
        openSrcbook={openSrcbook}
      />
      <ImportSrcbookModal open={showImportSrcbookModal} onOpenChange={setShowImportSrcbookModal} />

      <div>
        <h4 className="h4 mx-auto mb-6">Apps</h4>
        <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-6">
          <CreateAppButton
            defaultLanguage={defaultLanguage}
            onClick={() => setShowCreateAppModal(true)}
          />
          {apps.map((app) => (
            <AppCard
              key={app.id}
              name={app.name}
              onClick={() => navigate(`/apps/${app.id}`)}
              onDelete={() => setAppToDelete(app)}
            />
          ))}
        </div>
      </div>

      <div>
        <h4 className="h4 mx-auto mt-8 mb-6">New Notebook</h4>
        <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-6">
          <CreateSrcbookButton defaultLanguage={defaultLanguage} onSubmit={onCreateSrcbook} />
          <GenerateSrcbookButton onClick={() => setShowGenSrcbookModal(true)} />
          <ImportSrcbookButton onClick={() => setShowImportSrcbookModal(true)} />
        </div>
      </div>

      {srcbooks.length > 0 && (
        <div>
          <h4 className="h4 mx-auto mt-8 mb-6">Your Notebooks</h4>
          <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
            {srcbooks
              .sort((a, b) => b.openedAt - a.openedAt)
              .map((srcbook) => (
                <SrcbookCard
                  key={srcbook.id}
                  title={(srcbook.cells[0] as TitleCellType).text}
                  running={srcbook.cells.some((c) => c.type === 'code' && c.status === 'running')}
                  language={srcbook.language}
                  cellCount={srcbook.cells.length}
                  onClick={() => navigate(`/srcbooks/${srcbook.id}`)}
                  onDelete={() => onDeleteSrcbook(srcbook)}
                />
              ))}
          </div>
        </div>
      )}

      {examples.length > 0 && (
        <div>
          <h4 className="h4 mt-8 mb-6">Explore</h4>
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
            {examples.map((example) => (
              <MainCTACard
                key={example.id}
                srcbook={example}
                onClick={() => openExampleSrcbook(example)}
              />
            ))}
          </div>

          <div className="mt-8 flex justify-center">
            <a href="https://hub.srcbook.com" target="_blank">
              <Button size="lg" variant="secondary">
                <span className="mr-1.5">Explore all in the Hub</span>
                <ExternalLink size={16} />
              </Button>
            </a>
          </div>
        </div>
      )}
      <MailingListCard />
    </div>
  );
}

================
File: web/src/routes/secrets.tsx
================
import { useRef, useState } from 'react';
import { useHotkeys } from 'react-hotkeys-hook';
import { cn, isValidSecretName } from '@/lib/utils.ts';
import { getSecrets } from '@/lib/server';
import { type SecretWithAssociatedSessions } from '@srcbook/shared';
import { Info, Trash2, Eye, EyeOff } from 'lucide-react';
import { Form, useLoaderData, useRevalidator } from 'react-router-dom';
import { Input } from '@srcbook/components/src/components/ui/input';
import { Button } from '@srcbook/components/src/components/ui/button';
import { updateSecret, createSecret, deleteSecret } from '@/lib/server';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@srcbook/components/src/components/ui/dialog';

async function loader() {
  const { result } = await getSecrets();
  return { secrets: result };
}

function Secrets() {
  const { secrets } = useLoaderData() as { secrets: Array<SecretWithAssociatedSessions> };

  const [error, _setError] = useState<string | null>(null);

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const timeoutRef = useRef<any>(null);

  function setError(message: string | null, clearAfter: number | null = null) {
    if (message === null) {
      _setError(null);
      return;
    }

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    _setError(message);

    if (clearAfter) {
      timeoutRef.current = setTimeout(() => {
        _setError(null);
      }, clearAfter);
    }
  }

  return (
    <>
      <h4 className="h4 mx-auto mb-6">Secrets</h4>

      <p>
        Secrets are a safe way utilize API tokens or other private credentials in Srcbooks. These
        are available in code cells via <code className="code">process.env.SECRET_NAME</code>.
      </p>

      <div className="mt-8 space-y-3">
        <NewSecretForm setError={setError} />
        {error && <ErrorMessage message={error} />}
        <SecretsTable secrets={secrets} setError={setError} />
      </div>
    </>
  );
}

function ErrorMessage(props: { message: string }) {
  return (
    <div className="w-full flex items-center justify-center">
      <p className="text-sm max-w-md flex items-center gap-1.5 pl-[10px] pr-3 py-2 bg-error text-error-foreground font-medium rounded-sm">
        <Info size={16} className="shrink-0" />
        {props.message}
      </p>
    </div>
  );
}

function SecretsTable(props: {
  secrets: Array<SecretWithAssociatedSessions>;
  setError: (message: string | null, clearAfter?: number | null) => void;
}) {
  const revalidator = useRevalidator();

  async function onUpdate(name: string, updatedName: string, updatedValue: string) {
    // TODO handle errors
    await updateSecret({
      previousName: name,
      name: updatedName,
      value: updatedValue,
    });

    revalidator.revalidate();
  }

  async function onDelete(name: string) {
    await deleteSecret({ name });
    revalidator.revalidate();
  }

  const sortedSecrets = props.secrets.sort(({ name: nameA }, { name: nameB }) =>
    nameA.localeCompare(nameB),
  );

  return (
    sortedSecrets.length > 0 && (
      <div className="relative w-full overflow-auto">
        <table className="w-full space-y-2">
          <thead>
            <tr className="text-sm text-tertiary-foreground">
              <th className="h-10 pl-3 text-left font-medium align-middle">Name</th>
              <th className="h-10 pl-3 text-left font-medium align-middle">Value</th>
              <th className="h-10 pl-3 text-rightfont-medium align-middle w-[52px]"></th>
            </tr>
          </thead>
          <tbody>
            {sortedSecrets.map((secret) => (
              <SecretRow
                key={secret.name}
                name={secret.name}
                value={secret.value}
                onUpdate={onUpdate}
                onDelete={onDelete}
                setError={props.setError}
              />
            ))}
          </tbody>
        </table>
      </div>
    )
  );
}

function SecretRow(props: {
  name: string;
  value: string;
  onUpdate: (name: string, updatedName: string, updatedValue: string) => void;
  onDelete: (name: string) => void;
  setError: (message: string | null, clearAfter?: number | null) => void;
}) {
  const [open, setOpen] = useState(false);
  const [name, setName] = useState(props.name);
  const [value, setValue] = useState(props.value);

  const nameRef = useRef<HTMLInputElement>(null);
  const passwordRef = useRef<HTMLInputElement>(null);

  const [hovering, setHovering] = useState(false);
  const [show, setShow] = useState(false);

  function onNameKeydown(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === 'Enter') {
      e.preventDefault();
      e.stopPropagation();
      nameRef.current?.blur();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      e.stopPropagation();
      // Revert to original name
      setName(props.name);
      // Timeout needed for this component to re-render before
      // we blur, otherwise it'll use an old state value rather than
      // the value we just set above.
      setTimeout(() => nameRef.current?.blur(), 10);
    }
  }

  function onPasswordKeydown(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === 'Enter') {
      e.preventDefault();
      e.stopPropagation();
      passwordRef.current?.blur();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      e.stopPropagation();
      // Revert to original value
      setValue(props.value);
      // Timeout needed for this component to re-render before
      // we blur, otherwise it'll use an old state value rather than
      // the value we just set above.
      setTimeout(() => passwordRef.current?.blur(), 10);
    }
  }

  function onBlur() {
    if (isValidSecretName(name)) {
      props.onUpdate(props.name, name, value);
    } else {
      props.setError(
        'Secret names must be uppercase and can only contain letters, numbers, and underscores.',
        5000,
      );
      setName(props.name);
    }
  }

  return (
    <tr
      className="transition-all group"
      onMouseEnter={() => setHovering(true)}
      onMouseLeave={() => setHovering(false)}
    >
      <Dialog open={open} onOpenChange={setOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>
              Delete <code className="code">{name}</code>
            </DialogTitle>
            <DialogDescription>Are you sure you want to delete this secret?</DialogDescription>
            <div className="flex w-full justify-end items-center gap-2 pt-4 bg-background">
              <Button
                variant="secondary"
                onClick={() => {
                  setOpen(false);
                }}
              >
                Cancel
              </Button>
              <Button variant="destructive" onClick={() => props.onDelete(name)}>
                Delete
              </Button>
            </div>
          </DialogHeader>
        </DialogContent>
      </Dialog>
      <td className="h-10 pr-3 text-left align-middle lg:w-[434px]">
        <Input
          ref={nameRef}
          value={name}
          onKeyDown={onNameKeydown}
          onChange={(e) => setName(e.currentTarget.value.toUpperCase())}
          autoComplete="off"
          onBlur={onBlur}
          className="border-transparent group-hover:border-border group-focus-within:border-border"
        />
      </td>
      <td className="h-10 text-left align-middle relative">
        <Input
          ref={passwordRef}
          type={show ? 'text' : 'password'}
          autoComplete="off"
          value={value}
          onKeyDown={onPasswordKeydown}
          onChange={(e) => setValue(e.currentTarget.value)}
          required
          onBlur={onBlur}
          className="border-transparent group-hover:border-border group-focus-within:border-border pr-8"
        />
        {show ? (
          <EyeOff
            size={14}
            className={cn(
              'absolute right-3 top-3 cursor-pointer opacity-80 bg-background',
              !hovering && 'hidden',
            )}
            onClick={() => setShow(false)}
          />
        ) : (
          <Eye
            size={14}
            className={cn(
              'absolute right-3 top-3 cursor-pointer opacity-80 bg-background',
              !hovering && 'hidden',
            )}
            onClick={() => setShow(true)}
          />
        )}
      </td>
      <td className="h-10 pl-3 text-right align-middle w-[52px]">
        <Button variant="icon" onClick={() => setOpen(true)}>
          <Trash2 size={18} />
        </Button>
      </td>
    </tr>
  );
}

function NewSecretForm(props: {
  setError: (message: string | null, clearAfter?: number | null) => void;
}) {
  useHotkeys(
    'mod+enter',
    () => {
      onSubmit();
    },
    { enableOnFormTags: ['input'] },
  );

  const revalidator = useRevalidator();

  const [name, setName] = useState('');
  const [value, setValue] = useState('');

  async function onSubmit(e?: React.FormEvent<HTMLFormElement>) {
    if (e) {
      e.preventDefault();
    }

    if (!isValidSecretName(name)) {
      props.setError(
        'Secret names must be uppercase and can only contain letters, numbers, and underscores.',
        5000,
      );
      return;
    }

    await createSecret({ name, value });
    setName('');
    setValue('');
    revalidator.revalidate();
  }

  return (
    <Form method="post" className="flex items-center gap-3" onSubmit={onSubmit}>
      <Input
        type="text"
        name="name"
        required
        autoComplete="off"
        placeholder="SECRET_NAME"
        value={name}
        onChange={(e) => setName(e.currentTarget.value.toUpperCase())}
      />

      <Input
        type="text"
        name="value"
        required
        autoComplete="off"
        placeholder="secret-value"
        value={value}
        onChange={(e) => setValue(e.currentTarget.value)}
      />

      <Button type="submit" disabled={!name || !value}>
        Create
      </Button>
    </Form>
  );
}

Secrets.loader = loader;
export default Secrets;

================
File: web/src/routes/session.tsx
================
import { useCallback, useEffect, useReducer, useRef, useState } from 'react';
import { useLoaderData, type LoaderFunctionArgs } from 'react-router-dom';
import {
  CellType,
  CellOutputPayloadType,
  CellUpdatedPayloadType,
  CellUpdateAttrsType,
  TsServerCellDiagnosticsPayloadType,
  CodeLanguageType,
  MarkdownCellType,
  CodeCellType,
  TitleCellType,
  TsServerCellSuggestionsPayloadType,
} from '@srcbook/shared';
import { loadSession, loadSessions, getConfig } from '@/lib/server';
import type { SessionType, SettingsType } from '@/types';
import { GenerateAICellType, OutputType } from '@srcbook/components/src/types';
import { TitleCell, MarkdownCell } from '@srcbook/components';
import ControlledCodeCell from '@/components/cells/code';
import GenerateAiCell from '@/components/cells/generate-ai';
import SessionMenu, { SESSION_MENU_PANELS, Panel } from '@/components/session-menu';
import { Button } from '@srcbook/components/src/components/ui/button';
import { SessionChannel } from '@/clients/websocket';
import { CellsProvider, useCells } from '@srcbook/components/src/components/use-cell';
import { cn } from '@/lib/utils';
import { useHotkeys } from 'react-hotkeys-hook';
import InstallPackageModal from '@/components/install-package-modal';
import { PackageJsonProvider, usePackageJson } from '@/components/use-package-json';
import { SessionNavbar } from '@/components/navbar';
import { toast } from 'sonner';
import { TsConfigProvider } from '@/components/use-tsconfig-json';
import { VITE_SRCBOOK_DEBUG_RENDER_SESSION_AS_READ_ONLY } from '@/lib/environment';

async function loader({ params }: LoaderFunctionArgs) {
  const [{ result: config }, { result: srcbooks }, { result: session }] = await Promise.all([
    getConfig(),
    loadSessions(),
    loadSession({ id: params.id! }),
  ]);
  return { config, srcbooks, session };
}

type SessionLoaderDataType = {
  config: SettingsType;
  srcbooks: Array<SessionType>;
  session: SessionType;
};

function SessionPage() {
  const { config, srcbooks, session } = useLoaderData() as SessionLoaderDataType;

  // Because we use refs for our state, we need a way to trigger
  // component re-renders when the ref state changes.
  //
  // https://legacy.reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate
  //
  const [, forceComponentRerender] = useReducer((x) => x + 1, 0);

  const channelRef = useRef(SessionChannel.create(session.id));
  const connectedSessionIdRef = useRef<SessionType['id'] | null>(null);
  const connectedSessionLanguageRef = useRef<SessionType['language'] | null>(null);
  const channel = channelRef.current;

  useEffect(() => {
    if (connectedSessionIdRef.current === session.id) {
      return;
    }

    const oldChannel = channelRef.current;

    // Disconnect from the previously connected session
    if (connectedSessionIdRef.current) {
      oldChannel.unsubscribe();

      if (connectedSessionLanguageRef.current === 'typescript') {
        oldChannel.push('tsserver:stop', {});
      }
    }

    // Reconnect to the new session
    channelRef.current = SessionChannel.create(session.id);
    connectedSessionIdRef.current = session.id;
    connectedSessionLanguageRef.current = session.language;

    const channel = channelRef.current;

    channel.subscribe();

    if (session.language === 'typescript') {
      channel.push('tsserver:start', {});
    }

    forceComponentRerender();
  }, [session.id, session.language, forceComponentRerender]);

  return (
    <CellsProvider cells={session.cells}>
      <PackageJsonProvider channel={channel}>
        <TsConfigProvider session={session} channel={channel}>
          {VITE_SRCBOOK_DEBUG_RENDER_SESSION_AS_READ_ONLY ? (
            <Session readOnly session={session} srcbooks={srcbooks} config={config} />
          ) : (
            <Session session={session} channel={channel} srcbooks={srcbooks} config={config} />
          )}
        </TsConfigProvider>
      </PackageJsonProvider>
    </CellsProvider>
  );
}

type SessionPropsBase = {
  session: SessionType;
  srcbooks: Array<SessionType>;
  config: SettingsType;
};

type SessionProps =
  | ({ readOnly: true } & SessionPropsBase)
  | ({ readOnly?: false; channel: SessionChannel } & SessionPropsBase);

function Session(props: SessionProps) {
  const { readOnly, session, srcbooks, config } = props;
  const channel = !readOnly ? props.channel : null;

  const {
    cells: allCells,
    updateCell,
    removeCell,
    createCodeCell,
    createMarkdownCell,
    createGenerateAiCell,
    setOutput,
    setTsServerDiagnostics,
    setTsServerSuggestions,
  } = useCells();

  const {
    npmInstall,
    failed: dependencyInstallFailed,
    outdated: outdatedDependencies,
    installing: installingDependencies,
    output: dependencyInstallOutput,
  } = usePackageJson();

  const [depsInstallModalOpen, setDepsInstallModalOpen] = useState(false);
  const [[selectedPanelName, selectedPanelOpen], setSelectedPanelNameAndOpen] = useState<
    [Panel['name'], boolean]
  >([SESSION_MENU_PANELS[0]!.name, false]);

  const isPanelOpen = useCallback(
    (name: Panel['name']) => selectedPanelOpen && selectedPanelName === name,
    [selectedPanelOpen, selectedPanelName],
  );

  useHotkeys('mod+;', () => {
    if (!isPanelOpen('packages')) {
      setSelectedPanelNameAndOpen(['packages', true]);
    }
  });

  async function onDeleteCell(cell: CellType | GenerateAICellType) {
    if (!channel) {
      return;
    }
    if (cell.type !== 'code' && cell.type !== 'markdown') {
      throw new Error(`Cannot delete cell of type '${cell.type}'`);
    }

    // Optimistically delete cell
    removeCell(cell);

    channel.push('cell:delete', {
      cellId: cell.id,
    });
  }

  useEffect(() => {
    if (!channel) {
      return;
    }
    const callback = (payload: CellOutputPayloadType) => {
      setOutput(payload.cellId, payload.output);
    };

    channel.on('cell:output', callback);

    return () => channel.off('cell:output', callback);
  }, [channel, setOutput]);

  useEffect(() => {
    if (!channel) {
      return;
    }
    const callback = (payload: TsServerCellDiagnosticsPayloadType) => {
      setTsServerDiagnostics(payload.cellId, payload.diagnostics);
    };

    channel.on('tsserver:cell:diagnostics', callback);

    return () => channel.off('tsserver:cell:diagnostics', callback);
  }, [channel, setTsServerDiagnostics]);

  useEffect(() => {
    if (!channel) {
      return;
    }
    const callback = (payload: TsServerCellSuggestionsPayloadType) => {
      setTsServerSuggestions(payload.cellId, payload.diagnostics);
    };

    channel.on('tsserver:cell:suggestions', callback);

    return () => channel.off('tsserver:cell:suggestions', callback);
  }, [channel, setTsServerSuggestions]);

  useEffect(() => {
    if (!channel) {
      return;
    }
    const callback = (payload: CellUpdatedPayloadType) => {
      updateCell(payload.cell);
    };

    channel.on('cell:updated', callback);

    return () => channel.off('cell:updated', callback);
  }, [channel, updateCell]);

  function updateCellOnServer(cell: CellType, updates: CellUpdateAttrsType) {
    if (!channel) {
      return;
    }
    channel.push('cell:update', {
      cellId: cell.id,
      updates,
    });
  }

  async function createNewCell(type: 'code' | 'markdown' | 'generate-ai', index: number) {
    if (!channel) {
      return;
    }

    // First, create the cell on client.
    // Then, push state to server, _only_ for code or markdown cells. AI generation is a client side only cell.
    // TODO: Handle potential errors (eg, rollback optimistic client creation if there are errors)
    let cell;
    switch (type) {
      case 'code':
        cell = createCodeCell(index, session.language);
        channel.push('cell:create', { index, cell });
        break;
      case 'markdown':
        cell = createMarkdownCell(index);
        channel.push('cell:create', { index, cell });
        break;
      case 'generate-ai':
        cell = createGenerateAiCell(index);
        break;
    }
  }

  async function insertGeneratedCells(idx: number, cells: Array<CodeCellType | MarkdownCellType>) {
    if (!channel) {
      return;
    }

    for (let i = 0; i < cells.length; i++) {
      const cell = cells[i];
      if (!cell) continue;
      const insertIdx = idx + i;
      let newCell;
      switch (cell.type) {
        case 'code':
          newCell = createCodeCell(insertIdx, session.language, cell);
          break;
        case 'markdown':
          newCell = createMarkdownCell(insertIdx, cell);
          break;
      }
      channel.push('cell:create', { index: insertIdx, cell: newCell });
    }
  }

  // TOOD: We need to stop treating titles and package.json as cells.
  const [titleCellUncasted, _packageJsonCell, ...remainingCells] = allCells;
  const titleCell = titleCellUncasted as TitleCellType;
  const cells = remainingCells as (MarkdownCellType | CodeCellType | GenerateAICellType)[];

  useEffect(() => {
    let result: () => void = () => {};

    if (depsInstallModalOpen || isPanelOpen('packages')) {
      return result;
    }

    if (installingDependencies) {
      const toastId = toast.loading('Installing dependencies...');
      result = () => toast.dismiss(toastId);
    } else if (dependencyInstallFailed) {
      const toastId = toast.error('Failed to install dependencies', {
        duration: 10000,
        action: {
          label: 'Try again',
          onClick: () => {
            setSelectedPanelNameAndOpen(['settings', true]);
            setTimeout(npmInstall, 100);
          },
        },
      });
      result = () => toast.dismiss(toastId);
    } else if (outdatedDependencies) {
      toast.warning('Packages need to be installed', {
        duration: 10000,
        action: {
          label: 'Install',
          onClick: () => {
            // If outdatedDependencies is an array, it usually menas those packages are not present
            // inside of package.json yet. Thus we must specifically install them by name so they are
            // installed and added to package.json. Otherwise, we just need to install what is already
            // listed inside of package.json.
            if (Array.isArray(outdatedDependencies)) {
              npmInstall(outdatedDependencies);
            } else {
              npmInstall();
            }
          },
        },
      });
    }

    return result;
  }, [
    outdatedDependencies,
    installingDependencies,
    dependencyInstallFailed,
    isPanelOpen,
    depsInstallModalOpen,
    npmInstall,
  ]);

  return (
    <div className="flex flex-col">
      <SessionNavbar
        readOnly={readOnly}
        session={session}
        srcbooks={srcbooks}
        baseDir={config.baseDir}
        title={titleCell.text}
      />

      <div className="flex mt-12">
        {!readOnly ? (
          <PackageInstallModal
            open={depsInstallModalOpen}
            onOpenChange={setDepsInstallModalOpen}
            installing={installingDependencies}
            output={dependencyInstallOutput}
            npmInstall={npmInstall}
          />
        ) : null}
        {readOnly ? (
          <SessionMenu
            readOnly
            session={session}
            selectedPanelName={selectedPanelName}
            selectedPanelOpen={selectedPanelOpen}
            onChangeSelectedPanelNameAndOpen={setSelectedPanelNameAndOpen}
          />
        ) : (
          <SessionMenu
            session={session}
            selectedPanelName={selectedPanelName}
            selectedPanelOpen={selectedPanelOpen}
            onChangeSelectedPanelNameAndOpen={setSelectedPanelNameAndOpen}
            openDepsInstallModal={() => setDepsInstallModalOpen(true)}
            channel={props.channel}
          />
        )}

        <div className="grow shrink lg:px-0 pb-28">
          <div className="max-w-[800px] mx-auto my-12 px-[32px]">
            {readOnly ? (
              <TitleCell readOnly cell={titleCell} />
            ) : (
              <TitleCell
                cell={titleCell}
                updateCellOnClient={updateCell}
                updateCellOnServer={updateCellOnServer}
              />
            )}

            {cells.map((cell, idx) => (
              <div key={cell.id}>
                {readOnly ? (
                  <div className="h-5" />
                ) : (
                  <InsertCellDivider
                    language={session.language}
                    createCodeCell={() => createNewCell('code', idx + 2)}
                    createMarkdownCell={() => createNewCell('markdown', idx + 2)}
                    createGenerateAiCodeCell={() => createNewCell('generate-ai', idx + 2)}
                  />
                )}

                {cell.type === 'code' && readOnly && (
                  <ControlledCodeCell readOnly cell={cell} session={session} />
                )}
                {cell.type === 'code' && !readOnly && (
                  <ControlledCodeCell
                    cell={cell}
                    session={session}
                    channel={props.channel}
                    updateCellOnServer={updateCellOnServer}
                    onDeleteCell={onDeleteCell}
                  />
                )}

                {cell.type === 'markdown' && readOnly && <MarkdownCell readOnly cell={cell} />}
                {cell.type === 'markdown' && !readOnly && (
                  <MarkdownCell
                    cell={cell}
                    updateCellOnClient={updateCell}
                    updateCellOnServer={updateCellOnServer}
                    onDeleteCell={onDeleteCell}
                  />
                )}

                {cell.type === 'generate-ai' && !readOnly && (
                  <GenerateAiCell
                    cell={cell}
                    session={session}
                    insertIdx={idx + 2}
                    onSuccess={insertGeneratedCells}
                  />
                )}
              </div>
            ))}

            {/* There is always an insert cell divider after the last cell */}
            {!readOnly ? (
              <InsertCellDivider
                language={session.language}
                createCodeCell={() => createNewCell('code', allCells.length)}
                createMarkdownCell={() => createNewCell('markdown', allCells.length)}
                createGenerateAiCodeCell={() => createNewCell('generate-ai', allCells.length)}
                className={cn('h-14', cells.length === 0 && 'opacity-100')}
              />
            ) : null}
          </div>
        </div>
      </div>
    </div>
  );
}

function InsertCellDivider(props: {
  createCodeCell: () => void;
  createMarkdownCell: () => void;
  createGenerateAiCodeCell: () => void;
  language: CodeLanguageType;
  className?: string;
}) {
  return (
    <div
      className={cn(
        'h-5 relative z-10 opacity-0 hover:opacity-100 transition-opacity',
        props.className,
      )}
    >
      <div className="h-full px-3 flex flex-col justify-center">
        <div className="w-full h-[1px] bg-border"></div>
      </div>

      <div className="absolute top-0 w-full h-full flex items-center justify-center">
        <div className="flex mr-4 border rounded-md bg-background shadow">
          <Button
            variant="secondary"
            className="border-none rounded-md rounded-r-none"
            onClick={props.createCodeCell}
          >
            {props.language === 'javascript' ? 'JavaScript' : 'TypeScript'}
          </Button>
          <Button
            variant="secondary"
            className="border-none rounded-md rounded-l-none"
            onClick={props.createMarkdownCell}
          >
            Markdown
          </Button>
          <Button
            variant="secondary"
            className="border-none rounded-md rounded-l-none"
            onClick={props.createGenerateAiCodeCell}
          >
            Generate with AI
          </Button>
        </div>
      </div>
    </div>
  );
}

function PackageInstallModal(props: {
  open: boolean;
  onOpenChange: (value: boolean) => void;
  installing: boolean;
  npmInstall: (packages?: string[]) => void;
  output: OutputType[];
}) {
  const { open, onOpenChange, installing, npmInstall, output } = props;

  useHotkeys('mod+i', () => {
    if (!open) {
      onOpenChange(true);
    }
  });

  return (
    <InstallPackageModal
      open={open}
      setOpen={onOpenChange}
      installing={installing}
      npmInstall={npmInstall}
      output={output}
    />
  );
}

SessionPage.loader = loader;
export default SessionPage;

================
File: web/src/routes/settings.tsx
================
import { useEffect, useState } from 'react';
import { CircleCheck, Loader2, CircleX } from 'lucide-react';
import { aiHealthcheck, subscribeToMailingList } from '@/lib/server';
import { useSettings } from '@/components/use-settings';
import { AiProviderType, getDefaultModel, type CodeLanguageType } from '@srcbook/shared';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@srcbook/components/src/components/ui/select';
import { Input } from '@srcbook/components/src/components/ui/input';
import useTheme from '@srcbook/components/src/components/use-theme';
import { Switch } from '@srcbook/components/src/components/ui/switch';
import { Button } from '@srcbook/components/src/components/ui/button';
import { toast } from 'sonner';

function Settings() {
  const { updateConfig: updateConfigContext, defaultLanguage, subscriptionEmail } = useSettings();

  const isSubscribed = subscriptionEmail && subscriptionEmail !== 'dismissed';

  const [email, setEmail] = useState<string>(isSubscribed ? subscriptionEmail : '');

  const updateDefaultLanguage = (value: CodeLanguageType) => {
    updateConfigContext({ defaultLanguage: value });
  };

  const { theme, toggleTheme } = useTheme();

  const handleSubscribe = async () => {
    try {
      const response = await subscribeToMailingList(email);
      if (response.success) {
        await updateConfigContext({ subscriptionEmail: email });
        toast.success('Subscribed successfully!');
      } else {
        toast.error('There was an error subscribing to the mailing list. Please try again later.');
      }
    } catch (error) {
      toast.error('There was an error subscribing to the mailing list. Please try again later.');
      console.error('Subscription error:', error);
    }
  };

  return (
    <div>
      <h4 className="h4 mx-auto mb-6">Settings</h4>
      <div className="space-y-10">
        <div>
          <h2 className="text-base font-medium">Theme</h2>
          <label className="opacity-70 text-sm" htmlFor="theme-switch">
            Select light or dark mode for the Srcbook app.
          </label>
          <div className="flex items-center gap-2 mt-2">
            <Switch id="theme-switch" checked={theme === 'dark'} onCheckedChange={toggleTheme} />
            <label htmlFor="theme-switch">
              <span className="text-sm font-medium">Dark mode</span>
            </label>
          </div>
        </div>

        <div>
          <h2 className="text-base font-medium">Default Language</h2>
          <label className="opacity-70 block pb-3 text-sm" htmlFor="language-selector">
            The default language to use when creating new Srcbooks.
          </label>
          <Select onValueChange={updateDefaultLanguage}>
            <SelectTrigger id="language-selector" className="w-[180px]">
              <SelectValue
                placeholder={defaultLanguage === 'typescript' ? 'TypeScript' : 'JavaScript'}
              />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="typescript">TypeScript</SelectItem>
              <SelectItem value="javascript">JavaScript</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div>
          <h2 className="text-base font-medium">AI</h2>
          <div className="flex flex-col">
            <label className="opacity-70 text-sm pb-3" htmlFor="ai-provider-selector">
              Select your preferred LLM and enter your credentials to use Srcbook's AI features.
            </label>
          </div>
          <AiSettings />
        </div>

        <div>
          <h2 className="text-base font-medium">Get product updates</h2>
          <div>
            <label className="opacity-70 text-sm" htmlFor="mailing-list-email">
              Subscribe to our mailing list to get the latest updates, early access features, and
              expert tips delivered to your inbox.
            </label>
            <div className="flex gap-2 mt-3">
              <Input
                id="mailing-list-email"
                type="text"
                placeholder="Your email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
              <Button className="px-5" onClick={handleSubscribe}>
                {isSubscribed ? 'Update' : 'Subscribe'}
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

function AiInfoBanner() {
  const { aiEnabled, aiProvider } = useSettings();

  const fragments = (provider: AiProviderType) => {
    switch (provider) {
      case 'openai':
        return (
          <div className="flex items-center gap-10 bg-sb-yellow-20 text-sb-yellow-80 rounded-sm text-sm font-medium px-3 py-2">
            <p>API key required</p>
            <a href="https://platform.openai.com/api-keys" target="_blank" className="underline">
              Go to {aiProvider}
            </a>
          </div>
        );

      case 'anthropic':
        return (
          <div className="flex items-center gap-10 bg-sb-yellow-20 text-sb-yellow-80 rounded-sm text-sm font-medium px-3 py-2">
            <p>API key required</p>
            <a
              href="https://console.anthropic.com/settings/keys"
              target="_blank"
              className="underline"
            >
              Go to {aiProvider}
            </a>
          </div>
        );

      case 'Xai':
        return (
          <div className="flex items-center gap-10 bg-sb-yellow-20 text-sb-yellow-80 rounded-sm text-sm font-medium px-3 py-2">
            <p>API key required</p>
          </div>
        );

      case 'Gemini':
        return (
          <div className="flex items-center gap-10 bg-sb-yellow-20 text-sb-yellow-80 rounded-sm text-sm font-medium px-3 py-2">
            <p>API key required</p>
          </div>
        );

      case 'custom':
        return (
          <div className="flex items-center gap-10 bg-sb-yellow-20 text-sb-yellow-80 rounded-sm text-sm font-medium px-3 py-2">
            <p>Base URL required</p>
          </div>
        );
    }
  };

  return (
    <div className="flex items-center gap-1">
      {aiEnabled ? <TestAiButton /> : fragments(aiProvider)}
    </div>
  );
}

const TestAiButton = () => {
  const [state, setState] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');

  const TIMEOUT = 2500;
  useEffect(() => {
    if (state === 'success' || state === 'error') {
      const timeout = setTimeout(() => setState('idle'), TIMEOUT);
      return () => clearTimeout(timeout);
    }
  }, [state]);

  const check = () => {
    setState('loading');
    aiHealthcheck()
      .then((res) => {
        setState(res.error ? 'error' : 'success');
      })
      .catch((err) => {
        console.error(err);
        setState('error');
      });
  };
  return (
    <>
      {state === 'idle' && (
        <div>
          <button
            className="flex items-center gap-2 bg-secondary text-secondary-foreground border border-border hover:bg-muted hover:text-secondary-hover rounded-sm text-sm font-medium px-3 py-1"
            onClick={check}
          >
            Test AI config
          </button>
        </div>
      )}
      {state === 'loading' && (
        <div className="flex items-center gap-2 bg-secondary text-secondary-foreground border border-border hover:bg-muted hover:text-secondary-hover rounded-sm text-sm font-medium px-3 py-1">
          <Loader2 size={16} className="animate-spin" />
          <p>Testing</p>
        </div>
      )}
      {state === 'success' && (
        <div className="flex items-center gap-2 bg-sb-green-20 text-sb-green-80 rounded-sm text-sm font-medium px-3 py-1 w-fit">
          <CircleCheck size={16} />
          <p>Success</p>
        </div>
      )}
      {state === 'error' && (
        <div className="flex items-center gap-2 bg-error text-error-foreground rounded-sm text-sm font-medium px-3 py-1 w-fit">
          <CircleX size={16} />
          <p>Error (check logs)</p>
        </div>
      )}
    </>
  );
};

type AiSettingsProps = {
  saveButtonLabel?: string;
};

export function AiSettings({ saveButtonLabel }: AiSettingsProps) {
  const {
    aiProvider,
    aiModel,
    aiBaseUrl,
    openaiKey: configOpenaiKey,
    anthropicKey: configAnthropicKey,
    customApiKey: configCustomApiKey,
    xaiKey: configXaiKey,
    geminiKey: configGeminiKey,
    updateConfig: updateConfigContext,
  } = useSettings();

  const [openaiKey, setOpenaiKey] = useState<string>(configOpenaiKey ?? '');
  const [anthropicKey, setAnthropicKey] = useState<string>(configAnthropicKey ?? '');
  const [xaiKey, setXaiKey] = useState<string>(configXaiKey ?? '');
  const [geminiKey, setGeminiKey] = useState<string>(configGeminiKey ?? '');
  const [customApiKey, setCustomApiKey] = useState<string>(configCustomApiKey ?? '');
  const [model, setModel] = useState<string>(aiModel);
  const [baseUrl, setBaseUrl] = useState<string>(aiBaseUrl || '');

  const setAiProvider = (provider: AiProviderType) => {
    const model = getDefaultModel(provider);
    setModel(model);
    updateConfigContext({ aiProvider: provider, aiModel: model });
  };

  // Either the key from the server is null/undefined and the user entered input
  // or the key from the server is a string and the user entered input is different.
  const openaiKeySaveEnabled =
    (typeof configOpenaiKey === 'string' && openaiKey !== configOpenaiKey) ||
    ((configOpenaiKey === null || configOpenaiKey === undefined) && openaiKey.length > 0) ||
    model !== aiModel;

  const anthropicKeySaveEnabled =
    (typeof configAnthropicKey === 'string' && anthropicKey !== configAnthropicKey) ||
    ((configAnthropicKey === null || configAnthropicKey === undefined) &&
      anthropicKey.length > 0) ||
    model !== aiModel;

  const xaiKeySaveEnabled =
    (typeof configXaiKey === 'string' && xaiKey !== configXaiKey) ||
    ((configXaiKey === null || configXaiKey === undefined) && xaiKey.length > 0) ||
    model !== aiModel;

  const geminiKeySaveEnabled =
    (typeof configGeminiKey === 'string' && geminiKey !== configXaiKey) ||
    ((configGeminiKey === null || configGeminiKey === undefined) && geminiKey.length > 0) ||
    model !== aiModel;

  const customModelSaveEnabled =
    (typeof configCustomApiKey === 'string' && customApiKey !== configCustomApiKey) ||
    ((configCustomApiKey === null || configCustomApiKey === undefined) &&
      customApiKey.length > 0) ||
    (typeof aiBaseUrl === 'string' && baseUrl !== aiBaseUrl) ||
    ((aiBaseUrl === null || aiBaseUrl === undefined) && baseUrl.length > 0) ||
    model !== aiModel;

  return (
    <>
      <div className="flex items-center justify-between w-full mb-2 min-h-10">
        <div className="flex items-center gap-2">
          <Select onValueChange={setAiProvider}>
            <SelectTrigger id="ai-provider-selector" className="w-[180px]">
              <SelectValue placeholder={aiProvider} />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="openai">openai</SelectItem>
              <SelectItem value="anthropic">anthropic</SelectItem>
              <SelectItem value="Xai">Xai</SelectItem>
              <SelectItem value="Gemini">Gemini</SelectItem>
              <SelectItem value="custom">custom</SelectItem>
            </SelectContent>
          </Select>
          <Input
            name="aiModel"
            className="w-[200px]"
            placeholder="AI model"
            value={model}
            onChange={(e) => setModel(e.target.value)}
          />
        </div>
        <AiInfoBanner />
      </div>

      {aiProvider === 'openai' && (
        <div className="flex gap-2">
          <Input
            name="openaiKey"
            placeholder="openAI API key"
            type="password"
            value={openaiKey}
            onChange={(e) => setOpenaiKey(e.target.value)}
          />
          <Button
            className="px-5"
            onClick={() => updateConfigContext({ openaiKey, aiModel: model })}
            disabled={!openaiKeySaveEnabled}
          >
            {saveButtonLabel ?? 'Save'}
          </Button>
        </div>
      )}

      {aiProvider === 'anthropic' && (
        <div className="flex gap-2">
          <Input
            name="anthropicKey"
            placeholder="anthropic API key"
            type="password"
            value={anthropicKey}
            onChange={(e) => setAnthropicKey(e.target.value)}
          />
          <Button
            className="px-5"
            onClick={() => updateConfigContext({ anthropicKey, aiModel: model })}
            disabled={!anthropicKeySaveEnabled}
          >
            {saveButtonLabel ?? 'Save'}
          </Button>
        </div>
      )}

      {aiProvider === 'Xai' && (
        <div className="flex gap-2">
          <Input
            name="xaiKey"
            placeholder="xai API key"
            type="password"
            value={xaiKey}
            onChange={(e) => setXaiKey(e.target.value)}
          />
          <Button
            className="px-5"
            onClick={() => updateConfigContext({ xaiKey, aiModel: model })}
            disabled={!xaiKeySaveEnabled}
          >
            {saveButtonLabel ?? 'Save'}
          </Button>
        </div>
      )}

      {aiProvider === 'Gemini' && (
        <div className="flex gap-2">
          <Input
            name="geminiKey"
            placeholder="Gemini API key"
            type="password"
            value={geminiKey}
            onChange={(e) => setGeminiKey(e.target.value)}
          />
          <Button
            className="px-5"
            onClick={() => updateConfigContext({ geminiKey, aiModel: model })}
            disabled={!geminiKeySaveEnabled}
          >
            {saveButtonLabel ?? 'Save'}
          </Button>
        </div>
      )}

      {aiProvider === 'custom' && (
        <div>
          <p className="opacity-70 text-sm mb-4">
            If you want to use an openai-compatible model (for example when running local models
            with Ollama or using a third party like togetherAI), choose this option and set the
            baseUrl. Optionally add an API key if needed.
          </p>
          <div className="flex flex-col gap-2">
            <div className="flex gap-2">
              <Input
                name="baseUrl"
                placeholder="http://localhost:11434/v1"
                value={baseUrl}
                onChange={(e) => setBaseUrl(e.target.value)}
              />
              <Input
                name="customApiKey"
                placeholder="API key (optional)"
                type="password"
                value={customApiKey}
                onChange={(e) => setCustomApiKey(e.target.value)}
              />
            </div>
            <div className="flex justify-end">
              <Button
                className="px-5"
                onClick={() =>
                  updateConfigContext({ aiBaseUrl: baseUrl, customApiKey, aiModel: model })
                }
                disabled={!customModelSaveEnabled}
              >
                {saveButtonLabel ?? 'Save'}
              </Button>
            </div>
          </div>
        </div>
      )}
    </>
  );
}

export default Settings;

================
File: web/src/config.ts
================
// Expected to be defined in index.html
declare global {
  interface Window {
    SRCBOOK_CONFIG: {
      api: {
        host: string;
        origin: string;
      };
    };
  }
}

export default window.SRCBOOK_CONFIG;

================
File: web/src/error.tsx
================
import { Link } from 'react-router-dom';
import { useRouteError } from 'react-router-dom';

export default function ErrorPage() {
  const error = useRouteError() as { statusText: string; message: string };
  console.error(error);

  return (
    <div className="flex flex-col justify-center items-center h-screen w-full">
      <h1 className="text-xl font-bold">Oops!</h1>

      <p>
        Sorry, an unexpected error has occured:
        <span className="text-destructive italic"> {error.statusText || error.message}</span>
      </p>

      <Link to="/" className="text-accent underline underline-offset-2">
        go home
      </Link>
    </div>
  );
}

================
File: web/src/index.css
================
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&family=Instrument+Sans:ital,wght@0,400..700;1,400..700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --sb-core-0: 0 0% 100%;
    --sb-core-10: 210 33% 99%;
    --sb-core-20: 210 7% 95%;
    --sb-core-30: 204 7% 86%;
    --sb-core-40: 207 7% 76%;
    --sb-core-50: 205 7% 67%;
    --sb-core-60: 204 7% 59%;
    --sb-core-70: 203 7% 49%;
    --sb-core-80: 205 11% 40%;
    --sb-core-90: 204 16% 32%;
    --sb-core-100: 203 17% 26%;
    --sb-core-110: 204 17% 23%;
    --sb-core-120: 206 16% 19%;
    --sb-core-130: 203 17% 15%;
    --sb-core-140: 204 17% 11%;
    --sb-core-150: 206 18% 8%;
    --sb-core-160: 200 16% 4%;

    --sb-yellow-10: 33 100% 95%;
    --sb-yellow-20: 33 100% 90%;
    --sb-yellow-30: 33 97% 85%;
    --sb-yellow-40: 34 96% 81%;
    --sb-yellow-50: 35 95% 76%;
    --sb-yellow-60: 33 76% 69%;
    --sb-yellow-70: 35 31% 45%;
    --sb-yellow-80: 34 28% 32%;

    --sb-red-10: 0 100% 96%;
    --sb-red-20: 0 100% 86%;
    --sb-red-30: 0 100% 76%;
    --sb-red-40: 0 100% 66%;
    --sb-red-50: 0 66% 53%;
    --sb-red-60: 0 66% 41%;
    --sb-red-70: 0 74% 30%;
    --sb-red-80: 0 82% 20%;

    --sb-blue-10: 203 100% 95%;
    --sb-blue-20: 202 100% 84%;
    --sb-blue-30: 202 100% 73%;
    --sb-blue-40: 202 100% 61%;
    --sb-blue-50: 202 100% 50%;
    --sb-blue-60: 202 100% 40%;
    --sb-blue-70: 202 100% 30%;
    --sb-blue-80: 202 100% 20%;

    --sb-purple-10: 270 62% 96%;
    --sb-purple-20: 270 78% 91%;
    --sb-purple-60: 277 42% 57%;
    --sb-purple-70: 277 34% 47%;
    --sb-purple-80: 277 38% 38%;

    --sb-green-20: 123 40% 90%;
    --sb-green-80: 122 76% 20%;
  }

  :root {
    --primary-hover: var(--sb-core-80);
    --secondary-hover: var(--sb-core-80);
    --tertiary: var(--sb-core-0);
    --tertiary-foreground: var(--sb-core-60);
    --ai: var(--sb-purple-10);
    --ai-btn: var(--sb-purple-60);
    --ai-ring: var(--sb-purple-60);
    --ai-foreground: var(--sb-purple-80);
    --ai-border: var(--sb-purple-20);
    --run: var(--sb-yellow-50);
    --run-foreground: var(--sb-core-100);
    --run-ring: var(--sb-yellow-50);
    --inline-code: var(--sb-core-20);
    --inline-code-foreground: var(--foreground);
    --error: var(--sb-red-30);
    --error-foreground: var(--sb-red-80);
    --error-background-subtle: hsl(var(--sb-red-40) / 0.1);
    --warning: var(--sb-yellow-20);
    --warning-foreground: var(--sb-yellow-80);
    --warning-background-subtle: hsl(var(--sb-yellow-50) / 0.1);
  }

  .dark {
    --primary-hover: var(--sb-core-30);
    --secondary-hover: var(--sb-core-30);
    --tertiary: var(--sb-core-130);
    --tertiary-foreground: var(--sb-core-60);
    --ai: 277 42% 57% / 0.1;
    --ai-foreground: 269 100% 83%;
    --ai-border: 277 42% 57% / 0.2;
    --run: var(--sb-yellow-50);
    --run-foreground: var(--sb-core-100);
    --run-ring: var(--sb-yellow-50);
    --inline-code: var(--sb-core-110);
    --inline-code-foreground: var(--foreground);
    --error: var(--sb-red-30);
    --error-foreground: var(--sb-red-80);
    --error-background-subtle: hsl(var(--sb-red-40) / 0.1);
    --warning: var(--sb-yellow-20);
    --warning-foreground: var(--sb-yellow-80);
    --warning-background-subtle: hsl(var(--sb-yellow-50) / 0.1);
  }

  /* shadcn variables light */
  :root {
    --background: var(--sb-core-0);
    --foreground: var(--sb-core-100);
    --card: var(--sb-core-0);
    --card-foreground: var(--sb-core-100);
    --popover: var(--sb-core-0);
    --popover-foreground: var(--sb-core-100);
    --primary: var(--sb-core-100);
    --primary-foreground: var(--sb-core-0);
    --secondary: var(--sb-core-0);
    --secondary-foreground: var(--sb-core-100);
    --muted: var(--sb-core-10);
    --muted-foreground: var(--sb-core-30);
    --accent: var(--sb-blue-60);
    --accent-foreground: var(--sb-core-0);
    --destructive: var(--sb-red-40);
    --destructive-foreground: var(--sb-core-0);
    --border: var(--sb-core-30);
    --input: var(--sb-core-30);
    --ring: var(--sb-core-100);
  }

  /* shadcn variables dark */
  .dark {
    --background: var(--sb-core-130);
    --foreground: var(--sb-core-0);
    --card: var(--sb-core-130);
    --card-foreground: var(--sb-core-0);
    --popover: var(--sb-core-130);
    --popover-foreground: var(--sb-core-0);
    --primary: var(--sb-core-0);
    --primary-foreground: var(--sb-core-100);
    --secondary: var(--sb-core-130);
    --secondary-foreground: var(--sb-core-40);
    --muted: var(--sb-core-120);
    --muted-foreground: var(--sb-core-90);
    --accent: var(--sb-blue-60);
    --accent-foreground: var(--sb-core-0);
    --destructive: var(--sb-red-40);
    --destructive-foreground: var(--sb-core-0);
    --border: var(--sb-core-100);
    --input: var(--sb-core-100);
    --ring: var(--sb-core-0);
  }
}

@layer components {
  .title {
    font-size: 2rem;
    line-height: 1;
    font-weight: 500;
  }

  .h1 {
    font-size: 1.875rem;
    line-height: 2.375rem;
    font-weight: 500;
  }

  .h2 {
    font-size: 1.5rem;
    line-height: 2rem;
    font-weight: 500;
  }

  .h3 {
    font-size: 1.25rem;
    line-height: 1.875rem;
    font-weight: 500;
  }

  .h4 {
    font-size: 1.125rem;
    line-height: 1.75rem;
    font-weight: 500;
  }

  .h5 {
    font-size: 1rem;
    line-height: 1.5rem;
    font-weight: 500;
  }

  .p {
    font-size: 1rem;
    line-height: 1.5rem;
    font-weight: 300;
  }

  .code {
    @apply text-sm;
    @apply rounded-sm;
    @apply px-1;
    @apply py-0.5;
    @apply mx-0.5;
    @apply bg-muted;
    @apply text-inline-code-foreground;
  }

  .code-mini {
    @apply text-xs;
    @apply rounded-sm;
    @apply px-0.5;
    @apply bg-muted;
    @apply text-inline-code-foreground;
  }
}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }
}

.sb-prose {
  @apply font-sans;
  @apply text-base;
  @apply leading-7;
}

.sb-prose > *:first-child {
  margin-top: 0;
}

.sb-prose > *:last-child {
  margin-bottom: 0;
}

.sb-prose p {
  @apply my-3;
}

.sb-prose a {
  font-weight: bold;
  @apply underline;
  @apply decoration-2;
  @apply underline-offset-2;
}

.sb-prose a:hover {
  @apply text-primary-hover;
}

.sb-prose blockquote {
  @apply font-semibold;
  @apply my-5;
  @apply italic;
  @apply text-tertiary-foreground;
  @apply ps-5;
  @apply border-s-4;
  @apply border-s-border;
  quotes: '\201C' '\201D' '\2018' '\2019';
}

.sb-prose blockquote p:first-of-type::before {
  content: open-quote;
}

.sb-prose blockquote p:last-of-type::after {
  content: close-quote;
}

.sb-prose pre {
  @apply overflow-x-auto;
  @apply bg-muted;
  @apply text-foreground;
  @apply text-base;
  @apply p-4;
  @apply rounded-sm;
  @apply my-4;
}

.sb-prose code:not(pre code) {
  @apply code;
}

.sb-prose h1 > code,
.sb-prose h2 > code,
.sb-prose h3 > code,
.sb-prose h4 > code,
.sb-prose h5 > code {
  @apply font-mono;
  /* No way to avoid !important given specificity priority and the fact that we don't generate the HTML */
  font-size: 80% !important;
  @apply px-1.5 !important;
  @apply font-normal;
}

.sb-prose h1 {
  @apply h1;
  @apply my-5;
}

.sb-prose h2 {
  @apply h2;
  @apply my-5;
}

.sb-prose h3 {
  @apply h3;
  @apply my-4;
}

.sb-prose h4 {
  @apply h4;
  @apply my-3;
}

.sb-prose h5 {
  @apply h5;
  @apply my-3;
}

.sb-prose hr {
  @apply my-5;
}

.sb-prose ol {
  @apply list-decimal;
  @apply ps-6;
  margin: 1.15em 0;
}

.sb-prose ol > li:marker {
  @apply font-normal;
}

.sb-prose ul {
  @apply list-disc;
  @apply ps-6;
  margin: 1.15em 0;
}

.sb-prose li {
  margin: 5px 0;
}

.sb-prose ol > li {
  @apply ps-1.5;
  @apply my-1;
}

.sb-prose ul > li {
  @apply ps-1.5;
  @apply my-1;
}

.sb-prose img {
  border-radius: 3px;
}

.sb-prose-mini {
  @apply font-sans;
  @apply text-xs;
  @apply leading-3;
}

.sb-prose-mini > *:first-child {
  margin-top: 0;
}

.sb-prose-mini > *:last-child {
  margin-bottom: 0;
}

.sb-prose-mini p {
  @apply my-1;
}

.sb-prose-mini a {
  font-weight: 50;
  @apply underline;
  @apply decoration-1;
  @apply underline-offset-1;
}

.sb-prose-mini a:hover {
  @apply text-primary-hover;
}

.sb-prose-mini blockquote {
  @apply font-semibold;
  @apply my-3;
  @apply italic;
  @apply text-tertiary-foreground;
  @apply ps-2;
  @apply border-s-2;
  @apply border-s-border;
  quotes: '\201C' '\201D' '\2018' '\2019';
}

.sb-prose-mini blockquote p:first-of-type::before {
  content: open-quote;
}

.sb-prose-mini blockquote p:last-of-type::after {
  content: close-quote;
}

.sb-prose-mini pre {
  @apply text-xs;
  @apply overflow-x-auto;
  @apply bg-muted;
  @apply text-foreground;
  @apply p-2;
  @apply rounded-sm;
  @apply border;
  @apply border-border;
}

.sb-prose-mini code:not(pre code) {
  @apply code-mini;
}

.sb-prose-mini h1 > code,
.sb-prose-mini h2 > code,
.sb-prose-mini h3 > code,
.sb-prose-mini h4 > code,
.sb-prose-mini h5 > code {
  @apply font-mono;
  /* No way to avoid !important given specificity priority and the fact that we don't generate the HTML */
  font-size: 80% !important;
  @apply px-1.5 !important;
  @apply font-normal;
}

.sb-prose-mini h1 {
  @apply text-xl;
  @apply my-2;
}

.sb-prose-mini h2 {
  @apply text-lg;
  @apply my-2;
}

.sb-prose-mini h3 {
  @apply text-lg;
  @apply my-2;
}

.sb-prose-mini h4 {
  @apply text-sm;
  @apply my-1;
}

.sb-prose-mini h5 {
  @apply text-sm;
  @apply my-1;
}

.sb-prose-mini hr {
  @apply my-2;
}

.sb-prose-mini ol {
  @apply list-decimal;
  @apply ps-2;
  margin: 1.15em 0;
}

.sb-prose-mini ol > li:marker {
  @apply font-normal;
}

.sb-prose-mini ul {
  @apply list-disc;
  @apply ps-2;
  margin: 0.75em 0;
}

.sb-prose-mini li {
  margin: 3px 0;
}

.sb-prose-mini ol > li {
  @apply ps-1.5;
  @apply my-1;
}

.sb-prose-mini ul > li {
  @apply ps-1.5;
  @apply my-1;
}

.sb-prose-mini img {
  border-radius: 1.5px;
}

.sb-prose-chat {
  @apply font-sans;
  @apply text-sm;
  @apply leading-5;
}

.sb-prose-chat > *:first-child {
  margin-top: 0;
}

.sb-prose-chat > *:last-child {
  margin-bottom: 0;
}

.sb-prose-chat p {
  @apply my-2;
}

.sb-prose-chat a {
  font-weight: bold;
  @apply underline;
  @apply decoration-2;
  @apply underline-offset-2;
}

.sb-prose-chat a:hover {
  @apply text-primary-hover;
}

.sb-prose-chat blockquote {
  @apply font-medium;
  @apply my-3;
  @apply italic;
  @apply text-tertiary-foreground;
  @apply ps-4;
  @apply border-s-2;
  @apply border-s-border;
  quotes: '\201C' '\201D' '\2018' '\2019';
}

.sb-prose-chat blockquote p:first-of-type::before {
  content: open-quote;
}

.sb-prose-chat blockquote p:last-of-type::after {
  content: close-quote;
}

.sb-prose-chat pre {
  @apply overflow-x-auto;
  @apply bg-muted;
  @apply text-foreground;
  @apply p-3;
  @apply rounded-sm;
  @apply my-3;
}

.sb-prose-chat code:not(pre code) {
  @apply text-sm;
  @apply rounded-sm;
  @apply px-1;
  @apply py-0.5;
  @apply mx-0.5;
  @apply bg-muted;
  @apply text-inline-code-foreground;
}

.sb-prose-chat h1 > code,
.sb-prose-chat h2 > code,
.sb-prose-chat h3 > code,
.sb-prose-chat h4 > code,
.sb-prose-chat h5 > code {
  @apply font-mono;
  /* No way to avoid !important given specificity priority and the fact that we don't generate the HTML */
  font-size: 80% !important;
  @apply px-1.5 !important;
  @apply font-normal;
}

.sb-prose-chat h1 {
  font-size: 1.5rem;
  line-height: 2rem;
  font-weight: 500;
  @apply my-3;
}

.sb-prose-chat h2 {
  font-size: 1.25rem;
  line-height: 1.75rem;
  font-weight: 500;
  @apply my-3;
}

.sb-prose-chat h3 {
  font-size: 1.1rem;
  line-height: 1.675rem;
  font-weight: 500;
  @apply my-2;
}

.sb-prose-chat h4 {
  font-size: 1rem;
  line-height: 1.5rem;
  font-weight: 500;
  @apply my-2;
}

.sb-prose-chat h5 {
  font-size: 0.9rem;
  line-height: 1.4rem;
  font-weight: 500;
  @apply my-2;
}

.sb-prose-chat hr {
  @apply my-3;
}

.sb-prose-chat ol {
  @apply list-decimal;
  @apply ps-6;
  margin: 1em 0;
}

.sb-prose-chat ol > li:marker {
  @apply font-normal;
}

.sb-prose-chat ul {
  @apply list-disc;
  @apply ps-6;
  margin: 1em 0;
}

.sb-prose-chat li {
  margin: 3px 0;
}

.sb-prose-chat ol > li {
  @apply ps-1.5;
  @apply my-1;
}

.sb-prose-chat ul > li {
  @apply ps-1.5;
  @apply my-1;
}

.sb-prose-chat img {
  border-radius: 3px;
}

.cm-editor {
  @apply h-full;
  @apply rounded-b;
  @apply text-sm;
  @apply overflow-auto;
}

.cm-editor.cm-focused {
  outline: none;
  border: none;
}

.cm-editor .cm-gutters {
  @apply rounded-bl;
  @apply bg-background;
}

.cm-editor .cm-gutters .cm-gutterElement {
  @apply px-1.5;
  padding-top: 1px;
  font-size: 12px;
  min-width: 2rem;
}

.cm-editor .cm-gutters .cm-activeLineGutter {
  background-color: transparent;
}

.cm-editor .cm-scroller {
  overflow: auto;
  height: 100%;
}

.cm-editor .cm-gutters,
.cm-editor .cm-content {
  min-height: '100px';
}

.cm-editor del {
  text-decoration: none;
}

.cm-editor .cm-deletedChunk {
  background-color: rgba(248, 81, 73, 0.15);
}

.cm-editor.cm-merge-a .cm-changedLine,
.cm-editor.cm-merge-b .cm-changedLine {
  background-color: rgba(46, 160, 67, 0.15);
}

.cm-editor * {
  font-family: 'IBM Plex Mono', ui-monospace, 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas',
    'Liberation Mono', 'Courier New', 'monospace';
}

.cm-tooltip {
  @apply overflow-hidden;
  @apply !bg-background;
  @apply border;
  @apply shadow-md;
  @apply !border-border;
}

.cm-tooltip-autocomplete {
  @apply overflow-hidden;
  @apply !bg-background;
  @apply border;
  @apply shadow-md;
  @apply !border-border;
}

.cm-tooltip.cm-tooltip-autocomplete ul {
  font-family: 'IBM Plex Mono', ui-monospace, 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas',
    'Liberation Mono', 'Courier New', 'monospace';
}

.cm-tooltip.cm-tooltip-autocomplete ul li.custom-class {
  @apply !bg-muted;
  @apply !text-foreground;
  font-style: normal;
}

.cm-diagnostic {
  @apply ml-0;
  @apply !p-0;
}

.cm-tooltip-section:not(:first-child) {
  @apply !border-t-0;
}

================
File: web/src/Layout.tsx
================
import { useLoaderData } from 'react-router-dom';
import { Toaster } from '@srcbook/components/src/components/ui/sonner';
import { SettingsProvider } from '@/components/use-settings';
import { type SettingsType } from '@/types';
import { getConfig } from '@/lib/server';

export async function loader() {
  const { result: config } = await getConfig();

  return { config };
}

export default function Layout(props: { children: React.ReactNode }) {
  const { config } = useLoaderData() as { config: SettingsType };

  return (
    <>
      <SettingsProvider config={config}>{props.children}</SettingsProvider>

      <Toaster position="top-right" offset="20px" closeButton />
    </>
  );
}

================
File: web/src/LayoutNavbar.tsx
================
import { useLoaderData } from 'react-router-dom';
import { Toaster } from '@srcbook/components/src/components/ui/sonner';
import { SettingsProvider } from '@/components/use-settings';
import { type SettingsType } from '@/types';
import { getConfig } from '@/lib/server';
import { Navbar } from './components/navbar';

export async function loader() {
  const { result: config } = await getConfig();

  return { config };
}

export default function LayoutNavbar(props: { children: React.ReactNode }) {
  const { config } = useLoaderData() as { config: SettingsType };

  return (
    <>
      <div className="flex flex-col">
        <Navbar />

        <SettingsProvider config={config}>
          <div className="w-full max-w-[936px] mx-auto px-4 lg:px-0 py-12 mt-8">
            {props.children}
          </div>
        </SettingsProvider>
      </div>
      <Toaster position="top-right" offset="20px" closeButton />
    </>
  );
}

================
File: web/src/main.tsx
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import { createBrowserRouter, RouterProvider, Outlet } from 'react-router-dom';
import './index.css';
import Layout, { loader as configLoader } from './Layout';
import LayoutNavbar from './LayoutNavbar';
import Home, { loader as homeLoader } from './routes/home';
import { AppContext, AppProviders } from './routes/apps/context';
import AppPreview from './routes/apps/preview';
import AppFiles from './routes/apps/files';
import AppFilesShow from './routes/apps/files-show';
import {
  index as appIndex,
  preview as appPreview,
  filesShow as appFilesShow,
} from './routes/apps/loaders';
import Session from './routes/session';
import Settings from './routes/settings';
import Secrets from './routes/secrets';
import ErrorPage from './error';
import posthog from 'posthog-js';
import { PostHogProvider } from 'posthog-js/react';
import { DragAndDropSrcmdModal } from './components/drag-and-drop-srcmd-modal';

posthog.init('phc_bQjmPYXmbl76j8gW289Qj9XILuu1STRnIfgCSKlxdgu', {
  api_host: 'https://us.i.posthog.com',
  person_profiles: 'identified_only',
});

const router = createBrowserRouter([
  {
    path: '/',
    element: (
      <DragAndDropSrcmdModal>
        <Layout>
          <LayoutNavbar>
            <Home />
          </LayoutNavbar>
        </Layout>
      </DragAndDropSrcmdModal>
    ),
    errorElement: <ErrorPage />,
    loader: homeLoader,
  },
  {
    path: '/',
    element: (
      <Layout>
        <Outlet />
      </Layout>
    ),
    errorElement: <ErrorPage />,
    loader: configLoader,
    children: [
      {
        path: '/srcbooks/:id',
        loader: Session.loader,
        element: <Session />,
        errorElement: <ErrorPage />,
      },
      {
        path: '/apps/:id',
        loader: appIndex,
        element: <AppContext />,
        errorElement: <ErrorPage />,
        children: [
          {
            path: '',
            loader: appPreview,
            element: (
              <AppProviders>
                <AppPreview />
              </AppProviders>
            ),
          },
          {
            path: '/apps/:id/files',
            loader: appPreview,
            element: (
              <AppProviders>
                <AppFiles />
              </AppProviders>
            ),
          },
          {
            path: '/apps/:id/files/:path',
            loader: appFilesShow,
            element: (
              <AppProviders>
                <AppFilesShow />
              </AppProviders>
            ),
          },
        ],
      },
      {
        path: '/',
        element: (
          <LayoutNavbar>
            <Outlet />
          </LayoutNavbar>
        ),
        loader: configLoader,
        children: [
          {
            path: '/secrets',
            loader: Secrets.loader,
            element: <Secrets />,
            errorElement: <ErrorPage />,
          },
          {
            path: '/settings',
            element: <Settings />,
            errorElement: <ErrorPage />,
          },
        ],
      },
    ],
  },
]);

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <PostHogProvider client={posthog}>
      <RouterProvider router={router} />
    </PostHogProvider>
  </React.StrictMode>,
);

================
File: web/src/types.ts
================
import { CellType, CodeLanguageType, AiProviderType } from '@srcbook/shared';

export interface FsObjectType {
  path: string;
  dirname: string;
  basename: string;
  isDirectory: boolean;
}

export type SettingsType = {
  baseDir: string;
  defaultLanguage: CodeLanguageType;
  openaiKey?: string | null;
  anthropicKey?: string | null;
  xaiKey?: string | null;
  geminiKey?: string | null;
  aiProvider: AiProviderType;
  customApiKey: string | null;
  aiModel: string;
  aiBaseUrl?: string | null;
  subscriptionEmail?: string | null;
};

export type SessionType = {
  id: string;
  cells: CellType[];
  language: CodeLanguageType;
  'tsconfig.json'?: string;
  openedAt: number;
};

export type ExampleSrcbookType = {
  id: string;
  path: string;
  title: string;
  dirname: string;
  language: CodeLanguageType;
  description: string;
  tags: string[];
};

================
File: web/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: web/.env.development
================
VITE_SRCBOOK_API_HOST="'localhost:2150'"
VITE_SRCBOOK_API_ORIGIN="'http://localhost:2150'"

================
File: web/.env.production
================
VITE_SRCBOOK_API_HOST="window.location.host"
VITE_SRCBOOK_API_ORIGIN="window.location.origin"

================
File: web/.eslintrc.cjs
================
/** @type {import("eslint").Linter.Config} */
module.exports = {
  root: true,
  extends: [require.resolve('@srcbook/configs/eslint/react.js')],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: './tsconfig.lint.json',
    tsconfigRootDir: __dirname,
  },
  globals: {
    Bun: false,
  },
};

================
File: web/CHANGELOG.md
================
# @srcbook/web

## 0.0.15

### Patch Changes

- fcabe77: Add support for API keys on openAI compatible models

## 0.0.14

### Patch Changes

- a236470: Add gemini support
- Updated dependencies [a236470]
  - @srcbook/shared@0.0.13
  - @srcbook/components@0.0.7

## 0.0.13

### Patch Changes

- 727bab7: Support X ai models
- 2e774d4: Support streaming of the responses!
- Updated dependencies [727bab7]
- Updated dependencies [2e774d4]
  - @srcbook/shared@0.0.12
  - @srcbook/components@0.0.6

## 0.0.12

### Patch Changes

- b49bdf4: The backend now notifies the frontend of file changes -> files update visually in realtime
- bbbd5d6: Add versions! powered by git. Ability to revert to an older version
- Updated dependencies [b49bdf4]
- Updated dependencies [bbbd5d6]
  - @srcbook/shared@0.0.11
  - @srcbook/components@0.0.5

## 0.0.11

### Patch Changes

- 4e9b37b: Ability to open app in new tab. Better packages handling after creation

## 0.0.10

### Patch Changes

- ccd8d01: Introduce app builder
- 5fa7e4b: Fix undo/redo history affecting multiple files after switching in codeMirror
- 73cd6e8: support backend hmr
- Updated dependencies [ccd8d01]
- Updated dependencies [73cd6e8]
  - @srcbook/components@0.0.4
  - @srcbook/shared@0.0.10

## 0.0.9

### Patch Changes

- 459b18d: Deploy all packages
- Updated dependencies [459b18d]
  - @srcbook/components@0.0.3
  - @srcbook/shared@0.0.9

## 0.0.8

### Patch Changes

- 24c841e: Update websocket client to pass context and connection
- 1a80ba8: Improve styling of typescript hover box
- Updated dependencies [24c841e]
  - @srcbook/components@0.0.2
  - @srcbook/shared@0.0.8

## 0.0.7

### Patch Changes

- f75be08: Add Ability to create secrets within a Srcbook [3091604](https://github.com/srcbookdev/srcbook/commit/30916042f1f2af937c8b188d794c522408e9c4e0)
- 691f81f: 480bf57: Adds autocomplete support!
- Updated dependencies [691f81f]
  - @srcbook/shared@0.0.7

## 0.0.6

### Patch Changes

- 98ffcb3: Improve mermaid rendering
- 0eb51dd: Added support for goto def with Alt(Option) + Click
- 3c912b9: b365ee5: Improved import and export behaviors to support importing from a url/clipboard, and exporting to the clipboard
- Updated dependencies [0eb51dd]
  - @srcbook/shared@0.0.6

## 0.0.5

### Patch Changes

- 8c99a0d: Fix broken NPM package
- Updated dependencies [8c99a0d]
  - @srcbook/shared@0.0.5

## 0.0.4

### Patch Changes

- e335100: Add support for mermaid diagrams (#282, 99b87a0)
- 50291e5: Visual tweaks when missing AI configuration, and Prettier logo size"
- 394d369: Secrets must now be enabled per Srcbook
- 773ceec: Theme improvements for mermaid diagrams
- Updated dependencies [9f0a632]
  - @srcbook/shared@0.0.4

## 0.0.3

### Patch Changes

- 2923ffc: Various small UI fixes and improvements
- b5ab034: Added an upsell to subscribe to our mailing list + ability to update in settings
- 4af9c95: Fix individual deps not installing when prompted
- 22e6ca0: Implemented new navbar and sidebar features
- 545699e: Add Prettier Support to Code Notebook
- 833264c: Underlying dependency bumps for maintenence
- Updated dependencies [545699e]
- Updated dependencies [833264c]
  - @srcbook/shared@0.0.3

## 0.0.2

### Patch Changes

- Updated dependencies [735deb8]
  - @srcbook/shared@0.0.2

## 0.0.1

### Patch Changes

- 4e04909: hover tooltips, tooling improvements, new contributors effyzhang 1egoman!
- 7dd383b: fix display bug where tiny empty tooltip would appear when no quickinfo from tsserver
- a0901db: Implement jsx-a11y acessibility rules across the package with minor exception for tabindexes in one component
- Updated dependencies [4e04909]
  - @srcbook/shared@0.0.1

================
File: web/components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}

================
File: web/index.html
================
<!doctype html>
<html lang="en" class="dark scroll-smooth scroll-pt-12">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Srcbook</title>
    <script type="text/javascript">
      (function (theme) {
        if (theme === null) {
          return;
        }

        const html = document.querySelector('html');

        if (theme === 'light') {
          html.classList.remove('dark');
          html.classList.add('light');
        }
      })(localStorage.getItem('sb:theme'));
    </script>
    <script type="text/javascript">
      globalThis.SRCBOOK_CONFIG = {
        api: {
          host: %VITE_SRCBOOK_API_HOST%,
          origin: %VITE_SRCBOOK_API_ORIGIN%,
        },
      };
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: web/package.json
================
{
  "name": "@srcbook/web",
  "private": true,
  "version": "0.0.15",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "prebuild": "rm -rf ./dist",
    "build": "tsc && vite build && cp -R ./dist/. ../../srcbook/public",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "format": "prettier --write .",
    "preview": "vite preview",
    "check-types": "tsc"
  },
  "dependencies": {
    "@codemirror/autocomplete": "^6.18.1",
    "@codemirror/lang-css": "^6.3.0",
    "@codemirror/lang-html": "^6.4.9",
    "@codemirror/lang-javascript": "^6.2.2",
    "@codemirror/lang-json": "^6.0.1",
    "@codemirror/lang-markdown": "^6.2.5",
    "@codemirror/lint": "^6.8.1",
    "@codemirror/merge": "^6.7.0",
    "@codemirror/state": "^6.4.1",
    "@srcbook/components": "workspace:^",
    "@srcbook/shared": "workspace:^",
    "@uiw/codemirror-themes": "^4.23.2",
    "@uiw/react-codemirror": "^4.23.2",
    "clsx": "^2.1.1",
    "codemirror": "^6.0.1",
    "diff": "^7.0.0",
    "lucide-react": "^0.439.0",
    "marked": "catalog:",
    "marked-react": "^2.0.0",
    "posthog-js": "^1.174.2",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-dropzone": "^14.2.3",
    "react-hotkeys-hook": "^4.5.1",
    "react-router-dom": "^6.26.2",
    "react-textarea-autosize": "^8.5.3",
    "sonner": "^1.5.0",
    "tailwind-merge": "^2.5.2",
    "tailwindcss-animate": "^1.0.7",
    "use-debounce": "^10.0.3",
    "zod": "catalog:"
  },
  "devDependencies": {
    "@types/diff": "^5.2.3",
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.7.0",
    "autoprefixer": "^10.4.20",
    "chokidar": "^4.0.1",
    "postcss": "^8.4.45",
    "tailwindcss": "^3.4.11",
    "vite": "^5.4.4"
  }
}

================
File: web/postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: web/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
import plugin from 'tailwindcss/plugin';
import path from 'path';
import { createRequire } from 'module';
import animate from 'tailwindcss-animate';

// Create require function for resolving package paths
const require = createRequire(import.meta.url);

export default {
  darkMode: ['class'],
  content: [
    './index.html',
    './src/**/*.{css,ts,tsx}',
    path.join(path.dirname(require.resolve('@srcbook/components')), '**/*.{css,js,ts,tsx}'),
  ],
  prefix: '',
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      fontFamily: {
        sans: [
          'Instrument Sans',
          'ui-sans-serif',
          'system-ui',
          'sans-serif',
          'Apple Color Emoji',
          'Segoe UI Emoji',
          'Segoe UI Symbol',
          'Noto Color Emoji',
        ],
        mono: [
          'IBM Plex Mono',
          'ui-monospace',
          'SFMono-Regular',
          'Menlo',
          'Monaco',
          'Consolas',
          'Liberation Mono',
          'Courier New',
          'monospace',
        ],
      },
      colors: {
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          hover: 'hsl(var(--primary-hover))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          hover: 'hsl(var(--secondary-hover))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        tertiary: {
          DEFAULT: 'hsl(var(--tertiary))',
          foreground: 'hsl(var(--tertiary-foreground))',
        },
        run: {
          DEFAULT: 'hsl(var(--run))',
          foreground: 'hsl(var(--run-foreground))',
          ring: 'hsl(var(--run-ring))',
        },
        'inline-code': {
          DEFAULT: 'hsl(var(--inline-code))',
          foreground: 'hsl(var(--inline-code-foreground))',
        },
        error: {
          DEFAULT: 'hsl(var(--error))',
          foreground: 'hsl(var(--error-foreground))',
        },
        warning: {
          DEFAULT: 'hsl(var(--warning))',
          foreground: 'hsl(var(--warning-foreground))',
        },
        ai: {
          DEFAULT: 'hsl(var(--ai))',
          foreground: 'hsl(var(--ai-foreground))',
          border: 'hsl(var(--ai-border))',
          btn: 'hsl(var(--ai-btn))',
          ring: 'hsl(var(--ai-ring))',
        },
        sb: {
          'core-0': 'hsl(var(--sb-core-0))',
          'core-10': 'hsl(var(--sb-core-10))',
          'core-20': 'hsl(var(--sb-core-20))',
          'core-30': 'hsl(var(--sb-core-30))',
          'core-40': 'hsl(var(--sb-core-40))',
          'core-50': 'hsl(var(--sb-core-50))',
          'core-60': 'hsl(var(--sb-core-60))',
          'core-70': 'hsl(var(--sb-core-70))',
          'core-80': 'hsl(var(--sb-core-80))',
          'core-90': 'hsl(var(--sb-core-90))',
          'core-100': 'hsl(var(--sb-core-100))',
          'core-110': 'hsl(var(--sb-core-110))',
          'core-120': 'hsl(var(--sb-core-120))',
          'core-130': 'hsl(var(--sb-core-130))',
          'core-140': 'hsl(var(--sb-core-140))',
          'core-150': 'hsl(var(--sb-core-150))',
          'core-160': 'hsl(var(--sb-core-160))',

          'yellow-10': 'hsl(var(--sb-yellow-10))',
          'yellow-20': 'hsl(var(--sb-yellow-20))',
          'yellow-30': 'hsl(var(--sb-yellow-30))',
          'yellow-40': 'hsl(var(--sb-yellow-40))',
          'yellow-50': 'hsl(var(--sb-yellow-50))',
          'yellow-60': 'hsl(var(--sb-yellow-60))',
          'yellow-70': 'hsl(var(--sb-yellow-70))',
          'yellow-80': 'hsl(var(--sb-yellow-80))',

          'red-10': 'hsl(var(--sb-red-10))',
          'red-20': 'hsl(var(--sb-red-20))',
          'red-30': 'hsl(var(--sb-red-30))',
          'red-40': 'hsl(var(--sb-red-40))',
          'red-50': 'hsl(var(--sb-red-50))',
          'red-60': 'hsl(var(--sb-red-60))',
          'red-70': 'hsl(var(--sb-red-70))',
          'red-80': 'hsl(var(--sb-red-80))',

          'blue-10': 'hsl(var(--sb-blue-10))',
          'blue-20': 'hsl(var(--sb-blue-20))',
          'blue-30': 'hsl(var(--sb-blue-30))',
          'blue-40': 'hsl(var(--sb-blue-40))',
          'blue-50': 'hsl(var(--sb-blue-50))',
          'blue-60': 'hsl(var(--sb-blue-60))',
          'blue-70': 'hsl(var(--sb-blue-70))',
          'blue-80': 'hsl(var(--sb-blue-80))',

          'purple-10': 'hsl(var(--sb-purple-10))',
          'purple-20': 'hsl(var(--sb-purple-20))',
          'purple-60': 'hsl(var(--sb-purple-60))',
          'purple-70': 'hsl(var(--sb-purple-70))',
          'purple-80': 'hsl(var(--sb-purple-80))',

          'green-20': 'hsl(var(--sb-green-20))',
          'green-80': 'hsl(var(--sb-green-80))',
        },
      },
      dropShadow: {
        key: '0 1px 0 hsl(var(--border))', // for keyboard shortcuts. border-border 1px straight down
      },
      borderRadius: {
        sm: '0.1875rem', // 3px
        mid: '0.375rem', // 6px
        md: '0.4375rem', // 7px
      },
      transitionProperty: {
        height: 'height',
        spacing: 'margin, padding',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
        'collapsible-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-collapsible-content-height)' },
        },
        'collapsible-up': {
          from: { height: 'var(--radix-collapsible-content-height)' },
          to: { height: '0' },
        },
        indeterminate: {
          '0%': { transform: 'translateX(-100%)' },
          '100%': { transform: 'translateX(100%)' },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
        'collapsible-down': 'collapsible-down 1s ease-out',
        'collapsible-up': 'collapsible-up 1s ease-out',
        indeterminate: 'indeterminate 1s infinite linear',
      },
      typography: {
        DEFAULT: {
          css: {
            // Remove visible backticks by overriding code::before and code::after
            // https://github.com/tailwindlabs/tailwindcss-typography/issues/18
            'code::before': {
              content: '""',
            },
            'code::after': {
              content: '""',
            },
          },
        },
      },
    },
  },
  plugins: [animate],
};

================
File: web/tsconfig.json
================
{
  "extends": "@srcbook/configs/ts/react-library.json",
  "compilerOptions": {
    "target": "ES2020",
    "outDir": "dist",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src", "tests"],
  "exclude": ["node_modules", "dist"]
}

================
File: web/tsconfig.lint.json
================
{
  "include": ["src", "vite.config.ts", "drizzle.config.ts"],
  "exclude": ["node_modules", "dist"]
}

================
File: web/vite.config.ts
================
import path from 'path';
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc';
import chokidar from 'chokidar';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    react(),
    // reload on backend change
    {
      name: 'backend-watch-reload',
      configureServer(server) {
        const watcher = chokidar.watch('../api', {
          persistent: true,
          ignored: (file, stats) => !!stats?.isFile() && !file.endsWith('.mts'),
        });
        watcher.on('change', () => {
          server.ws.send({
            type: 'full-reload',
          });
        });
      },
    },
  ],

  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
